<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[建立稳定、安全的通信连接]]></title>
    <url>%2F2019%2F01%2F21-stable-security-connect-way%2F</url>
    <content type="text"><![CDATA[建立稳定、安全的通信连接连接阿里云、腾讯云服务器时，有时网络不稳定，经常出现断网情况。有很多能增强连接稳定性与安全性的方式。比如PPTP、L2TP、IPSec、IKEv2等，这里介绍使用PPTP、IKEv2方式来有效解决这类问题。 环境准备1、新装 Ubuntu 16.04.5 (其余操作系统类似，除了安装软件方式有区别外) ubuntu16开始使用apt代替apt-get，在使用上没有什么差别。 安装准备执行 12apt updateapt -f install tree lrzsz git-core 可以安装上nginx，也可以不装。 1apt -f install nginx 安装步骤前提准备1、防火墙、IP转发等 ubuntu默认使用ufw。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667681、切换到root账户sudo su2、切换到/devcd /etc3、修改ufw默认配置vim /etc/default/ufw修改DEFAULT_FORWARD_POLICY=&quot;DROP&quot;为DEFAULT_FORWARD_POLICY=&quot;ACCEPT&quot;4、修改sysctl.confvim /etc/ufw/sysctl.conf反注释为：# Uncomment this to allow this host to route packets between interfacesnet/ipv4/ip_forward=1net/ipv6/conf/default/forwarding=1net/ipv6/conf/all/forwarding=15、修改ufw防火墙配置vim /etc/ufw/before.rules在指定位置插入：## rules.before## Rules that should be run before the ufw command line added rules. Custom# rules should be added to one of these chains:# ufw-before-input# ufw-before-output# ufw-before-forward################################################################################ 指定位置加入nat配置*nat:PREROUTING ACCEPT [0:0]# 在有的服务提供商是这两条生效，注意eth0不同机器可能不一样，使用ifconfig可以判断实际是哪一个# -A PREROUTING -i eth0 -p tcp --dport 1723 -j DNAT --to xx.xx.xx.xx# -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j SNAT --to xx.xx.xx.xx# PPTP使用-A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE# IKEv2使用-A POSTROUTING -s 10.31.2.0/24 -o eth0 -j MASQUERADECOMMIT############################################################################### Don&apos;t delete these required lines, otherwise there will be errors*filter:ufw-before-input - [0:0]:ufw-before-output - [0:0]:ufw-before-forward - [0:0]:ufw-not-local - [0:0]# End required lines6、打开ufw的特定入端口# IKEv2基于UDP，使用500、4500ufw allow 500ufw allow 4500# PPTP基于TCP，使用1723ufw allow 1723# 申请证书使用ufw allow 80其余端口比如SSH视自身情况而定。7、重启服务器 配置PPTP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061621、安装pptpdapt -f install pptpd2、配置pptpd.conf反注释：# be set to the given one. You MUST still give at least one remote# IP for each simultaneous client.## (Recommended)##############################################################################localip 192.168.0.1remoteip 192.168.0.234-238,192.168.0.245############################################################################### or#localip 192.168.0.234-238,192.168.0.245#remoteip 192.168.1.234-238,192.168.1.2453、配置pppvim /etc/ppp/pptpd-options 修改为：# If pppd is acting as a server for Microsoft Windows clients, this# option allows pppd to supply one or two DNS (Domain Name Server)# addresses to the clients. The first instance of this option# specifies the primary DNS address; the second instance (if given)# specifies the secondary DNS address.# Attention! This information may not be taken into account by a Windows# client. See KB311218 in Microsoft&apos;s knowledge base for more information.###############################################################################ms-dns 8.8.8.8#ms-dns 8.8.4.4ms-dns 223.5.5.5ms-dns 223.6.6.6############################################################################### If pppd is acting as a server for Microsoft Windows or &quot;Samba&quot;# clients, this option allows pppd to supply one or two WINS (Windows# Internet Name Services) server addresses to the clients. The first# instance of this option specifies the primary WINS address; the# second instance (if given) specifies the secondary WINS address.###############################################################################ms-wins 8.8.8.8#ms-wins 8.8.4.4ms-wins 223.5.5.5ms-wins 223.6.6.6##############################################################################4、修改chap验证vim /etc/ppp/chap-secrets增加pptp服务使用的chap账号# Secrets for authentication using CHAP# client server secret IP addresses##############################################################################user pptpd pass *##############################################################################5、启用pptpd服务开启自启动systemctl enable pptpd6、重启服务器，配置完毕netstat -ant可以看到1723端口已经监听 PPTP协议简单，配置方便，无需证书，兼容性好。但是连接有时也会受到干扰，建议使用IKEv2方式。 配置IKEv2签发自有证书IKEv2建议配置证书方式+账号密码验证，这样安全性很高。 证书可以选择rsa方式自己生成一个，但是缺点是客户端需要安装证书并信任，比较麻烦，这里不推荐。 使用letsencrypt，结合自己的域名，签署一个自然信任的证书，这样客户端不用安装额外自定义证书，很方便。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031、下载letsencrypt切换到自己的home目录下，下载letsencryptgit clone https://github.com/letsencrypt/letsencrypt然后cd letsencrypt执行./letsencrypt-auto --help会安装一些必须环境，比如python环境。在配置过程中，可能会遇到如下提示：Creating virtual environment...Traceback (most recent call last): File &quot;/usr/lib/python3/dist-packages/virtualenv.py&quot;, line 2363, in &lt;module&gt; main() File &quot;/usr/lib/python3/dist-packages/virtualenv.py&quot;, line 719, in main symlink=options.symlink) File &quot;/usr/lib/python3/dist-packages/virtualenv.py&quot;, line 988, in create_environment download=download, File &quot;/usr/lib/python3/dist-packages/virtualenv.py&quot;, line 918, in install_wheel call_subprocess(cmd, show_stdout=False, extra_env=env, stdin=SCRIPT) File &quot;/usr/lib/python3/dist-packages/virtualenv.py&quot;, line 812, in call_subprocess % (cmd_desc, proc.returncode))OSError: Command /opt/eff.org/certbot/venv/bin/python2.7 - setuptools pkg_resources pip wheel failed with error code 2执行可以解决：pip install setuptoolspip install --upgrade setuptoolspip install virtualenvpip install --upgrade virtualenv如果还是不行，强制重装pip，比如重新安装成最新版pip，再执行以上步骤。执行成功后会提示如下：Creating virtual environment...Installing Python packages...Installation succeeded.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - letsencrypt-auto [SUBCOMMAND] [options] [-d DOMAIN] [-d DOMAIN] ...Certbot can obtain and install HTTPS/TLS/SSL certificates. By default,it will attempt to use a webserver both for obtaining and installing thecertificate. The most common SUBCOMMANDS and flags are:...2、签发证书./letsencrypt-auto certonly --server https://acme-v01.api.letsencrypt.org/directory --agree-dev-preview会有以下选择：How would you like to authenticate with the ACME CA?- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -1: Nginx Web Server plugin (nginx)2: Spin up a temporary webserver (standalone)3: Place files in webroot directory (webroot)- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -因为已经安装了nginx，最简单的就是选择3。Enter email address (used for urgent renewal and security notices) (Enter &apos;c&apos; tocancel): aaa@bbb.com- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Please read the Terms of Service athttps://letsencrypt.org/documents/LE-SA-v1.2-November-15-2017.pdf. You mustagree in order to register with the ACME server athttps://acme-v01.api.letsencrypt.org/directory- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -(A)gree/(C)ancel: a- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Would you be willing to share your email address with the Electronic FrontierFoundation, a founding partner of the Let&apos;s Encrypt project and the non-profitorganization that develops Certbot? We&apos;d like to send you email about our workencrypting the web, EFF news, campaigns, and ways to support digital freedom.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -(Y)es/(N)o: yPlease enter in your domain name(s) (comma and/or space separated) (Enter &apos;c&apos;to cancel): xxx.yyy.zzzObtaining a new certificatePerforming the following challenges:http-01 challenge for xxx.yyy.zzzInput the webroot for xxx.yyy.zzz: (Enter &apos;c&apos; to cancel): /var/www/htmlWaiting for verification...Cleaning up challengesUse of --agree-dev-preview is deprecated.IMPORTANT NOTES: - Congratulations! Your certificate and chain have been saved at: /etc/letsencrypt/live/xxx.yyy.zzz/fullchain.pem Your key file has been saved at: /etc/letsencrypt/live/xxx.yyy.zzz/privkey.pem Your cert will expire on 2019-04-21. To obtain a new or tweaked version of this certificate in the future, simply run letsencrypt-auto again. To non-interactively renew *all* of your certificates, run &quot;letsencrypt-auto renew&quot; - If you like Certbot, please consider supporting our work by: Donating to ISRG / Let&apos;s Encrypt: https://letsencrypt.org/donate Donating to EFF: https://eff.org/donate-le至此，就成功生成了证书。注意：证书三个月后会过期，可以使用定时任务脚本去定期更新 配置strongswan1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141、安装strongswanapt -f install strongswan*安装所有的stringswan插件，避免缺失插件造成功能不全。2、复制letsencrypt生成的证书cp /etc/letsencrypt/live/xxx.yyy.zzz/chain.pem /etc/ipsec.d/cacerts/ca.cert.pem cp /etc/letsencrypt/live/xxx.yyy.zzz/cert.pem /etc/ipsec.d/certs/server.cert.pem cp /etc/letsencrypt/live/xxx.yyy.zzz/privkey.pem /etc/ipsec.d/private/server.pem 结构如下：.├── aacerts├── acerts├── cacerts│ └── ca.cert.pem├── certs│ └── server.cert.pem├── crls├── ocspcerts├── policies├── private│ └── server.pem└── reqs注意pem文件权限。3、编辑strongswan.confvim /etc/strongswan.conf# strongswan.conf - strongSwan configuration file## Refer to the strongswan.conf(5) manpage for details## Configuration changes should be made in the included filescharon &#123; load_modular = yes duplicheck.enable = no compress = yes plugins &#123; include strongswan.d/charon/*.conf &#125; #dns1 = 8.8.8.8 #dns2 = 8.8.4.4 #nbns1 = 8.8.8.8 #nbns2 = 8.8.4.4 dns1 = 223.5.5.5 dns2 = 223.6.6.6 nbns1 = 223.5.5.5 nbns2 = 223.6.6.6&#125;include strongswan.d/*.conf4、编辑ipsec.secrets vim /etc/ipsec.secrets # This file holds shared secrets or RSA private keys for authentication.# RSA private key for this host, authenticating it to any other host# which knows the public part.: RSA server.pem#: PSK &quot;myPSKkey&quot;#: XAUTH &quot;myXAUTHPass&quot;user %any : EAP &quot;pass&quot;5、编辑ipsec.confvim /etc/ipsec.confconfig setup uniqueids=never conn ikev2 keyexchange=ikev2 ike=aes256-sha256-modp2048,3des-sha1-modp2048,aes256-sha1-modp2048! esp=aes256-sha256,3des-sha1,aes256-sha1! rekey=no left=%defaultroute leftid=@xxx.yyy.zzz leftsendcert=always leftsubnet=0.0.0.0/0 leftcert=server.cert.pem right=%any rightauth=eap-mschapv2 rightsourceip=10.31.2.0/24 rightsendcert=never eap_identity=%any dpdaction=clear fragmentation=yes auto=add6、重启服务器7、查看ipsecipsec statusallStatus of IKE charon daemon (strongSwan 5.3.5, Linux 4.4.0-141-generic, x86_64): uptime: 4 seconds, since Jan 21 13:07:17 2019 malloc: sbrk 1765376, mmap 532480, used 1025520, free 739856 worker threads: 11 of 16 idle, 5/0/0/0 working, job queue: 0/0/0/0, scheduled: 0 loaded plugins: charon test-vectors unbound ldap pkcs11 aes rc2 sha1 sha2 md4 md5 rdrand random nonce x509 revocation constraints acert pubkey pkcs1 pkcs7 pkcs8 pkcs12 pgp dnskey sshkey dnscert ipseckey pem openssl gcrypt af-alg fips-prf gmp agent chapoly xcbc cmac hmac ctr ccm gcm ntru bliss curl soup mysql sqlite attr kernel-netlink resolve socket-default connmark farp stroke updown eap-identity eap-sim eap-sim-pcsc eap-aka eap-aka-3gpp2 eap-simaka-pseudonym eap-simaka-reauth eap-md5 eap-gtc eap-mschapv2 eap-dynamic eap-radius eap-tls eap-ttls eap-peap eap-tnc xauth-generic xauth-eap xauth-pam xauth-noauth tnc-imc tnc-imv tnc-tnccs tnccs-20 tnccs-11 tnccs-dynamic dhcp whitelist lookip error-notify certexpire led radattr addrblock unityVirtual IP pools (size/online/offline): 10.31.2.0/24: 254/0/0Listening IP addresses: 172.xx.xx.xxConnections: ikev2: %any...%any IKEv2, dpddelay=30s ikev2: local: [xxx.yyy.zzz] uses public key authentication ikev2: cert: &quot;CN=xxx.yyy.zzz&quot; ikev2: remote: uses EAP_MSCHAPV2 authentication with EAP identity &apos;%any&apos; ikev2: child: 0.0.0.0/0 === dynamic TUNNEL, dpdaction=clearSecurity Associations (0 up, 0 connecting): none 建立连接1、安卓手机 直接在系统设置里，新建VPN连接，选择PPTP协议或IKEv2，输入服务器域名、账号、密码即可。 2、苹果手机 在系统设计里，新建VPN，IOS最近版本只能选择IKEv2，远程ID输入上述的xxx.yyy.zzz，再输入服务器域名、账号、密码即可。 3、Windows系统 系统设置里，新建VPN连接，选择PPTP协议或IKEv2，输入服务器域名、账号、密码即可。另外，在控制面板，找到”你的VPN连接名”，右键属性，选择网络，打开”Internet协议”属性，在高级设置里，勾选”在远程网络上使用默认网关”。 4、Mac系统 系统设置里，新建IKEv2连接，远程ID输入上述的xxx.yyy.zzz，再输入服务器域名、账号、密码即可。 经验技巧1tail -200f /var/log/syslog 查看连接日志，能有效排除一些配置中遇到的问题。 如果发现连接成功没有成功上网：1、检查DNS是否可用（可以本地客户端设置自己的DNS服务器地址）2、检查服务器防火墙配置 如果发现突然连接不上：1、更换服务器IP]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java单例设计模式]]></title>
    <url>%2F2018%2F08%2F23-java-singleton%2F</url>
    <content type="text"><![CDATA[Java单例设计模式从实习到毕业工作，一晃就过去了快两个月。毕业之后的时间远远没有在学校多，主要时间还是做着工作上的事。刚毕业，也需要适应工作的节奏，工作的节奏不同于在学校学习的节奏，时间是需要挤出来的。从毕业到现在工作，虽然只有两个月的时间，不过自己的感触良多，包括生活、社会、工作，感觉自身变化还是很多的，有些变化能用言语表达出来，而有些变化确实悄然的变化，难以用言语表述。打开尘封了两个多月的博客地址，忽然发现更换了电脑，但是自己原本搭建在旧电脑上的Hexo虚拟机没有能及时备份，早已不复存在，好在博客原始文件一直有备份在云端的习惯。忙碌了两个月，上线了一个项目，其中也体会到互联网这一行加班的常态，两点一线的家与公司的时光。感触良多，好在现在略微闲了下来，也能静下心来思考一下。给电脑安装上虚拟机，装上Ubuntu18，再安装好Hexo，配好Next主题，发现无论Hexo还是Next，当初的不足已经被完善，无需再修改代码，一切需求都被官方囊括。互联网是一直在发展着的，技术上无论小到像Hexo这样的博客，还是大到各种中间件、框架、组合，业务上也是一样的，时刻都在变化着。恢复好博客，曾经的评论与浏览量也从零开始计算，博客样式的细节处也完善的很好。 最后，附上一个天然线程安全的，可以防止序列化和反射攻击，性能良好的，具有懒加载特性的单例模式。 单例模式1234567891011121314151617181920public final class EnumSingleton &#123; private enum InstanceEnum &#123; INSTANCE; private EnumSingleton instance; private InstanceEnum() &#123; this.instance = new EnumSingleton(); &#125; &#125; private EnumSingleton() &#123; &#125; public static EnumSingleton getInstance() &#123; return InstanceEnum.INSTANCE.instance; &#125;&#125; 现在最怀念的还是能在慵懒的春光中，充满着生气的湖边，刚抽条的柳树下，躺在长椅上，什么都不用做，听鸟叫，水响，看童戏，叶婆娑，渔者钓。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[毕业设计总结]]></title>
    <url>%2F2018%2F06%2F02-graduation-project%2F</url>
    <content type="text"><![CDATA[毕业设计总结本科在学校的生涯即将结束，在此对自己的毕业设计做一个概况总结。 架构 结构 结果 总结毕业设计主要是盲人语音导盲系统，结合实时的视频图像处理。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何抓取小程序的数据包]]></title>
    <url>%2F2018%2F05%2F05-how-to-capture-packet-https%2F</url>
    <content type="text"><![CDATA[如何抓取小程序的数据包开发需要，需要抓取小程序的数据包，查看前端的数据请求。 软件Fiddler 步骤针对安卓智能手机，抓取小程序的包。（如果是小米的应用分身的话，还没有研究出来怎么抓包）苹果系统的抓包方式类似，没有尝试过。安卓的证书认证方式和苹果有点区别。 1、1) 电脑首先安装好Fiddler，然后开启WiFi热点（Windows10自带的蛮好用的），比如Dell-AP。2) 设置防火墙入规则允许8888。3) 通过ipconfig确定本机热点的网关地址。比如192.168.137.1。 2、1) 勾选Fiddler中Options中的HTTPS选项中的Capture HTTPS CONNECTS、Decrypt HTTPS traffic、Ignore server certificate errors。2) 勾选Fiddler中Options中的Connections中的allow remote computers to connect。保持端口8888不变。（端口冲突的话，第一步中防火墙以及第三步中的端口都需保持一致，比如均需要修改设置为8808）。3) 关闭并重新打开Fiddler。 3、1) 安卓手机连接上电脑的热点，然后在手机设置里的无线设置，选择自定义热点连接的Proxy，设置好主机为第一步获取到的网关地址，比如192.168.137.1，端口为8888。2) 浏览器访问http://192.168.137.1:8888，下载Fiddler的证书，并使用手机中的证书管理（一般在手机设置 隐私 选项里）安装好这个证书。设置使用范围是APP。 4、之后可以用手机访问百度主页，观察电脑上的Fiddler，可以看到成功抓到数据包，并能查看HTTPS的内容。小程序也是可以的了。 总结转自知乎，Fiddler抓取https的原理： 首先fiddler截获客户端浏览器发送给服务器的https请求，此时还未建立握手。第一步，fiddler向服务器发送请求进行握手，获取到服务器的CA证书，用根证书公钥进行解密，验证服务器数据签名，获取到服务器CA证书公钥。第二步，fiddler伪造自己的CA证书，冒充服务器证书传递给客户端浏览器，客户端浏览器做跟fiddler在第一步一样的事（手机中已经安装了Fiddler的根证书，所以是可以验证通过的）。第三步，客户端浏览器生成https通信用的对称密钥，用fiddler伪造的证书公钥加密后传递给服务器，被fiddler截获。第四步，fiddler将截获的密文用自己伪造证书的私钥解开，获得https通信用的对称密钥。第五步，fiddler将对称密钥用服务器证书公钥加密传递给服务器，服务器用私钥解开后建立信任，握手完成，用对称密钥加密消息，开始通信。第六步，fiddler接收到服务器发送的密文，用对称密钥解开，获得服务器发送的明文。再次加密（用伪造的证书公钥加密），发送给客户端浏览器。第七步，客户端向服务器发送消息，用对称密钥加密，被fidller截获后，解密获得明文。由于fiddler一直拥有通信用对称密钥，所以在整个https通信过程中信息对其透明。 所以，在浏览器面前Fiddler假装成一个HTTPS服务器，而在真正的HTTPS服务器面前Fiddler假装成浏览器。Fiddler会动态地生成HTTPS证书来伪装服务器。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合的子集和笛卡儿积与优惠套餐的应用]]></title>
    <url>%2F2018%2F04%2F24-java-subset%2F</url>
    <content type="text"><![CDATA[集合的子集和笛卡儿积与优惠套餐的应用这是项目中用到的一个算法的实际应用。算法比较简单，求两个集合的子集的笛卡尔积，用于商家的后端优惠组合。还是蛮有意思的哈。 情景举个例子。 两种优惠：第一种是满金额减，第二种是满数量减。 第一种有多种优惠，比如：1、满1000减2002、满500减100 第二种有多种优惠，比如：1、满10件商品再打8折2、满5件商品再打9折 这四种商家可以自由多选，制定自己的优惠。 优惠先执行第一种优惠的计算，然后再计算第二种优惠的计算。 比如：顾客买了6件商品，总额1028元。那么先可以进行“满1000减200”的优惠，需付款变成828元，然后因为“满5件商品”，可以再打9折，需付款又变成了745.2元。 解决这么灵活的选择，怎么去计算所有的可能组合，以便进行校验和排除某些组合的操作呢？ 计算所有的子集，并进行笛卡尔积，再去重应该就可以了。 代码如下：github 结果：12345678910111213141516[] + [][满1000减200] + [满10件商品再打8折][满1000减200, 满500减100] + [满10件商品再打8折][满1000减200, 满500减100] + [][满1000减200, 满500减100] + [满5件商品再打9折][] + [满10件商品再打8折][满500减100] + [满10件商品再打8折][满1000减200] + [满5件商品再打9折][] + [满10件商品再打8折, 满5件商品再打9折][满500减100] + [满10件商品再打8折, 满5件商品再打9折][满500减100] + [][满1000减200] + [][满1000减200] + [满10件商品再打8折, 满5件商品再打9折][满1000减200, 满500减100] + [满10件商品再打8折, 满5件商品再打9折][] + [满5件商品再打9折][满500减100] + [满5件商品再打9折]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java重写、重载、多态和自动装拆箱的简单探究]]></title>
    <url>%2F2018%2F04%2F19-java-overload-override-polymorphic%2F</url>
    <content type="text"><![CDATA[Java重写、重载、多态和自动装拆箱的简单探究转眼已经在公司实习了快两个月，这两个月过的也是感觉蛮快的，也学到了不少东西。不过实习到现在，说好的博客和GitHub练习却中止了，也是惭愧。现在正好是项目QA阶段，老大抛给我了一个面试题，他刚用来问别人的，这个问题表面上是涉及到一些Java基础，再深层次就是编译和JVM的知识了。 情况一12345678910111213141516171819202122232425262728293031323334class Fruit &#123;&#125;class Apple extends Fruit &#123;&#125;class Banana extends Fruit &#123;&#125;class People &#123; public void eat(Fruit f) &#123; System.out.println("People eat Fruit"); &#125; public void eat(Apple f) &#123; System.out.println("People eat Apple"); &#125; public void eat(Banana f) &#123; System.out.println("People eat Banana"); &#125;&#125;class Boy extends People &#123; public void eat(Fruit f) &#123; System.out.println("Boy eats Fruit"); &#125; public void eat(Apple f) &#123; System.out.println("Boy eats Apple"); &#125; public void eat(Banana f) &#123; System.out.println("Boy eats Banana"); &#125;&#125; 测试方法：12345678public void test() &#123; Fruit apple = new Apple(); Fruit banana = new Banana(); People boy = new Boy(); boy.eat(apple); boy.eat(banana);&#125; 结果是啥？12Boy eats FruitBoy eats Fruit 神奇？？？ 情况二增加一个接口：123interface Eatable &#123; void eat(Fruit f);&#125; 增加一个女孩类：1234567891011class Girl extends People implements Eatable &#123; public void eat(Apple f) &#123; System.out.println("Girl eats Apple"); &#125; public void eat(Banana f) &#123; System.out.println("Girl eats Banana"); &#125;&#125; 测试方法：12345678public void test() &#123; Apple apple = new Apple(); Banana banana = new Banana(); Eatable eatable = new Girl(); eatable.eat(apple); eatable.eat(banana);&#125; 结果是？12People eats FruitPeople eats Fruit 什么？？？ 情况三新增一个水果篮子类：12345678910class Basket &#123; public void takeBy(People p) &#123; System.out.println("takenBy People"); &#125; public void takeBy(Eatable p) &#123; System.out.println("takenBy Eatable"); &#125;&#125; 测试方法：123456public void test() &#123; Basket basket = new Basket(); Girl girl = new Girl(); basket.takenBy(girl);&#125; 结果是？？ IDE报错！指定不明确。 真的假的！！！ 情况四自动拆箱 1234567891011121314151617class Box &#123; public void show(int i)&#123; System.out.println("show int"); &#125; public void show(Object obj)&#123; System.out.println("show obj"); &#125; public void show(Number number)&#123; System.out.println("show number"); &#125; public void show(Comparable comparable)&#123; System.out.println("show comparable"); &#125;&#125; 测试代码：12345public void test() &#123; Box box = new Box; Integer integer = Integer.valueOf(100); box.show(integer);&#125; 结果是？ 依然报错，原因和情况三是一样的。指定不明确。 如果是这样的测试代码呢？12345public void test() &#123; Box box = new Box; Number integer = Integer.valueOf(100); box.show(integer);&#125; 结果是？1show number 哈哈，有点眉头了？ 情况五和情况四差不多，只是去掉了一个方法 自动拆箱 1234567891011121314151617class Box &#123; public void show(int i)&#123; System.out.println("show int"); &#125; public void show(Object obj)&#123; System.out.println("show obj"); &#125; // public void show(Number number)&#123; // System.out.println("show number"); // &#125; public void show(Comparable comparable)&#123; System.out.println("show comparable"); &#125;&#125; 测试代码：12345public void test() &#123; Box box = new Box; Integer integer = Integer.valueOf(100); box.show(integer);&#125; 结果是：1show comparable 弄懂情况三就可以理解了。 情况六和情况五差不多，只是再去掉了一个方法 自动拆箱 1234567891011121314151617class Box &#123; public void show(int i)&#123; System.out.println("show int"); &#125; public void show(Object obj)&#123; System.out.println("show obj"); &#125; // public void show(Number number)&#123; // System.out.println("show number"); // &#125; // public void show(Comparable comparable)&#123; // System.out.println("show comparable"); // &#125;&#125; 测试代码：12345public void test() &#123; Box box = new Box; Integer integer = Integer.valueOf(100); box.show(integer);&#125; 结果是：1show obj 向上寻找？ 情况七和情况六差不多，只是再去掉了一个方法 自动拆箱 1234567891011121314151617class Box &#123; public void show(int i)&#123; System.out.println("show int"); &#125; // public void show(Object obj)&#123; // System.out.println("show obj"); // &#125; // public void show(Number number)&#123; // System.out.println("show number"); // &#125; // public void show(Comparable comparable)&#123; // System.out.println("show comparable"); // &#125;&#125; 测试代码：12345public void test() &#123; Box box = new Box; Integer integer = Integer.valueOf(100); box.show(integer);&#125; 结果是：1show int 这才是正确的拆箱姿势嘛。 情况八再来看看自动装箱 自动装箱 1234567891011121314151617class Box &#123; public void show(int i)&#123; System.out.println("show int"); &#125; public void show(Object obj)&#123; System.out.println("show obj"); &#125; public void show(Number number)&#123; System.out.println("show number"); &#125; public void show(Comparable comparable)&#123; System.out.println("show comparable"); &#125;&#125; 测试代码：12345public void test() &#123; Box box = new Box; int i = 100; box.show(i);&#125; 结果是，IDE报错了！指定不明确 情况九自动装箱 1234567891011121314151617class Box &#123; public void show(int i)&#123; System.out.println("show int"); &#125; public void show(Object obj)&#123; System.out.println("show obj"); &#125; // public void show(Number number)&#123; // System.out.println("show number"); // &#125; public void show(Comparable comparable)&#123; System.out.println("show comparable"); &#125;&#125; 测试代码：12345public void test() &#123; Box box = new Box; int i = 100; box.show(i);&#125; 结果是：1show comparable 嗯？ 情况十自动装箱 123456789101112131415161718192021class Box &#123; public void show(int i)&#123; System.out.println("show int"); &#125; public void show(Object obj)&#123; System.out.println("show obj"); &#125; // public void show(Number number)&#123; // System.out.println("show number"); // &#125; public void show(Comparable comparable)&#123; System.out.println("show comparable"); &#125; public void show(Integer integer) &#123; System.out.println("show integer"); &#125;&#125; 测试代码：12345public void test() &#123; Box box = new Box; int i = 100; box.show(i);&#125; 结果是：1show integer 嗯。这才是正确的自动装箱的姿势嘛。 总结做了那么多的实验，和诧异的结果，到底是怎么回事呢？ 书中自有黄金屋：《深入理解java虚拟机 第二版》 上面的测试大致面向几个方面：多态、重载、重写，以及自动装拆箱。 个人猜测（不一定正确）： 均建立在对象不为空的情况下，尤其是包装数据类型。 该由谁来执行，执行参数是什么 执行的方法是在执行者的引用类（2，People）里去找，方法的参数是（1，Fruit）；如果People里指定方法的参数没有Fruit，就会找Fruit的父类，直到找到为止（Object），如果找不到就会报错（编译器或IDE报错）。如果找到了就去真正的执行者（3，Boy）里去找刚才找到的符合参数的方法，找到就执行，找不到就按纵向查找，即执行者父类依次查找，直到找到People为止（沿着父类查找的过程中参数类型不变）。如果找到的方法是抽象或接口方法则报错。 Java是一门静态多分派且动态单分派的语言。具体我也不懂，可以看书和查询相关博客。 参考博客 语言也是一直变化的，没有是绝对不变的。 对于既不是基本数据类型，也不是包装数据类型 结合“该由谁来执行，执行参数是什么”按先横再纵。比如：第一次：male.eat(apple) -&gt; male.eat(fruit)第二次：boy.eat(fruit) -&gt; male.eat(fruit)…就这样直到找到匹配的。 对于基本数据类型先去找基本数据类型，没找到再尝试进行类型提升，比如int转成long，继续寻找。如果没有找到就尝试进行包装，比如int包装成Integer，然后再按“既不是基本数据类型，也不是包装数据类型”处理。如果还是没找到就报错。 包装类型不会进行自动提升。 对于包装数据类型先按照“既不是基本数据类型，也不是包装数据类型”进行处理，找不到最后再尝试拆箱成基本数据类型(比如Integer拆箱成int)进行查找。转成基本数据类型后弱火还是没找到就再尝试进行类型提升，比如int转成long，继续寻找。如果还是没找到就报错。 目前是没有基本数据类型自动类型下降的。 思考为什么要纠结这个问题呢？有什么意义？ 一个案例：123456789101112131415161718192021222324252627282930313233class BaseService &#123; public void process() &#123; System.out.println("process old"); &#125;&#125;class NewBaseService extends BaseService &#123; public void process() &#123; System.out.println("process new"); &#125;&#125;class GoodsService &#123; public void service(BaseService baseService) &#123; System.out.println("service old process old"); baseService.process(); &#125;&#125;class NewGoodsService extends GoodsService &#123; public void service(NewBaseService baseService) &#123; System.out.println("service new process new"); baseService.process(); &#125;&#125;@Testpublic void test3() &#123; BaseService baseService = new NewBaseService(); GoodsService goodsService = new NewGoodsService(); goodsService.service(baseService);&#125; 结果是：12service old process oldprocess new 但是需要的效果却是：12service new process newprocess new 怎么办呢？需要对原来的旧类进行改造才行。改成如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243class BaseService &#123; public void process() &#123; System.out.println("process old"); &#125;&#125;class NewBaseService extends BaseService &#123; public void process() &#123; System.out.println("process new"); &#125;&#125;class GoodsService &#123; public void service(BaseService baseService) &#123; System.out.println("service old process old"); baseService.process(); &#125; public void service(NewBaseService baseService) &#123; System.out.println("service old process new"); baseService.process(); &#125;&#125;class NewGoodsService extends GoodsService &#123;// public void service(BaseService baseService) &#123;// System.out.println("service new process old");// baseService.process();// &#125; public void service(NewBaseService baseService) &#123; System.out.println("service new process new"); baseService.process(); &#125;&#125;@Testpublic void test3() &#123; NewBaseService baseService = new NewBaseService(); GoodsService goodsService = new NewGoodsService(); goodsService.service(baseService);&#125; 对比就知道了原因了。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[保证数据传输安全的一种措施]]></title>
    <url>%2F2018%2F01%2F31-how-to-cnnnect-to-two-network%2F</url>
    <content type="text"><![CDATA[保证数据传输安全的一种措施在外国网站上看到，截屏记录一下，很实用。最好的教程就是官方的教程，有很多例子可以参考，直接看国内博客有的时候不是一个好的解决途径。 比如依据这两个关键的文章：1、rw-eap-mschapv2-id-rsa2、ip-pool]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>其他</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一次家中路由改造和监控升级]]></title>
    <url>%2F2018%2F01%2F22-one-router-change%2F</url>
    <content type="text"><![CDATA[记录一次家中路由改造和监控升级随着智能手机的普及，越来越多的人使用手机看高清视频、玩手机游戏。渐渐的，家里门面上的路由无线网络也吃不消了，现在回到家进行了一下改造，改造过程不难，记录一下。 路由改造家中的路由以前是水星普通家用路由器，从某东上买来一个普通的企业级路由器。将企业级路由器作为直接接入光猫端，以前的水星路由器作为子网，成树状结构。子网内的路由器相互进行WDS无线桥接，每个路由器都有各自的网线连接到企业级路由器。这样就可以实现家里的无线网络的全覆盖和流量分散，不像之前全部集中在一个路由器上，路由器处理不过来，导致经常卡顿、掉线。 树状结构主企业级路由器关闭DHCP，改为手动配置IP、网关、DNS等信息。子路由器固定IP连接到主路由器。主路由器开启IP和MAC绑定。子路由器关闭uPnP功能（迅雷等软件可能会占用所有的路由器带宽和计算资源）。子路由器在同一个子网下，与主路由器不在一个子网。子路由器开启指定MAC访问配置界面。主路由器没有无线模块。 大致示意图如下：png WDS组网WDS组网是无线路由的常用功能，现在的路由新的配置界面可以一键实现路由无线桥接，但是一键有好处也有不好。组网的机器最好是同厂家，不同厂家也可以，不多不排除会有掉线的问题。每个子路由器都通过有线接入主路由器，这样WDS组网后，每个路由器的向外访问的数据包会直接从各自路由器走，内部互相访问的流量才在子网内访问，避免桥接的网络数据拥堵（可以从路由的系统路由表得到这个结论）。子路由在使用人多的地方可以使用多天线，即带宽高一点，这样支持同时访问的人数就可以多一点。主路由器可以对每一个子路由器进行网速的限制。 WDS组网的注意事项是：每个路由器无线所使用的信道需要一致（不能为自动），DHCP的分配地址不能有重叠，每个子路由的网关不能有冲突。 监控升级家里的监控用的是海康威视DS-7804H-SNH，型号比较老。以前使用HiDDNS能实现远程实时预览和回放。突然有一天远程访问不能使用。检查后发现，一方面旧的HiDDNS海康已经不再支持，虽然旧型号仍然可以使用；另一方面，也是最重要的。家里的拨号后获取的IP竟然变成了100开头的IP地址，这是内网的IP。而海康获取到的IP为NAT后的公网IP，内网映射的端口如果直接从外网访问当然是访问不了，需要获取到外网映射的端口才行，但是外网映射的端口也是在不断变化的，这和UDP的聊天室是一个道理。没办法解决自己家中的网络被电信机房接入了内网的事实，只能另找其他办法。海康也推出了萤石云，萤石云可以解决这个问题，不再使用HiDDNS。不过萤石云官网上说明只是在新的机子上支持。 功夫不负有心人，在论坛上成功的找到DS-7804H-SNH的升级包，使用U盘插入升级后再重置（最好重置一下），设置中多了一个萤石云的选项。看来可行。 先配置好监控的常用设置，开启移动侦测，关闭定时录像，以节省硬盘空间。将监控接入主路由器，配置好IP等信息。下载萤石云视频APP，注册账号，然后在监控机器的网页界面（使用IE，兼容界面，安装WebComponent插件）可以获取到设备的9位ID，在监控的本机（不是网页）可以设置萤石云的访问的验证码（也可以不设置，设置后可以加密流）。通过萤石云视频APP，绑定好账号后就可以实时公网预览了。 然后下载APP名iVMS-4500，先手动添加内网访问监控的配置，然后再登陆上萤石云账号，同步刚才的萤石云视频APP的设置，就可以实现内网和外网都可以观看监控和回放了。萤石云视频APP也可以卸载，保留一个iVMS4500即可。 思考总结这样折腾一番后，家里的无线网络掉线现象得到明显的改善，监控也能愉快的内外网同时访问了。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派3搭建cups或p910nd打印服务器]]></title>
    <url>%2F2018%2F01%2F20-linux-share-printer%2F</url>
    <content type="text"><![CDATA[树莓派3搭建cups或p910nd打印服务器放假前实验室搭建出一套在线的浏览器WEB打印平台，共享打印机使用。放假回家记录一下踩到的坑，方便学习。 系统概述某宝类似产品 上面的某宝上有专门的厂家卖打印服务器，我这里使用树莓派搭建一个类似的平台。 大致的原理如上图。其他计算机可以通过这个打印服务器将需要打印的文件打印到打印机上。 实现的方式大致有两种： 一种是通过CUPS方法一种是通过p910d方式 当然还有蓝牙等其他方式，我没有做研究。 cups方式首先将树莓派刷入纯净的Linux操作系统，比如2017-11-29-raspbian-stretch-lite.img，下载地址可以在raspberrypi官网找到。 刷入系统的方法大致是先清除SD卡上的数据和分区，然后写入img镜像，插入树莓派后通电启动，则默认会加载内存卡中的系统。树莓派可以理解为一个裸机，系统和数据均是在内存卡中存储的，只需要更换内存卡即可方便的更换操作系统。 清除分区可以使用SDFormatter或者Windows命令diskpart，写入镜像可以使用Win32DiskImager。具体教程参考树莓派入门之装系统。 初次启动树莓派有很多方式，我的方式是通电前，插入网线连接到家用路由器上，然后再使用HDMI线连接到显示器，插入USB鼠标和键盘。通电后，可以在路由器配置界面(通常是192.168.1.1)查看到树莓派的IP。路由器可以设置IP和MAC绑定，防止树莓派的IP有变化。也可以设置好新的IP和MAC绑定项，比如192.168.1.188，然后关闭树莓派，重启路由器，再打开树莓派。这样树莓派就可以自动获得指定的IP。 树莓派启动后，还不能直接SSH连接，需要使用键盘和显示器的情况下预先配置一下。如果显示器没有输出图像的话，那么最简单的方式就是重新刷写SD卡，先确保HDMI线接入到通电状态下的显示器上，然后再启动树莓派。 使用如下命令可以配置树莓派的一些预先设置：1sudo raspi-config 在设置中可以开启SSH。然后重启树莓派，使用winscp+putty就可以登陆树莓派，此时键盘和显示器也可以撤了。 接着可以先安装一些常用的软件：12sudo apt-get updatesudo apt-get -f install vim tree openssh-server 接着就万事俱备，可以安装cups打印服务了。 先输入下面的命令安装hplip：1sudo apt-get -f install hplip 安装好hplip后通常cups也会一并安装好。 将当前树莓派用户pi加入到lp管理员组，用于之后的web配置，也可以单独新建一个用户加入。1sudo usermod -a -G lpadmin pi 备份配置文件（这是一个好习惯）：1sudo mv /etc/cups/cupsd.conf /etc/cups/cupsd.conf.bak 然后为了便于cups配置界面在其他电脑上也能直接访问，需要修改配置文件：1sudo vim /etc/cups/cupsd.conf 将1Listen localhost:631 改成1Listen 0.0.0.0:631 再将123&lt;Location /&gt; &lt;Location /admin&gt; &lt;Location /admin/conf&gt; 三个节点均添加1Allow from @Local 保存后重启cups服务或重启树莓派，连接上打印机的USB口。 重启后在浏览器中输入： http://（树莓派IP，比如192.168.1.188）:631 即可打开cups的配置界面。 点击Add printer可以添加打印机，添加打印机需要https访问，并输入之前设置的管理用户和密码（比如pi，密码raspberry）。 注意在windows中添加打印机时需要将https改成http。 具体操作步骤参考将树莓派变成网络打印机服务器。 可以安装samba让windows能直接在网络邻居中看到这台打印服务器，并共享打印机的驱动文件。参考CUPS&amp;samba。 cups需要打印机在linux下的驱动才能完美支持，但是很多打印机在linux下没有驱动（比如联想），这就很麻烦，所以p910nd方式兼容性会好些。 联想激光和喷墨打印机可以参考brother打印机，在linux中，使用lsusb可以看出来，联想的打印机显示的是brother公司，brother打印机在cups的驱动列表中可以找到部分驱动。如果不确定，可以比较生产日期和外观，确定具体的型号，但是驱动也并不能确保完美支持。惠普打印机在linux驱动方面做的很好，基本都能找到对应的驱动，hplip也是惠普主导的，这值得点赞。 如果实在没有驱动，那么可以使用驱动列表中的RAW，再选择queue即可，在windows中安装对应的打印机驱动也能支持。有些windows打印驱动下有ppd文件，如果有那么可以通过上传ppd的方式添加打印机。 针式打印机很少有linux下的驱动，cups下无法正常使用（自己尝试时，偶然有一次打印出了Print Test Page部分信息，但是之后再也没有进展）。 p910nd方式很多智能路由器装有基于openwrt的操作系统，这也是一个基于linux的操作系统，曾经在学校用过的天翼客户端破解路由器也是基于openwrt。 树莓派作为一个强大的开源设备（确实牛的不行），也支持openwrt系统，不过是其一个分支lede。某宝上卖的那款打印服务器推测也基本上基于这个系统实现的。 p910nd方式是基于TCP/IP方式连接打印机，传输协议采用RAW，服务器只是做打印数据的转发，并不需要像cups那样需要打印机的驱动，因此兼容性更好，也能支持部分老式的针式打印机。 下面就来折腾p910nd方式打印机服务器吧。 将树莓派的内存卡取出，使用另一张新的sd卡，这样可以实现方便的更换系统。 我所使用的是：树莓派3代B型，1.2GHz，四核64位ARMv8 CortexA53 CPU（bcm2837）。在lede官网上下载对应CPU的img系统镜像：1http://downloads.lede-project.org/releases/17.01.4/targets/brcm2708/bcm2710/ 如果镜像下载的不对，是不能启动的，或者支持的有问题。树莓派3就下载bcm2708下的bcm2710即可。 我下载的镜像文件是：lede-17.01.4-brcm2708-bcm2710-rpi-3-ext4-sdcard.img.gz 官网会不断的更新，需要自己选择最新和最稳定的版本，版本选择。 下载后，按照cups写的安装系统的方式，将img写入内存卡。 不一样的是，树莓派的lede启动后默认是当路由器使用，而我们需要作为打印服务器。 电脑网口与树莓派直连，然后在浏览器中输入192.168.1.1，即可访问lede配置界面。 初始账号root，密码为空，首次使用需要修改。并开启SSH便于远程访问。 登录后修改Network中的Interfaces，修改LAN口的配置，将IP改为其他，比如192.168.1.188（需要在路由器的同一网段下），修改网关为192.168.1.1（路由器网关），并设置DNS服务器（因地区而异，可以在家用路由器主界面中看到），可以关闭树莓派自己的DHCP服务器，也可以不关。应用并保存（Save&amp;Apply）后关闭树莓派。 将树莓派插入到家用路由器上（无需清除之前设置的IP和MAC绑定，因为树莓派硬件没有变化，MAC地址也没有变化，IP和MAC绑定仍然有效），接通树莓派的电源。 在浏览器中输入192.168.1.188，打开lede配置界面，进入System的Software下，点击update list，更新软件列表。内部的软件源是预先设置好的，主要如下：123456src/gz reboot_core http://downloads.lede-project.org/releases/17.01.4/targets/brcm2708/bcm2710/packagessrc/gz reboot_base http://downloads.lede-project.org/releases/17.01.4/packages/arm_cortex-a53_neon-vfpv4/basesrc/gz reboot_luci http://downloads.lede-project.org/releases/17.01.4/packages/arm_cortex-a53_neon-vfpv4/lucisrc/gz reboot_packages http://downloads.lede-project.org/releases/17.01.4/packages/arm_cortex-a53_neon-vfpv4/packagessrc/gz reboot_routing http://downloads.lede-project.org/releases/17.01.4/packages/arm_cortex-a53_neon-vfpv4/routingsrc/gz reboot_telephony http://downloads.lede-project.org/releases/17.01.4/packages/arm_cortex-a53_neon-vfpv4/telephony 可以Configuration下修改。注意源需要和树莓派系统版本对应，否则容易出现valid architectance提示。如果更新列表失败，则很可能是网络不通，需要重新检查LAN口配置。 在Available Packages下依次搜索安装： kmod-lp、kmod-usb-printer、usbutils、p910nd、luci-app-p910nd 也可以在命令行下使用：12opkg updateopkg install kmod-lp kmod-usb-printer usbutils p910nd luci-app-p910nd kmod-lp用于并行口的打印机，kmod-usb-printer用于USB打印机。安装usbutils以支持lsusb命令。p910nd为服务器，luci-app-p910nd为luci界面下的图形配置界面。 安装好后重启树莓派，插入打印机的USB口。重启后进入Services下新出现的p910nd - Printer server。 使用SSH连接到树莓派，输入lsusb，查看是否有打印机连接，再进入/etc/usb下，查看是否lp0字样。 可以使用echo “XXX” &gt; /etc/usb/lp0，测试打印机是否打印。 配置界面如下： 之后就可以在电脑上连接打印机了，具体连接步骤参考网络打印机TCP/IP共享设置教程。 如果是针式打印机使用Serial-USB转换器，基于PL2305芯片，插入到USB口，即可在/etc/serial中看到打印机的id或path，复制路径到Device栏中即可使用。但是并不是所用的针式打印机都能支持的。可以使用Add，分配不同的端口，比如9101，可以实现支持多个打印机。 在线打印（这是额外的内容） 实验室还搭建了一个浏览器上传文件打印方式的WEB服务。WEB服务主要是采用利用Linux的lpr命令和libreoffice软件实现。 lpr是linux的命令行打印命令，具体的学习资料链接。部分命令需要root权限，如果不考虑安全性的话，可以将web服务以root账号运行。 libreoffice是linux下的一个开源软件，能支持命令行文件格式转换，比如doc-&gt;pdf，但是支持的不是很好。比如常用的一个使用案例如下：1libreoffice --headless --convert-to pdf --outdir xxx.pdf xxx.doc web服务后台服务采用java实现，调用系统命令可以使用：1234567891011121314151617181920212223private String exec(String e, boolean r) &#123; try &#123; logger.info("exec: " + e); Process process = Runtime.getRuntime().exec(e); process.waitFor(); if (!r) return null; InputStream is = process.getInputStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] bytes = new byte[1024 * 8]; int len = -1; while ((len = is.read(bytes)) != -1) &#123; baos.write(bytes, 0, len); baos.flush(); &#125; return baos.toString(); &#125; catch (IOException e1) &#123; logger.error("printer", e1); &#125; catch (InterruptedException e1) &#123; logger.error("printer", e1); &#125; return null;&#125; 前端静态界面采用bootstrap和fileinput组件。 大致流程图如下：png 由于打印一般是在client端（即要打印的本地客户端）进行转换（这也是为什么要驱动的原因），转换后再将数据流发送给打印机打印，所以linux下这种在线打印平台经过测试，对pdf支持的较好，对其他格式支持的不佳（尤其是doc，会出现乱版）。 市面上也有专门的公司制作云打印平台，支持的最好的方式个人猜测还是windows下底层编程比较好，而不是像我实现的这种利用系统命令的方式。 ubuntu中添加打印机最好是在desktop下进行，命令行下比较麻烦。 思考总结p910nd没有cups稳定，但是它的兼容性更好。如果打印机是hp的，那么推荐使用cups，如果需要更好的兼容设备，那么选择p910nd。 某宝上卖的打印服务器可能还有直接的底层打印指令程序编写，支持上会更好。 教程写的不是很详细，只是记录了关键步骤，需要帮助的可以留言。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL复习笔记-I]]></title>
    <url>%2F2018%2F01%2F10-mysql-review-note-1%2F</url>
    <content type="text"><![CDATA[MySQL复习笔记-IMySQL中一些重点知识的复习笔记，内容摘自书和一些学习视频，并会持续不断的完善。 测试数据来源：MySQL官方employees数据库。 MySQL复习笔记-IMySQL复习笔记-IIMySQL复习笔记-IIIMySQL复习笔记-IV 基础知识DB、DBMS、DBA DDL、DCL、DML 常见MySQL命令行命令。 基础查询、条件查询（where）、常见函数（分组函数）、分组查询（group by/having）、排序查询（order by）、连接查询、子查询、分页查询（limit）、联合查询（union）。 基础查询12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/*基础查询语法：select 查询列表 from 表名;特点：1、查询列表可以是：表中的字段、常量值、表达式、函数2、查询的结果是一个虚拟的表格*/USE myemployees;#1.查询表中的单个字段SELECT last_name FROM employees;#2.查询表中的多个字段SELECT last_name,salary,email FROM employees;#3.查询表中的所有字段## 方式一：SELECT `employee_id`, `first_name`, `last_name`, `phone_number`, `last_name`, `job_id`, `phone_number`, `job_id`, `salary`, `commission_pct`, `manager_id`, `department_id`, `hiredate` FROM employees ;## 方式二： SELECT * FROM employees;#4.查询常量值SELECT 100;SELECT 'john'; #5.查询表达式SELECT 100%98; #6.查询函数 SELECT VERSION(); #7.起别名/*①便于理解②如果要查询的字段有重名的情况，使用别名可以区分开来*/##方式一：使用asSELECT 100%98 AS 结果;SELECT last_name AS 姓,first_name AS 名 FROM employees;##方式二：使用空格SELECT last_name 姓,first_name 名 FROM employees;###案例：查询salary，显示结果为 out putSELECT salary AS "out put" FROM employees;#8.去重##案例：查询员工表中涉及到的所有的部门编号SELECT DISTINCT department_id FROM employees;#9.+号的作用/*java中的+号：①运算符，两个操作数都为数值型②连接符，只要有一个操作数为字符串mysql中的+号：仅仅只有一个功能：运算符若需要连接，使用concat函数。select 100+90; 两个操作数都为数值型，则做加法运算select '123'+90;只要其中一方为字符型，试图将字符型数值转换成数值型，如果转换成功，则继续做加法运算select 'john'+90; 如果转换失败，则将字符型数值转换成0select null+10; 只要其中一方为null，则结果肯定为null*/## 案例：查询员工名和姓连接成一个字段，并显示为“姓名”SELECT CONCAT('a','b','c') AS 结果;SELECT CONCAT(last_name,first_name) AS 姓名FROM employees; 条件查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209/*条件查询语法： select 查询列表 from 表名 where 筛选条件;分类： 一、按条件表达式筛选 简单条件运算符：&gt; &lt; = != &lt;&gt; &gt;= &lt;= 二、按逻辑表达式筛选 逻辑运算符： 作用：用于连接条件表达式 java: &amp;&amp; || ! mysql: and or not &amp;&amp;和and：两个条件都为true，结果为true，反之为false ||或or： 只要有一个条件为true，结果为true，反之为false !或not： 如果连接的条件本身为false，结果为true，反之为false 三、模糊查询 like between and in not in is null is not null ...*/#一、按条件表达式筛选##案例1：查询工资&gt;12000的员工信息SELECT *FROM employeesWHERE salary&gt;12000; ##案例2：查询部门编号不等于90号的员工名和部门编号SELECT last_name, department_idFROM employeesWHERE department_id&lt;&gt;90;#二、按逻辑表达式筛选##案例1：查询工资z在10000到20000之间的员工名、工资以及奖金SELECT last_name, salary, commission_pctFROM employeesWHERE salary&gt;=10000 AND salary&lt;=20000;##案例2：查询部门编号不是在90到110之间，或者工资高于15000的员工信息SELECT *FROM employeesWHERE NOT(department_id&gt;=90 AND department_id&lt;=110) OR salary&gt;15000;#三、模糊查询/*likebetween andinis null|is not null*/#1.【like】/*特点：①一般和通配符搭配使用 通配符： % 任意【多】个字符,包含0个字符 _ 任意【单】个字符*/##案例1：查询员工名中包含字符a的员工信息select *from employeeswhere last_name like '%a%';#abc##案例2：查询员工名中第三个字符为e，第五个字符为a的员工名和工资select last_name, salaryFROM employeesWHERE last_name LIKE '__n_l%';##案例3：查询员工名中第二个字符为_的员工名SELECT last_nameFROM employeesWHERE last_name LIKE '_$_%' ESCAPE '$';#2.between and/*①使用between and 可以提高语句的简洁度②包含临界值③两个临界值不要调换顺序*/##案例1：查询员工编号在100到120之间的员工信息SELECT *FROM employeesWHERE employee_id &gt;= 120 AND employee_id&lt;=100;##----------------------SELECT *FROM employeesWHERE employee_id BETWEEN 120 AND 100;#3.in/*含义：判断某字段的值是否属于in列表中的某一项特点： ①使用in提高语句简洁度 ②in列表的值类型必须一致或兼容 ③in列表中不支持通配符*/##案例：查询员工的工种编号是 IT_PROG、AD_VP、AD_PRES中的一个员工名和工种编号SELECT last_name, job_idFROM employeesWHERE job_id = 'IT_PROT' OR job_id = 'AD_VP' OR JOB_ID ='AD_PRES';##------------------SELECT last_name, job_idFROM employeesWHERE job_id IN( 'IT_PROT' ,'AD_VP','AD_PRES');#4、is null/*=或&lt;&gt;不能用于判断null值is null或is not null 可以判断null值*/##案例1：查询没有奖金的员工名和奖金率SELECT last_name, commission_pctFROM employeesWHERE commission_pct IS NULL;##案例2：查询有奖金的员工名和奖金率SELECT last_name, commission_pctFROM employeesWHERE commission_pct IS NOT NULL;##----------以下为×SELECT last_name, commission_pctFROM employeesWHERE salary IS 12000;#安全等于 &lt;=&gt;##案例1：查询没有奖金的员工名和奖金率SELECT last_name, commission_pctFROM employeesWHERE commission_pct &lt;=&gt;NULL;##案例2：查询工资为12000的员工信息SELECT last_name, salaryFROM employeesWHERE salary &lt;=&gt; 12000;# 小结IS NULL: 仅仅可以判断NULL值，可读性较高，建议使用&lt;=&gt; : 既可以判断NULL值，又可以判断普通的数值，可读性较低 常见函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252/*常见函数 概念：类似于java的方法，将一组逻辑语句封装在方法体中，对外暴露方法名 好处：1、隐藏了实现细节 2、提高代码的重用性 调用：select 函数名(实参列表) 【from 表】;特点： ①叫什么（函数名） ②干什么（函数功能）分类： 1、单行函数 如 concat、length、ifnull等 2、分组函数 功能：做统计使用，又称为统计函数、聚合函数、组函数 常见函数： 一、单行函数 字符函数： length:获取字节个数(utf-8一个汉字代表3个字节,gbk为2个字节) concat substr instr trim upper lower lpad rpad replace 数学函数： round ceil floor truncate mod 日期函数： now curdate curtime year month monthname day hour minute second str_to_date date_format 其他函数： version database user 控制函数： if（mysql中if是一个函数） case*/#一、字符函数#1.length 获取参数值的字节个数SELECT LENGTH('john');SELECT LENGTH('张三丰hahaha');SHOW VARIABLES LIKE '%char%'#2.concat 拼接字符串SELECT CONCAT(last_name,'_',first_name) 姓名 FROM employees;#3.upper、lowerSELECT UPPER('john');SELECT LOWER('joHn');#示例：将姓变大写，名变小写，然后拼接SELECT CONCAT(UPPER(last_name),LOWER(first_name)) 姓名 FROM employees;#4.substr、substring注意：索引从1开始#截取从指定索引处后面所有字符SELECT SUBSTR('李莫愁爱上了陆展元',7) out_put;#截取从指定索引处指定字符长度的字符SELECT SUBSTR('李莫愁爱上了陆展元',1,3) out_put;#案例：姓名中首字符大写，其他字符小写然后用_拼接，显示出来SELECT CONCAT(UPPER(SUBSTR(last_name,1,1)),'_',LOWER(SUBSTR(last_name,2))) out_putFROM employees;#5.instr 返回子串第一次出现的索引，如果找不到返回0SELECT INSTR('杨不殷六侠悔爱上了殷六侠','殷八侠') AS out_put;#6.trimSELECT LENGTH(TRIM(' 张翠山 ')) AS out_put;SELECT TRIM('aa' FROM 'aaaaaaaaa张aaaaaaaaaaaa翠山aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa') AS out_put;#7.lpad 用指定的字符实现左填充指定长度SELECT LPAD('殷素素',2,'*') AS out_put;#8.rpad 用指定的字符实现右填充指定长度SELECT RPAD('殷素素',12,'ab') AS out_put;#9.replace 替换SELECT REPLACE('周芷若周芷若周芷若周芷若张无忌爱上了周芷若','周芷若','赵敏') AS out_put;#二、数学函数#round 四舍五入SELECT ROUND(-1.55);SELECT ROUND(1.567,2);#ceil 向上取整,返回&gt;=该参数的最小整数SELECT CEIL(-1.02);#floor 向下取整，返回&lt;=该参数的最大整数SELECT FLOOR(-9.99);#truncate 截断SELECT TRUNCATE(1.69999,1);#mod取余/*mod(a,b) ： a-a/b*bmod(-10,-3):-10- (-10)/(-3)*（-3）=-1*/SELECT MOD(10,-3);SELECT 10%3;#三、日期函数#now 返回当前系统日期+时间SELECT NOW();#curdate 返回当前系统日期，不包含时间SELECT CURDATE();#curtime 返回当前时间，不包含日期SELECT CURTIME();#可以获取指定的部分，年、月、日、小时、分钟、秒SELECT YEAR(NOW()) 年;SELECT YEAR('1998-1-1') 年;SELECT YEAR(hiredate) 年 FROM employees;SELECT MONTH(NOW()) 月;SELECT MONTHNAME(NOW()) 月;#str_to_date 将字符通过指定的格式转换成日期SELECT STR_TO_DATE('1998-3-2','%Y-%c-%d') AS out_put;#查询入职日期为1992--4-3的员工信息SELECT * FROM employees WHERE hiredate = '1992-4-3';SELECT * FROM employees WHERE hiredate = STR_TO_DATE('4-3 1992','%c-%d %Y');#date_format 将日期转换成字符SELECT DATE_FORMAT(NOW(),'%y年%m月%d日') AS out_put;#查询有奖金的员工名和入职日期(xx月/xx日 xx年)SELECT last_name,DATE_FORMAT(hiredate,'%m月/%d日 %y年') 入职日期FROM employeesWHERE commission_pct IS NOT NULL;#四、其他函数SELECT VERSION();SELECT DATABASE();SELECT USER();#五、流程控制函数#1.if函数： if else 的效果SELECT IF(10&lt;5,'大','小');SELECT last_name,commission_pct,IF(commission_pct IS NULL,'没奖金，呵呵','有奖金，嘻嘻') 备注FROM employees;#2.case函数的使用一： switch case 的效果/*java中switch(变量或表达式)&#123; case 常量1：语句1;break; ... default:语句n;break;&#125;mysql中case 要判断的字段或表达式when 常量1 then 要显示的值1或语句1;when 常量2 then 要显示的值2或语句2;...else 要显示的值n或语句n;end*//*案例：查询员工的工资，要求部门号=30，显示的工资为1.1倍部门号=40，显示的工资为1.2倍部门号=50，显示的工资为1.3倍其他部门，显示的工资为原工资*/SELECT salary 原始工资,department_id,CASE department_idWHEN 30 THEN salary*1.1WHEN 40 THEN salary*1.2WHEN 50 THEN salary*1.3ELSE salaryEND AS 新工资FROM employees;#3.case 函数的使用二：类似于多重if/*java中：if(条件1)&#123; 语句1；&#125;else if(条件2)&#123; 语句2；&#125;...else&#123; 语句n;&#125;mysql中：case when 条件1 then 要显示的值1或语句1when 条件2 then 要显示的值2或语句2...else 要显示的值n或语句nend*/#案例：查询员工的工资的情况如果工资&gt;20000,显示A级别如果工资&gt;15000,显示B级别如果工资&gt;10000，显示C级别否则，显示D级别SELECT salary,CASE WHEN salary&gt;20000 THEN 'A'WHEN salary&gt;15000 THEN 'B'WHEN salary&gt;10000 THEN 'C'ELSE 'D'END AS 工资级别FROM employees; 排序查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*排序查询语法：select 查询列表from 表名【where 筛选条件】order by 排序的字段或表达式;特点：1、asc代表的是升序，可以省略 desc代表的是降序2、order by子句可以支持 单个字段、别名、表达式、函数、多个字段3、order by子句在查询语句的最后面，除了limit子句*/#1、按单个字段排序SELECT * FROM employees ORDER BY salary DESC;#2、添加筛选条件再排序#案例：查询部门编号&gt;=90的员工信息，并按员工编号降序SELECT *FROM employeesWHERE department_id&gt;=90ORDER BY employee_id DESC;#3、按表达式排序#案例：查询员工信息 按年薪降序SELECT *,salary*12*(1+IFNULL(commission_pct,0))FROM employeesORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC;#4、按别名排序#案例：查询员工信息 按年薪升序SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪FROM employeesORDER BY 年薪 ASC;#5、按函数排序#案例：查询员工名，并且按名字的长度降序SELECT LENGTH(last_name),last_name FROM employeesORDER BY LENGTH(last_name) DESC;#6、按多个字段排序#案例：查询员工信息，要求先按工资降序，再按employee_id升序SELECT *FROM employeesORDER BY salary DESC,employee_id ASC; 分组查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/*分组查询语法： select 查询列表 from 表 【where 筛选条件】 group by 分组的字段 having 分组后筛选 【order by 排序的字段】;特点：1、和分组函数一同查询的字段必须是group by后出现的字段2、筛选分为两类：【分组前筛选和分组后筛选】 针对的表 位置 连接的关键字分组前筛选（原始表） group by前 where分组后筛选（group by后的结果集） group by后 having问题1：分组函数做筛选能不能放在where后面答：不能问题2：where——group by——having一般来讲，能用分组前筛选的，尽量使用分组前筛选，提高效率3、分组可以按单个字段也可以按多个字段4、可以搭配着排序使用*/#引入：查询每个部门的员工个数SELECT COUNT(*) FROM employees WHERE department_id=90;#1.简单的分组##案例1：查询每个工种的员工平均工资SELECT AVG(salary),job_idFROM employeesGROUP BY job_id;##案例2：查询每个位置的部门个数SELECT COUNT(*),location_idFROM departmentsGROUP BY location_id;#2、可以实现分组前的筛选##案例1：查询邮箱中包含a字符的每个部门的最高工资SELECT MAX(salary),department_idFROM employeesWHERE email LIKE '%a%'GROUP BY department_id;##案例2：查询有奖金的每个领导手下员工的平均工资SELECT AVG(salary),manager_idFROM employeesWHERE commission_pct IS NOT NULLGROUP BY manager_id;#3、分组后筛选##案例1：查询哪个部门的员工个数&gt;5#①查询每个部门的员工个数SELECT COUNT(*),department_idFROM employeesGROUP BY department_id;#② 筛选刚才①结果SELECT COUNT(*),department_idFROM employeesGROUP BY department_idHAVING COUNT(*)&gt;5;##案例2：每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资SELECT job_id,MAX(salary)FROM employeesWHERE commission_pct IS NOT NULLGROUP BY job_idHAVING MAX(salary)&gt;12000;##案例3：领导编号&gt;102的每个领导手下的最低工资大于5000的领导编号和最低工资manager_id&gt;102SELECT manager_id,MIN(salary)FROM employeesGROUP BY manager_idHAVING MIN(salary)&gt;5000;#4.添加排序##案例：每个工种有奖金的员工的最高工资&gt;6000的工种编号和最高工资,按最高工资升序SELECT job_id,MAX(salary) mFROM employeesWHERE commission_pct IS NOT NULLGROUP BY job_idHAVING m&gt;6000ORDER BY m;#5.按多个字段分组##案例：查询每个工种每个部门的最低工资,并按最低工资降序SELECT MIN(salary),job_id,department_idFROM employeesGROUP BY department_id,job_idORDER BY MIN(salary) DESC; 连接查询 SQL92语法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216/*含义：又称多表查询，当查询的字段来自于多个表时，就会用到连接查询笛卡尔乘积现象：表1 有m行，表2有n行，结果=m*n行发生原因：没有有效的连接条件如何避免：添加有效的连接条件分类： 按年代分类： sql92标准：仅仅支持内连接 sql99标准【推荐】：支持内连接 + 外连接（左外和右外） + 交叉连接 按功能分类： 内连接： 等值连接 非等值连接 自连接 外连接： 左外连接 右外连接 全外连接 交叉连接*/USE employees;# sql92标准：内连接（仅支持）## 笛卡尔积（没有有效的连接条件）SELECT * FROM departments d,employees e;## 等值连接 SELECT *FROM salaries s, employees eWHERE e.`emp_no` = s.`emp_no` AND s.`to_date` = '9999-01-01';## 不等值连接 SELECT *FROM salaries s, employees eWHERE e.`emp_no` = s.`emp_no` AND s.`to_date` = '9999-01-01' AND s.`salary` BETWEEN 80000 AND 100000; ## 自连接 SELECT *FROM salaries s1, salaries s2WHERE s1.`from_date` = s2.`to_date`;## 练习：查询工资最高的在职经理所在的部门的工资最低的在职员工的姓名，职位，工资。/*嵌套双层查询可以解决 LIMIT &amp; SUBQUERY*/### 1.查询出所有的在职经理的员工号SELECT emp_no FROM dept_manager dm WHERE dm.`to_date`='9999-01-01';### 2.查出工资最高的经理的员工号 SELECT emp_no, salaryFROM salaries sWHERE s.`to_date` = '9999-01-01' AND s.emp_no IN (SELECT emp_no FROM dept_manager dm WHERE dm.`to_date`='9999-01-01')ORDER BY s.salary DESCLIMIT 1;### 3.查出工资最高的经理的部门号 SELECT dm.dept_noFROM dept_manager dmWHERE dm.`emp_no` IN (SELECT t.emp_no FROM ( SELECT emp_no, salaryFROM salaries sWHERE s.`to_date` = '9999-01-01' AND s.emp_no IN (SELECT emp_no FROM dept_manager dm WHERE dm.`to_date`='9999-01-01')ORDER BY s.salary DESCLIMIT 1) AS t); ### 4.由3结果查询该部门内所有在职员工号 SELECT de.`emp_no`FROM dept_emp deWHERE de.`dept_no` IN ( SELECT dm.dept_noFROM dept_manager dmWHERE dm.`emp_no` IN (SELECT t.emp_no FROM (SELECT emp_no, salary, from_date, to_dateFROM salaries sWHERE s.`to_date` = '9999-01-01' AND s.emp_no IN (SELECT emp_no FROM dept_manager dm WHERE dm.`to_date`='9999-01-01')ORDER BY s.salary DESCLIMIT 1) AS t)) AND de.`to_date`='9999-01-01'; ### 5.由4结果查询工资最低的员工号SELECT s.`emp_no`,s.`salary` FROM salaries s WHERE s.`emp_no` IN (SELECT de.`emp_no`FROM dept_emp deWHERE de.`dept_no` IN ( SELECT dm.dept_noFROM dept_manager dmWHERE dm.`emp_no` IN (SELECT t.emp_no FROM (SELECT emp_no, salary, from_date, to_dateFROM salaries sWHERE s.`to_date` = '9999-01-01' AND s.emp_no IN (SELECT emp_no FROM dept_manager dm WHERE dm.`to_date`='9999-01-01')ORDER BY s.salary DESCLIMIT 1) AS t)) AND de.`to_date`='9999-01-01') AND s.`to_date`='9999-01-01' ORDER BY s.`salary` LIMIT 1;### 6.由5结果查询出所需信息 SELECT s.`emp_no`, CONCAT( e.`first_name`, ' ', e.`last_name` ) AS 'name', t.`title`, s.`salary`FROM employees e, titles t, (SELECT s.`emp_no`, s.`salary` FROM salaries s WHERE s.`emp_no` IN (SELECT de.`emp_no` FROM dept_emp de WHERE de.`dept_no` IN (SELECT dm.dept_no FROM dept_manager dm WHERE dm.`emp_no` IN (SELECT t.emp_no FROM (SELECT emp_no, salary, from_date, to_date FROM salaries s WHERE s.`to_date` = '9999-01-01' AND s.emp_no IN (SELECT emp_no FROM dept_manager dm WHERE dm.`to_date` = '9999-01-01') ORDER BY s.salary DESC LIMIT 1) AS t)) AND de.`to_date` = '9999-01-01') AND s.`to_date` = '9999-01-01' ORDER BY s.`salary` LIMIT 1) AS sWHERE e.`emp_no` = t.`emp_no` AND t.`to_date` = '9999-01-01' AND s.`emp_no` = e.`emp_no`;+--------+----------------+-------+--------+| emp_no | name | title | salary |+--------+----------------+-------+--------+| 65337 | Youngkon Munck | Staff | 39821 |+--------+----------------+-------+--------+1 row in set (2.60 sec) SQL99语法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338/*sql99语法： select 查询列表 from 表1 别名 【连接类型】join 表2 别名 on 连接条件 【where 筛选条件】 【group by 分组】 【having 筛选条件】 【order by 排序列表】 分类： 内连接（★）：【inner】 join 外连接 左外(★):left 【outer】 join 右外(★)：right 【outer】 join 全外：full【outer】join 交叉连接：cross join*/USE employees;SELECT * FROM departments;SELECT * FROM dept_emp;# 内连接（相交部分）/*语法： select 查询列表 from 表1 别名 【inner】 join 表2 别名 on 连接条件;分类： 等值 非等值 自连接特点： ①添加排序、分组、筛选 ②inner可以省略 ③与sql92相比，筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读 ④inner join连接和sql92语法中的连接效果是一样的，都是查询多表的【交集】*/## 笛卡尔积/*cross join是纯粹的笛卡尔积，理论上不应该支持on语法，但是MySQL在这方面做的比较奇怪。cross join也可以添加on条件。所以在mysql中，cross join和inner join可以等同，相互替代。*/SELECT * FROM employees,departments;SELECT * FROM employees INNER JOIN departments;SELECT * FROM employees JOIN departments;## 等值连接 SELECT *FROM salaries s JOIN employees e ON e.`emp_no` = s.`emp_no` AND s.`to_date` = '9999-01-01'WHERE e.`first_name` = 'Parto';# 外连接 /* 应用场景：用于查询一个表中有，另一个表没有的记录 特点： 1、外连接的查询结果为主表中的所有记录 如果从表中有和它匹配的，则显示匹配的值 如果从表中没有和它匹配的，则显示null 【外连接查询结果 = 内连接结果 + 主表中有而从表没有的记录】 2、左外连接，left join左边的是主表 右外连接，right join右边的是主表 3、左外和右外交换两个表的顺序，可以实现同样的效果 4、【全外连接 = 内连接的结果 + 表1中有但表2没有的 + 表2中有但表1没有的】 */## 左外连接 SELECT *FROM departments d LEFT OUTER JOIN dept_emp de ON d.`dept_no` = de.`dept_no` AND de.`to_date` = '9999-01-01'; ## 右外连接 SELECT *FROM dept_emp de RIGHT OUTER JOIN departments d ON d.`dept_no` = de.`dept_no` AND de.`to_date` = '9999-01-01'; ## 左外连接（不包含相交部分） SELECT *FROM departments d LEFT OUTER JOIN dept_emp de ON d.`dept_no` = de.`dept_no` AND de.`to_date` = '9999-01-01' WHERE de.`dept_no` IS NULL; ## 右外连接（不包含相交部分） SELECT *FROM dept_emp de RIGHT OUTER JOIN departments d ON d.`dept_no` = de.`dept_no` AND de.`to_date` = '9999-01-01' WHERE de.`dept_no` IS NULL;## 不包含相交部分 (SELECT *FROM departments d LEFT OUTER JOIN dept_emp de ON d.`dept_no` = de.`dept_no` AND de.`to_date` = '9999-01-01'WHERE de.`dept_no` IS NULL)UNION(SELECT *FROM departments d RIGHT OUTER JOIN dept_emp de ON d.`dept_no` = de.`dept_no` AND de.`to_date` = '9999-01-01'WHERE d.`dept_no` IS NULL);## 全连接（包含三部分） /*union默认是去重的，如果不想去重，使用union all*/(SELECT *FROM departments d LEFT OUTER JOIN dept_emp de ON d.`dept_no` = de.`dept_no` AND de.`to_date` = '9999-01-01')UNION(SELECT *FROM departments d RIGHT OUTER JOIN dept_emp de ON d.`dept_no` = de.`dept_no` AND de.`to_date` = '9999-01-01'); # 练习：查询工资最高的在职经理所在的部门的工资最低的在职员工的姓名，职位，工资。 ## 1.查出所有的在职经理 SELECT dm.`emp_no`, dm.`dept_no`FROM dept_manager dm WHERE dm.`to_date`='9999-01-01'; ## 2.查出1中的经理中工资最高的 SELECT s.`emp_no`, s.`salary`FROM salaries sWHERE s.`emp_no` IN (SELECT dm.`emp_no` FROM dept_manager dm WHERE dm.`to_date` = '9999-01-01')ORDER BY s.`salary` DESCLIMIT 1;## 3.查出2中的经理所在的部门 SELECT dm.`dept_no`FROM dept_manager dmWHERE dm.`emp_no` IN (SELECT t.`emp_no` FROM (SELECT s.`emp_no`, s.`salary` FROM salaries s WHERE s.`emp_no` IN (SELECT dm.`emp_no` FROM dept_manager dm WHERE dm.`to_date` = '9999-01-01') ORDER BY s.`salary` DESC LIMIT 1) AS t);## 4.查出3中部门的所有在职员工 SELECT de.`emp_no`FROM dept_emp deWHERE de.`dept_no` IN (SELECT dm.`dept_no` FROM dept_manager dm WHERE dm.`emp_no` IN (SELECT t.`emp_no` FROM (SELECT s.`emp_no`, s.`salary` FROM salaries s WHERE s.`emp_no` IN (SELECT dm.`emp_no` FROM dept_manager dm WHERE dm.`to_date` = '9999-01-01') ORDER BY s.`salary` DESC LIMIT 1) AS t)) AND de.`to_date`='9999-01-01'; ## 5.查询4中所有员工的工资最低的员工号 SELECT s.`emp_no`, s.`salary`FROM salaries sWHERE s.`emp_no` IN (SELECT de.`emp_no` FROM dept_emp de WHERE de.`dept_no` IN (SELECT dm.`dept_no` FROM dept_manager dm WHERE dm.`emp_no` IN (SELECT t.`emp_no` FROM (SELECT s.`emp_no`, s.`salary` FROM salaries s WHERE s.`emp_no` IN (SELECT dm.`emp_no` FROM dept_manager dm WHERE dm.`to_date` = '9999-01-01') AND s.`to_date` = '9999-01-01' ORDER BY s.`salary` DESC LIMIT 1) AS t)) AND de.`to_date` = '9999-01-01') AND s.`to_date` = '9999-01-01'ORDER BY s.`salary`LIMIT 1; ## 6.查询5中的员工所需信息 SELECT e.`emp_no`, CONCAT( e.`first_name`, ' ', e.`last_name` ) AS 'name', p.`salary`, t.`title`FROM employees e JOIN titles t ON e.`emp_no` = t.`emp_no` AND t.`to_date` = '9999-01-01' JOIN (SELECT s.`emp_no`, s.`salary`FROM salaries sWHERE s.`emp_no` IN (SELECT de.`emp_no` FROM dept_emp de WHERE de.`dept_no` IN (SELECT dm.`dept_no` FROM dept_manager dm WHERE dm.`emp_no` IN (SELECT t.`emp_no` FROM (SELECT s.`emp_no`, s.`salary` FROM salaries s WHERE s.`emp_no` IN (SELECT dm.`emp_no` FROM dept_manager dm WHERE dm.`to_date` = '9999-01-01') AND s.`to_date` = '9999-01-01' ORDER BY s.`salary` DESC LIMIT 1) AS t)) AND de.`to_date` = '9999-01-01') AND s.`to_date` = '9999-01-01'ORDER BY s.`salary`LIMIT 1) AS p ON p.`emp_no` = e.`emp_no`;+--------+----------------+--------+-------+| emp_no | name | salary | title |+--------+----------------+--------+-------+| 65337 | Youngkon Munck | 39821 | Staff |+--------+----------------+--------+-------+1 row in set (2.48 sec) 子查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/*子查询含义： 出现在其他语句中的select语句，称为子查询或内查询 外部的查询语句，称为主查询或外查询分类： 按子查询出现的位置： select后面： 仅仅支持标量子查询 from后面： 支持表子查询 where或having后面：★ 标量子查询（单行） √ 列子查询 （多行） √ 行子查询 exists后面（相关子查询） 表子查询 按结果集的行列数不同： 标量子查询（结果集只有一行一列） 列子查询（结果集只有一列多行） 行子查询（结果集有一行多列） 表子查询（结果集一般为多行多列）*/# where或having后面 /*1、标量子查询（单行子查询）2、列子查询（多行子查询）3、行子查询（多列多行）特点：①子查询放在小括号内②子查询一般放在条件的右侧③标量子查询，一般搭配着单行操作符使用 比如：&gt; &lt; &gt;= &lt;= = &lt;&gt;列子查询，一般搭配着多行操作符使用 比如：in、any/some、all④子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果*/## 行子查询（结果集一行多列或多行多列）### 案例：查询员工编号最小并且工资最高的员工信息SELECT * FROM employeesWHERE (employee_id,salary)=( SELECT MIN(employee_id),MAX(salary) FROM employees);# select后面 /*仅仅支持标量子查询*/## 案例：查询每个部门的员工个数 SELECT d.*, (SELECT COUNT(*) FROM employees e WHERE e.department_id = d.`department_id`) 个数FROM departments d; # from后面 /*将子查询结果充当一张表，【必须起别名】。*/# exists后面（相关子查询） /*语法： exists(完整的查询语句)结果： 1或0*/## 案例：查询有员工的部门名### in SELECT department_nameFROM departments dWHERE d.`department_id` IN (SELECT department_id FROM employees) ### exists SELECT department_name FROM departments d WHERE EXISTS (SELECT * FROM employees e WHERE d.`department_id` = e.`department_id`); 分页查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*【分页查询】应用场景： 当要显示的数据，一页显示不全，需要分页提交sql请求语法： select 查询列表 from 表 【join type join 表2 on 连接条件 where 筛选条件 group by 分组字段 having 分组后的筛选 order by 排序的字段】 limit 【offset,】size; offset要显示条目的起始索引（起始索引从0开始） size 要显示的条目个数特点： ①limit语句放在查询语句的最后 ②公式 要显示的页数 page，每页的条目数size select 查询列表 from 表 limit (page-1)*size,size; size=10 page 1 0 2 10 3 20*/#案例1：查询前五条员工信息 SELECT *FROM employeesLIMIT 0, 5;SELECT * FROM employees LIMIT 5;#案例2：查询第11条——第25条SELECT * FROM employees LIMIT 10,15;#案例3：有奖金的员工信息，并且工资较高的前10名显示出来SELECT * FROM employees WHERE commission_pct IS NOT NULL ORDER BY salary DESC LIMIT 10 ; 联合查询1234567891011121314151617181920212223242526272829303132/*联合查询：union（联合、合并）：将多条查询语句的结果合并成一个结果语法： (查询语句1) union (查询语句2) union ...应用场景：要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时特点：★1、要求多条查询语句的查询列数是一致的，否则报错。2、要求多条查询语句的查询的每一列的类型和顺序最好一致，不然数据意义错误。3、union关键字默认去重，如果使用union all 可以包含重复项。*/#引入的案例：查询部门编号&gt;90或邮箱包含a的员工信息##做法一：SELECT * FROM employees WHERE email LIKE '%a%' OR department_id&gt;90;##做法二：(SELECT * FROM employees WHERE email LIKE '%a%')UNION(SELECT * FROM employees WHERE department_id&gt;90);##案例：查询中国用户中男性的信息以及外国用户中年男性的用户信息(SELECT id,cname FROM t_ca WHERE csex='男')UNION ALL(SELECT t_id,tname FROM t_ua WHERE tGender='male';)]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java实现模拟小球二维完全弹性斜碰]]></title>
    <url>%2F2017%2F12%2F18-java-ball-collision%2F</url>
    <content type="text"><![CDATA[Java实现模拟小球二维完全弹性斜碰QQ的桌球游戏初中那会很流行，当时就想着是怎么做到的呢？游戏开发其中也有很多门道，很多方面。这里我也不懂，只是做了一个桌球游戏的简单实现，实现的过程可能并不完美，不过还是尽量图文并茂、易于理解的写出来。如果有不正确的地方欢迎指正。 功能简述1、桌面是二维光滑平面，带有边缘（墙壁），没有阻力。2、球与球之间能实现完全弹性斜碰，即实现真正的物理上桌球的击球效果。 软件架构绘图使用JFrame嵌套JPanel，JPanel自带双缓冲，能够做到绘图减少闪烁。JPanel内使用Canvas、Graphics、Image绘图，Image也自带双缓冲。绘图功能由CanvasThread实现，球的运动和计算由CircleThread实现，球的数量控制由ServeThread实现。 png 原理详解 注意：在这里的实现中，球和圆是同一个意思，即球可以等价看出圆。 这里的球碰撞主要是要解决两个问题：碰墙、碰球。 球的运动比较简单，球的运动速度矢量V可以分解在xy轴上，即向量Vx和Vy（有方向和大小），单位时间可以通过加上Vx和Vy的改变球的位置坐标Lx、Ly，从而实现球的运动。不过这里有一个小细节需要注意一下，不然会出现球有速度却静止不动的情况。 碰墙比较好解决，只要球超出边界就让它对应的Vx或Vy取反就行，不过这里还有几个小细节需要注意一下，不然会出现球嵌在墙里出不来的情况。 碰球的问题就比较复杂了，高中物理学过一维上两个小球的正面弹性碰撞公式，这里是小球在二维平面上的弹性斜碰情况。（均是光滑、无阻力的平面） 不过弹性斜碰仍然是可以分解转换成正面弹性碰撞的，下面进行分步骤详细解说一下吧。 数据准备： 球内存储的数据为： 这些数据共同参与运算构成了整个运行流程。 第零步：先判断两个圆的位置 只有满足两个圆心距离dn小于或等于两个圆的半径和dc的情况才叫碰撞，即两圆相切或相交时，需要做进一步处理。否则两圆相离无需做处理。 相切时的示意图： 第一步：计算合速度的大小和方向 球内存储的数据只有Vx和Vy这两个矢量，没有球运动的合速度矢量。不过解决球的斜碰还是需要合速度矢量的，需要计算出来。 分解速度矢量和合速度矢量： 第二步：计算共同（相对）坐标系s，解决粘连问题，计算ab在s中的速度的大小和方向 这个步骤比较复杂，需要分成三步来解决。 1）计算共同（相对）坐标系s。 为了将斜碰转化为正碰，需要将球的运动坐标系进行转化，共同坐标系s的x轴是以两个圆心所在直线为基础，因为是球b相对于球a的坐标系，所以坐标系的原点即球a的圆心。 共同（相对）坐标系s： 2）解决粘连问题，或者碰撞时已经相交的情况，让两个圆后退到相切状态。 让两个圆由相交状态回退到相切状态，需要将两个圆沿着运动方向的反方向移动，移动到相切（或略微有相离）为止。移动的距离就是中间的重叠部分，更详细点就是分别修改圆的x轴和y轴数值，数值大小就是重叠部分的数值，因为是重叠所以要除以2，即 (dn-dc)/2。 移动的加减运算的公式是一致的，这是可以推导的。 解决粘连问题： 3）将ab的速度大小和方向由原坐标系转化为在共同坐标系s中的速度大小和方向。 将ab的合速度投影到共同坐标系s中，便于接下来计算正碰。 坐标转化： 第三步：计算完全弹性斜碰 ab球的速度映射到s坐标系后，处在y轴的分速度发生弹性正碰时不受影响。处在x轴的分速度就等价于弹性正碰。 两个小球弹性正碰的公式推导（百度百科）： 发生弹性正碰之后，原来的y轴的分速度没有变化，x轴的分速度按公式进行“变换”。 第四步：计算两球发生碰撞后在s中的各自新合速度大小和运动方向 新的合速度和运动方向很容易就可以得出。 发生弹性正碰之后的两个小球的分速度变化和新合速度： 第五步：将两球速度转化为原坐标系中的速度 只需要将合速度进行三角运算即可得到映射的分速度。 两球新的合速度矢量转化为原坐标系中的分速度： 第六步：更新 将碰撞后的新数据更新到圆的存储中即可。 碰撞后的新方向： 补充：整个过程中因为桌面光滑，完全无损失碰撞，所以所有的球的动能和应该是恒定不变的。 关键代码球的运动和碰墙检测代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * 小球沿着vx和vy移动，并对此时移动过程中撞击到墙做判断和处理（先解决球碰墙，再解决球碰球） * * 每次移动一个单位的vx和vy * * 需要打磨算法才能准确 */public void move() &#123; // 当X轴上碰到墙时,X轴行进方向改变 if (lx + vx + radius &gt;= width) &#123; // 只有确实是在向右墙运动时才掉头，防止和collide中的调整出现冲突，以下类似 if (vx &gt; 0) vx *= -1; else // 如果不加这个方法，则球可能会一直嵌在墙里 moveX(); &#125; else if (lx + vx - radius &lt;= 0) &#123; if (vx &lt; 0) vx *= -1; else moveX(); &#125; // 没碰壁时继续前进 else &#123; moveX(); &#125; // 当在Y轴上碰到墙时,Y轴行进方向改变 if (ly + vy + radius &gt;= height) &#123; if (vy &gt; 0) vy *= -1; else moveY(); &#125; else if (ly + vy - radius &lt;= 0) &#123; if (vy &lt; 0) vy *= -1; else moveY(); &#125; // 没碰壁时继续前进 else &#123; moveY(); &#125;&#125;private void moveX() &#123; if (abs(vx) &lt; 1) &#123; px += vx; if (abs(px) &gt;= 1) &#123; lx += round(px); px = 0; &#125; &#125; else &#123; lx += vx; px = 0; &#125;&#125;private void moveY() &#123; if (abs(vy) &lt; 1) &#123; py += vy; if (abs(py) &gt;= 1) &#123; ly += round(py); py = 0; &#125; &#125; else &#123; ly += vy; py = 0; &#125;&#125; 球的斜碰： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170/** * 解决小球之间的斜碰（二维平面，球==圆） * * 坐标系x轴向右为正，y轴向下为正 * * 需要打磨算法才能准确 * * @param circle */public void collide(Circle b) &#123; Circle a = this; int alx = a.lx, aly = a.ly, blx = b.lx, bly = b.ly; double avx = a.vx, avy = a.vy, bvx = b.vx, bvy = b.vy; int ar = a.radius, br = b.radius; int am = a.weight, bm = b.weight; // ----- 第零步：先判断两个圆的位置 ----- double dn = sqrt(pow(alx - blx, 2) + pow(aly - bly, 2)); double dc = ar + br; // 两圆重合 if (dn == 0) return; // 两圆相离则返回 if (dn &gt; dc + Main.ERROR_APART) return; // ----- 第一步：计算合速度的大小和方向 ----- // 计算a的合速度的值（不包含方向） double av = sqrt(pow(avx, 2) + pow(avy, 2)); // 计算a的运行角度（运行方向，[-π ~ π)） double a0 = acos(avx / av); if (avy != 0) a0 *= avy / abs(avy); // 计算b的合速度的值 double bv = sqrt(pow(bvx, 2) + pow(bvy, 2)); // 计算b的运行角度 double b0 = acos(bvx / bv); if (bvy != 0) b0 *= bvy / abs(bvy); // System.out.println(av + " " + (a0 * 180 / PI)); // System.out.println(bv + " " + (b0 * 180 / PI)); // ----- 第二步：计算共同（相对）坐标系s，以及ab在s中的速度的大小和方向 ----- // ----- 第二步：第一部分：计算共同（相对）坐标系s的参数 ----- // 计算圆b圆心相对于圆a圆心的坐标（注意y轴为数学上的y轴，与计算机中的y轴相反） int sx = blx - alx; int sy = bly - aly; // 计算b相对于a的速度方向和大小 double sz = sqrt(pow(sx, 2) + pow(sy, 2)); double s0 = acos(sx / sz); if (sy != 0) s0 *= sy / abs(sy); // System.out.println(sz + " " + (s0 * 180 / PI)); // ----- 第二步：第二部分：解决粘连问题，或者检测到碰撞时已经相交，让两个圆分离 ----- // 在这里 dc-ERROR_CROSS &lt;= dn &lt;= dc+ERROR_APART 算相切 // 两圆相交（或两圆粘连） if (dn &lt; dc - Main.ERROR_CROSS) &#123; double de = (dc - dn) / 2; double dx = de * cos(s0); double dy = de * sin(s0); alx -= dx * 2; aly -= dy * 2; blx += dx * 2; bly += dy * 2; &#125; // ----- 第二步：第三部分：将ab的速度大小和方向由原坐标系转化为在共同坐标系s中的速度大小和方向 ----- // 在s坐标系中a的新运动方向 double sa0 = a0 - s0; // 在s坐标系中a的新速度大小 double sav = av; // 在s坐标系中a的新速度在s的x轴上的投影 double savx = sav * cos(sa0); // 在s坐标系中a的新速度在s的y轴上的投影 double savy = sav * sin(sa0); // 在s坐标系中b的新运动方向 double sb0 = b0 - s0; // 在s坐标系中b的新速度大小 double sbv = bv; // 在s坐标系中b的新速度在s的x轴上的投影 double sbvx = sbv * cos(sb0); // 在s坐标系中b的新速度在s的y轴上的投影 double sbvy = sbv * sin(sb0); // ----- 第三步：发生完全弹性斜碰时，在s坐标系中，两球y轴速度不变，x轴速度满足完全弹性正碰（由动能定理和动量守恒推导） ----- // 碰撞后a球s坐标系x轴的分速度 double savxp = ((am - bm) * savx + 2 * bm * sbvx) / (am + bm); // 碰撞后a球s坐标系y轴的分速度 double savyp = savy; // 碰撞后b球s坐标系x轴的分速度 double sbvxp = ((bm - am) * sbvx + 2 * am * savx) / (am + bm); // 碰撞后b球s坐标系y轴的分速度 double sbvyp = sbvy; // ----- 第四步：计算两球发生碰撞后在s中的各自合速度大小和运动方向----- // 碰撞后a球在s坐标系的合速度大小 double savp = sqrt(pow(savxp, 2) + pow(savyp, 2)); // 碰撞后a球在s坐标系的运动方向 double sa0p = acos(savxp / savp); if (savxp == 0 &amp;&amp; savyp == 0) sa0p = 0; else if (savyp != 0) sa0p *= savyp / abs(savyp); // 碰撞后b球在s坐标系的合速度大小 double sbvp = sqrt(pow(sbvxp, 2) + pow(sbvyp, 2)); // 碰撞后b球在s坐标系的运动方向 double sb0p = acos(sbvxp / sbvp); if (sbvxp == 0 &amp;&amp; sbvyp == 0) sb0p = 0; else if (sbvyp != 0) sb0p *= sbvyp / abs(sbvyp); // ----- 第五步：将两球速度转化为原坐标系中的速度 ----- // 碰撞后a球在原坐标系的合速度大小 double fva = savp; // 碰撞后a球在原坐标系的运动方向 double fa0 = sa0p + s0; if (fa0 &gt; PI) fa0 -= 2 * PI; else if (fa0 &lt;= -PI) fa0 += 2 * PI; // 碰撞后a球在原坐标系的合速度大小在x轴上的分量 double fvax = fva * cos(fa0); // 碰撞后a球在原坐标系的合速度大小在y轴上的分量 double fvay = fva * sin(fa0) * -1; // 碰撞后b球在原坐标系的合速度大小 double fvb = sbvp; // 碰撞后b球在原坐标系的运动方向 double fb0 = sb0p + s0; if (fb0 &gt; PI) fb0 -= 2 * PI; else if (fb0 &lt;= -PI) fb0 += 2 * PI; // 碰撞后b球在原坐标系的合速度大小在x轴上的分量 double fvbx = fvb * cos(fb0); // 碰撞后b球在原坐标系的合速度大小在y轴上的分量 double fvby = fvb * sin(fb0) * -1; // ----- 第六步：更新 ----- a.lx = alx; a.ly = aly; b.lx = blx; b.ly = bly; a.vx = fvax; a.vy = fvay; b.vx = fvbx; b.vy = fvby;&#125; 测试结果运行过程中某一个时间段的动图（动图帧率比较低，会显示的有些卡顿）： 运行过程中某一刻的球运动数据输出： 从结果可以看出系统总能是守恒的。 总结思考游戏编程主要是将数学和物理（也有其他学科）的知识结合图像显示出来，编写一些小游戏代码，能够锻炼代码的逻辑能力，也能遇到到一些编程中的细节问题，同时也是将数学转为代码，锻炼思维能力。游戏编写过程中，也能体会到代码加数学的魔性，增强编程的兴趣。 源码 参考博客csdn]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Hash进行大文本文件的行搜索]]></title>
    <url>%2F2017%2F12%2F14-large-file-hash-search%2F</url>
    <content type="text"><![CDATA[利用Hash进行大文本文件的行搜索思考一个问题，如何在大文件中搜索一个指定的数据？这也是一道经常被问的面试题，不过搜索了一下，网上一般只提供了思路但是并没有什么实际的代码和案例。现在想着自己能够实现一下，并写下了这篇博客，水平有限，如有不正确的地方欢迎指正。 问题描述现在有两个按行存储的文本文件a.txt和b.txt，已知a.txt内有url共50亿条，b.txt内有url共500条。请问，b中的url在a中是否出现，如果出现，依次输出该url在b中的行号。 问题分析如果采用顺序搜索，对于小数据是可以的，但是对于大文本文件，那个需要的时间可想而知。虽然将数据读入内存后，会加快搜索的速度，但是计算机的内存容量一般远小于磁盘容量，如果将一个2G大小的文件读入内存，那个代价也是承受不起的。其他常见的搜索方法，如二分搜索法，二分搜索法的前提是数据是有序的，而对一个大文本文件排序也是不现实的，所以在这里也不适用。 因此必须采用其他的方法来搜索数据。我这里采用Hash查找做了一个自己觉得还可以的实现。 Hash查找常见的Hash算法有很多，这里我采用的是JavaAPI中String.hashCode()方法和取模Hash法结合使用。 取模Hash法任意一个整数a，如果对它进行取模运算，比如a % N，那么取模的结果必然在 0 ~ N-1 之间。这样对于一个大的随机整数集Q，如果把它们依次进行取模运算，那么这个整数集Q就可以近似被分成 N 组。（如果随机整数集Q足够随机，每个组的元素数量也是近似相等的）这样的话如果要查找某个数b，那么先将它进行取模运算 b % N，得到的余数p就自然可以被映射到那个已经分好N组的某个组G中，换句话说，b如果在Q中存在，那么必然也只能是在G中。此时再利用线性搜索对这个分组G进行查找的话，由于此时只有Q/N个元素，速度自然会快了不少。 由上可见，N的取值也是比较关键的。 String.hashCode()String类重写了hashCode()方法： 12345678public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; hash = h = isLatin1() ? StringLatin1.hashCode(value) : StringUTF16.hashCode(value); &#125; return h;&#125; JavaAPI文档的描述是这样的： 12345Returns a hash code for this string. The hash code for a String object is computed as s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1] using int arithmetic, where s[i] is the ith character of the string, n is the length of the string, and ^ indicates exponentiation. (The hash value of the empty string is zero.) 这是Java中默认的计算String的hash值的方法，将字符串转为一个整数。 结合这两个计算Hash值的方法，就可以解决上面的问题。 我的解决目标文件均为按行存储的文本文件。 第一次采用的尝试实现的方法是：1、遍历文件a，对每一行数据求hashCode，然后再对hashCode求N=100的模，根据求模的结果写入到对应的小文件中，比如h34.txt，并将这一行所在的行号写入到另一个小文件中，比如n34.txt。2、这样一次遍历后，原来超大的文本文件a可以被分割成100个小文件，原来文本文件中某数据的所在行也可以对应映射记录在100个小文件中。比如原来a中的第1234行的数据，求模的值是78，那么这行数据被添加在h78.txt的末尾，对应的行号也添加在n78.txt末尾。3、因为只有一个线程在操作，所以不存在多线程安全的问题。数据的映射关系保持正确。4、输入要查找的字符串数据s，先对s进行取N=100模运算，比如得到结果78，然后再读取h78.txt文件，按顺序读取h78.txt文件，并同时记录读取h78.txt的行数L，若在h78.txt找到和s一致的数据时，此时再去n78.txt读取到L行，读出n78.txt的L行数据就是s在原来文件a中的行号。循环下去，直到读完h78.txt为止，此时也相应的得到s在文件a中出现的次数，以及对应的所有行号。 具体实现可以选择InputStream、Reader，对应的实现类BufferInputStream，FileInputStream、BufferedReader，FileReader，LineNumberReader。 第一种方法很好理解，也容易实现。不过需要在磁盘中多出很多额外的小文件，占有更多的磁盘空间。另外频繁的读取磁盘，不仅速度慢，而且也影响了磁盘的寿命。 对应第一种方法中的不足加以改进，第二次采用的尝试实现的方法是：1、在内存中建立一个Map，Map的键是Integer类型，Map的值是一个List。具体如下：12// Map&lt;Hash值，数据所在行的信息&gt;private Map&lt;Integer, List&lt;LineInfo&gt;&gt; store; 其中LineInfo存储了数据的所在行号、该行的开头在文件中的位置、该行数据的完整hash值。123456789// 数据所在行的信息private class LineInfo &#123; // 数据所在行号 private int lineNumber; // 该行的开头在文件中的位置 private long position; // 该行数据的完整hash值 private int hashValue;&#125; 2、遍历文件a，对每一行数据求hashCode，然后再对hashCode求N=100的模，得到求模的结果M，将M加入到Map中key=M的List中。3、查找数据s时和第一种方法类似，不同的是操作的是Map，获得Map中模存储的List，接着再遍历List即可。4、遍历List时，先判断s的hashCode和List中存储的LineInfo.hashValue是否一致，如果不一致则数据内容肯定不一致，能减少读取磁盘的次数，加快执行速度。然后再根据LineInfo.position定位到数据在文件a中的位置，读取出具体的数据，再使用equals方法进一步判断内容是否一致；由LineInfo.lineNumber可以得到数据在文件a的行号。这样重复操作，就可以解决上述问题。 具体的实现使用RandomAccessFile即可。 不过第二种方法在测试过程中，建立hash表的时间太长，同等文件大小下比第一种方法慢的多。既然都是文件读取操作，时间差别应该不是很大，所以还是需要改进的。 考虑到RandomAccessFile并没有BufferedInputStream和BufferedReader那样的缓存区，而是几乎每次都需要读取磁盘，才读若干行就需要去操作磁盘一次（从任务管理器也可以看的出来），虽然操作系统具有一部分缓存区，但是如果能一次读出一块放在内存中再进行计算，速度岂不是能大大提高。 为此在第二种方法的基础上，又加以改进，得到了第三种方法，即使用RandomAccessFile+byte[]的方式。 速度较慢的构建hash表的方式：12345678910111213141516171819202122232425262728// 慢速private void build0() &#123; store = new HashMap&lt;&gt;(); try &#123; file = new RandomAccessFile(path, "r"); // 行号从1开始 int lineNumber = 1; long cursor = 0; String lineStr = null; List&lt;LineInfo&gt; lineInfos = null; while ((lineStr = file.readLine()) != null) &#123; // 方便find查找 int realHashValue = lineStr.hashCode(); int hashCode = Math.abs(realHashValue) &amp; BASE; lineInfos = store.get(hashCode); if (lineInfos == null) &#123; lineInfos = new ArrayList&lt;&gt;(); store.put(hashCode, lineInfos); &#125; // 顺序添加，更进一步的意思是按照出现的顺序添加，能简化查找操作 lineInfos.add(new LineInfo(lineNumber++, cursor, realHashValue)); cursor = file.getFilePointer(); &#125; System.out.println("build slow-mode has read lines " + (lineNumber - 1)); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125;&#125; 速度较快的构建hash表的方式：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 快速private void build1() &#123; store = new HashMap&lt;&gt;(); try &#123; file = new RandomAccessFile(path, "r"); // 一次读取64M int bufLen = 1024 * 1024 * 64; byte[] buf = new byte[bufLen]; // 注意使用long long times = 0; int readLen = -1; // 行号从1开始 int lineNumber = 1; // 回退的位数 long back = 0; while ((readLen = file.read(buf)) != -1) &#123; times++; int cursor = 0; while (cursor &lt; readLen) &#123; int start = cursor; int offset = 0; int left = readLen - start; while (offset &lt; left) &#123; // 数据文件中的每一行数据的末尾必须要有'\n' if (buf[start + offset] == '\n') break; offset++; cursor++; &#125; if (offset == left) &#123; back += left; break; &#125; else &#123; if (offset &gt; 0 &amp;&amp; buf[start + offset - 1] == '\n') offset--; if (offset &gt; 0 &amp;&amp; buf[start + offset - 1] == '\r') offset--; String lineStr = new String(buf, start, offset); // 方便find查找 int realHashValue = lineStr.hashCode(); // 与方式取模，速度更快，前提是BASE必须是2^n-1 int hashCode = Math.abs(realHashValue) &amp; BASE; List&lt;LineInfo&gt; lineInfos = store.get(hashCode); if (lineInfos == null) &#123; lineInfos = new ArrayList&lt;&gt;(); store.put(hashCode, lineInfos); &#125; // 顺序添加，更进一步的意思是按照出现的顺序添加，能简化查找操作 lineInfos.add(new LineInfo(lineNumber++, (times - 1) * bufLen - back + start, realHashValue)); &#125; cursor++; &#125; file.seek(times * bufLen - back); &#125; System.out.println("build fast-mode has read lines " + (lineNumber - 1)); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125;&#125; 查找数据的方法：1234567891011121314151617181920212223242526272829303132333435/** * 查找 * * @param search * @return */public List&lt;Integer&gt; find(String search) &#123; if (search == null) throw new RuntimeException("string is null"); if (store == null) throw new RuntimeException("has not built yet"); int searchHashValue = search.hashCode(); int hashCode = Math.abs(searchHashValue) &amp; BASE; List&lt;LineInfo&gt; lineInfos = store.get(hashCode); if (lineInfos == null) return null; List&lt;Integer&gt; lines = new ArrayList&lt;&gt;(); try &#123; String lineStr = null; for (LineInfo line : lineInfos) &#123; // hash不一样，内容肯定不一样，能加快判断的速度 if (searchHashValue != line.hashValue) continue; file.seek(line.position); lineStr = file.readLine(); // 进一步判断内容 if (search.equals(lineStr)) // 行号从1开始 lines.add(line.lineNumber); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; return lines.size() &gt; 0 ? lines : null;&#125; 测试结果如果数据文件中的行数为10万，需要查找的数据为10条时，执行的结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899====== HASH SEARCH ======START MAKINGMAKING COST 139FAST MODESTART BUILDINGBUILDING COST 177START FINDING1 http://url.cn/FIND: 6330EXAMPLE: 1 5 10 20 22 FINDING STEP COST 20149 http://url.cn/IlqFIND: 1EXAMPLE: 49 FINDING STEP COST 119 http://url.cn/r0pX8W4I6FIND: 1EXAMPLE: 19 FINDING STEP COST 072 http://url.cn/1mhXGMclLYQkFIND: 1EXAMPLE: 72 FINDING STEP COST 0120 http://url.cn/JFIND: 101EXAMPLE: 120 1778 1798 2787 3335 FINDING STEP COST 458 http://url.cn/ThZfMpoMVhLwFIND: 1EXAMPLE: 58 FINDING STEP COST 011 http://url.cn/C0o3lk4FyAOewkPFIND: 1EXAMPLE: 11 FINDING STEP COST 091 http://url.cn/NstBXfBXEEJD3FIND: 1EXAMPLE: 91 FINDING STEP COST 045 http://url.cn/yxFIND: 2EXAMPLE: 45 94836 FINDING STEP COST 193 http://url.cn/A9moFIND: 1EXAMPLE: 93 FINDING STEP COST 0FINDING TOTAL COST 207SLOW MODESTART BUILDINGBUILDING COST 4329START FINDING1 http://url.cn/FIND: 6330EXAMPLE: 1 5 10 20 22 FINDING STEP COST 19149 http://url.cn/IlqFIND: 1EXAMPLE: 49 FINDING STEP COST 019 http://url.cn/r0pX8W4I6FIND: 1EXAMPLE: 19 FINDING STEP COST 072 http://url.cn/1mhXGMclLYQkFIND: 1EXAMPLE: 72 FINDING STEP COST 0120 http://url.cn/JFIND: 101EXAMPLE: 120 1778 1798 2787 3335 FINDING STEP COST 558 http://url.cn/ThZfMpoMVhLwFIND: 1EXAMPLE: 58 FINDING STEP COST 011 http://url.cn/C0o3lk4FyAOewkPFIND: 1EXAMPLE: 11 FINDING STEP COST 091 http://url.cn/NstBXfBXEEJD3FIND: 1EXAMPLE: 91 FINDING STEP COST 045 http://url.cn/yxFIND: 2EXAMPLE: 45 94836 FINDING STEP COST 093 http://url.cn/A9moFIND: 1EXAMPLE: 93 FINDING STEP COST 0FINDING TOTAL COST 198true 由测试结果可知：1、慢速和快速构建hash表的结果一致(true)。2、慢表的构建表的速度为4329毫秒，快表的构建表速度是177毫秒。3、使用Hash表进行文件的查找速度非常快，不用测试都能看出比顺序查找快很多。当数据重复行较多时，操作的主要耗时在读取行并判断equals上，这里还是可以再改进的。 接下来结合上面的内容再测试几组更大的数据规模，并使用Notepad++软件搜索计数功能手动验证部分结果，得到下表： 结果显示使用快速构建Hash表查找的方式的效果还是很不错的，实验的目的基本达成。 2017年12月22日补充： 如果将store改成双层hash，如下：12// Map&lt;Hash值，&lt;某行数据的hash值,数据所在行的信息&gt;&gt;private Map&lt;Integer, Map&lt;Integer, List&lt;LineInfo&gt;&gt;&gt; store; 虽然理论上查找速度会略微有提升，但是因为第二层Map有很多长度只有1的List，因此内存占用增大，CPU占用率也会大幅增加，查找速度反而又会下降。所以一层hash的效果更好一些。不过也应该有其他更好的优化方式，等遇到再说吧。 总结思考在解决这个问题的时候，也简单搜索了一下hash的具体应用，发现hash的用处广范而强大，比如分布式集群控制系统使用hash来实现，真的是简单的东西深挖下去不简单。 多动手，多思考。 源码]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程之工作流网图]]></title>
    <url>%2F2017%2F12%2F11-java-multithreads-product-diagram%2F</url>
    <content type="text"><![CDATA[Java多线程之工作流网图工作流网图基于前驱图实现。较之前几个问题，这个问题也是生产中的常见的模型，有人把这个模型称为AOE和AOV。 操作系统原理之进程和线程管理Java的多线程和并发知识纲要Java多线程之生产者和消费者模式Java多线程之哲学家就餐问题Java多线程之读者写者问题Java多线程之吸烟者问题Java多线程之熟睡的理发师问题 AOV和AOEAOV网与工作流网（AOE）在模型结构上是相似的，它们都是基于图的结构，以节点表示活动，有向边表示流程的流向。 AOV网的有向边仅仅只表示活动的前后次序，也可以说是流程中的流程流向。工作流网中的有向边却不仅如此，它可以在每条边上设置不同的条件来决定活动的下一环节是什么，它的出度就不一定是所有有向边了。 因此，AOV网其实是工作流网（AOE）的一种特例，是一种全入全出的有向无环工作流网。 AOE网的定义是在带权有向图中若以顶点表示事件，有向边表示活动，边上的权值表示该活动持续的时间。从定义上来看，很容易看出两种网的不同，AOV网的活动以顶点表示，而AOE网的活动以有向边表示。 纵观这两种网图，其实它们总体网络结构是一样的，仅仅是活动所表示的方式不同，因此从AOV网转换成AOE网应该是可行的。 问题描述在生产中，比如玩具组装车间情景里，有这样的流水线（可能不准确，只是为了说明工作流网）： 某一个节点，比如P3，它需要等待P0和P2的工作完成后才能进行工作。 问题分析AOE是边上有权值，节点值为“0”（只是为了理解，更准确的是“没有”）。AOV可以转换成AOE，只要将路径上的权值设置为“0”，节点值设置为非“0”。 在这个问题下，工作流图的图存储：1、如果使用邻接矩阵的话，存储边上的权值比较方便，但是去寻找节点的出度需要遍历操作。2、如果使用邻接表的话，存储边上的权值比较麻烦，但是去寻找节点的出度比较方便。 进程之间的工作完成的通知可以使用信号量。 我的解决我采用的工作流图的图存储方式是邻接矩阵，矩阵内的元素包含权值和信号量，这样既能方便找到某节点的出度和入度到某节点的源节点，也能迅速定位到这条边所使用的信号量。使用邻接表的话则不大容易实现。 将上图的工作流网图加上具体的边上权值，节点值为“0”，如下图： 源码实现具体的详细源码可以参看文末的链接。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172private class NodeThread extends Thread &#123; private int id; private String name; // 该节点生产时间 private int time; // 生产的次数 private int amount; private volatile boolean status; public NodeThread(int id, int time) &#123; this.id = id; this.name = "node-" + id; this.time = time; &#125; @Override public void run() &#123; try &#123; status = true; barrier.await(); System.out.println(name + " is ready"); long begin = System.currentTimeMillis(); while (status) &#123; System.out.println(name + " wait for semaphores"); long start = System.currentTimeMillis(); recv(); System.out.println(name + " is working"); process(); long end = System.currentTimeMillis(); System.out.println(name + " finish work, cost " + (end - start) + ", amount " + amount); send(); System.out.println(name + " has sent semaphores"); &#125; long finish = System.currentTimeMillis(); System.out.println(name + " IS DONE, TOTAL COST " + (finish - begin) + ", FINAL AMOUNT " + amount); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; // 等待所有入该节点的信号量 public void recv() throws InterruptedException &#123; for (int i = 0; i &lt; nums; i++) &#123; Edge e = diagram[i][id]; if (e == null) continue; e.semaphore.P(); &#125; &#125; // 通知所有出该节点的信号量 public void send() &#123; for (int i = 0; i &lt; nums; i++) &#123; Edge e = diagram[id][i]; if (e == null) continue; executor.schedule(new Msg(e.semaphore), e.value, TimeUnit.SECONDS); &#125; &#125; // 生产该节点负责的部分 public void process() throws InterruptedException &#123; Thread.sleep(time * 1000); if (++amount == goods) status = false; &#125;&#125; 结果分析P7和P0不相连，AOEP7和P0不相连，AOE，运行过程中某一个片段情况如下图： 从运行片段情况可以看出，整个网图第一次生产的过程耗时是最长的，花费了14012毫秒，同时也就是关键路径P0-&gt;P2-&gt;P3-&gt;P5-&gt;P7所耗费的时间。由于整个网络的生产是并行进行的，所以之后的生产速度就快了很多，这也是流水线生产模式的优势。 如果生产的产品数量是固定的，比如10件，即每个节点生产10次。此时观察运行结果，可以看到各个节点结束运行的先后顺序是：P0-&gt;P2-&gt;P1-&gt;P4-&gt;P3-&gt;P6-&gt;P5-&gt;P7。这个结束的顺序，对照上面的流图分析也是吻合的。 生产10件产品的总时间是14018毫秒（稍大于14秒）。 P7和P0相连，AOE如果将P7和P0相连，即增加一条图的有向边P7-&gt;P0。也就意味着P0必须等待P7生产完才能生产，那么整个流水线就变成同时只能生产一个完整产品。 假设第一次执行时P0无需等待P7的信号。 此时的运行过程中某一个片段情况如下图： 第一次循环时各个节点的执行时间与流图吻合，但是之后的循环却显示出每个节点等待的时间等于关键路径所需要的时间，如下图所示： P7和P0相连，AOE，生产10件产品的总时间： 此时观察运行结果，每次循环的执行顺序是固定的：P0-&gt;P2-&gt;P1-&gt;P4-&gt;P3-&gt;P6-&gt;P5-&gt;P7，与流图吻合。 生产10件产品的总时间是140081毫秒（约14*10秒，远大于14秒）。 P7和P0不相连，AOV如果更改每个edge的权值为“0”，节点值为非“0”，那么AOE就转变成AOV，如下图： 此时的运行过程中某一个片段情况（也是第一次循环时各个节点的执行时间，耗时15秒）如下图： P7和P0不相连，AOV，生产10件产品的总时间： 此时观察运行结果，可以看到各个节点结束运行的先后顺序是：P0-&gt;P2-&gt;P1-&gt;P4-&gt;P3-&gt;P5-&gt;P6-&gt;P7，与流图吻合。 生产10件产品的总时间是60023毫秒（约60秒，15+(2+3)*9）。 P7和P0相连，AOV在AOV的情况下，如果P7和P0相连的话，工作情况和AOE下P7和P0相连的情况是类似的。 P7和P0相连，AOV，生产10件产品的总时间： 此时观察运行结果，每次循环的执行顺序是固定的：P0-&gt;P2-&gt;P1-&gt;P4-&gt;P3-&gt;P5-&gt;P6-&gt;P7，与流图吻合。 生产10件产品的总时间是150044毫秒（约15*10秒）。 总结思考AOE示意图： AOV示意图： 具体AOE和AOV的知识还是等自己深入学习到数据结构–图再说吧，水平还不足请谅解。 多线程实现工作流图，也是线程之间的同步和协作的例子，还是比较有意思的哈。同时自己的数据结构知识还有待加强，学的越多圆圈越大，不知道的也越多。 源码]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
        <tag>数据结构</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程之熟睡的理发师问题]]></title>
    <url>%2F2017%2F12%2F10-java-multithreads-sleep-barber-learn%2F</url>
    <content type="text"><![CDATA[Java多线程之熟睡的理发师问题理发师问题也是经典问题之一，最经典的三个线程同步互斥问题是：生产消费者问题、哲学家就餐问题、读者写者问题。这三个问题的解决方案有很多，不同的方法也有不同的含义和原理，需要好好理解。各个方法中，信号量是通用的方法，理发师问题也可以用信号量来解决。 操作系统原理之进程和线程管理Java的多线程和并发知识纲要Java多线程之生产者和消费者模式Java多线程之哲学家就餐问题Java多线程之读者写者问题Java多线程之吸烟者问题 问题描述某理发店里只有一名理发师，一张理发椅，若干张顾客等待椅。理发师每天除了理发就是睡觉。理发店的生意很好，需要理发的人很多。如果一名需要理发的顾客，进店发现等待椅坐满了，他就走了，决定稍后再来。如果发现等待椅子上还有空位，他就走进店里坐下来等待，不过只会等待一会（每位顾客能等待的时间不一样），如果超过时间就放弃等待，离店并稍后再来。坐在等待椅上的顾客会不断注意理发师的状态，如果他不在理发而在睡觉中（哪怕刚睡着），就会尝试去叫醒理发师。叫醒理发师的顾客可以理发，但是需要抢占理发椅，只有抢占到理发椅的顾客才能离开等待椅，并坐到理发椅上由理发师理发。理发师理完发后，顾客起身离开理发椅，并离开理发店，对理发师的手艺很满意决定不久后再来。理发师一理完发就会睡觉，由于理发师只能由等待的顾客叫醒，所以如果理发店如果没有顾客的话理发师将一直睡着。理发师想睡觉只能睡在理发椅上，所以只有当理发师醒了，顾客才能去抢坐理发椅。 问题分析理发师问题看上去比较复杂，不过仔细分析，化繁就简还是能解决的。 假设顾客一直想理发，哪怕是刚刚理完发离店后不久还会再来。 顾客的状态：门外状态、等待状态、理发状态。理发师的状态：睡觉状态、理发状态。椅子（等待椅和理发椅）的状态：有人、没人。 状态变化分析： 1、在等待状态的顾客会一直尝试唤醒处在睡觉状态的理发师。2、在门外状态的顾客会每隔一段时间尝试进店，成为等待状态。3、在等待状态的顾客可能会等待一段时间后离开，变成门外状态。 具体做法分析：1、顾客尝试离开或坐入等待椅：等待椅的数量是一个临界资源chair，只能同时由一名顾客去操作。 2、顾客进门尝试坐在等待椅上：需要一个进入店门的信号量door，尝试进门的顾客先去door排队（P），获得door的顾客才能进店。进入店后查看等待椅的状态，如果椅子满了，就转身离开，并归还door信号量（V）。如果椅子没坐满，那么将等待临界资源chair，修改chair-1。修改好chair后才会归还door信号量（V）。这样的操作确保进店（拿到door）的顾客一次只有一个，且要么能坐到等待椅上，要么不能。 3、等待中的顾客唤醒理发师：坐在等待椅上的顾客只做一件事，如果理发师在睡觉就唤醒它。 4、顾客抢占理发椅：成功叫醒理发师后，所有的等待中的顾客都会尝试去占有理发椅，但是只有一个顾客能成功占有理发椅。其余顾客将继续保持等待状态。理发椅是临界资源，在理发师清醒状态下，只能由一名顾客占有。占有理发椅的顾客将进入理发状态，理发完成之后顾客离开理发椅。 我的解决各个对象的状态其实是为了方便理解，在实际代码中并不会使用到。 理发师： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package com.chain.test.day07;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;/** * 理发师 * * @author chain * */public class Barber &#123; // 理发师的姓名 private String name = "barber"; // 理发椅 private WorkChair workChair; private ReentrantLock lock; private Condition cond; // 理发师理过的顾客数量 private long times; public long getTimes() &#123; return times; &#125; public Condition getCondition() &#123; return cond; &#125; public WorkChair getWorkChair() &#123; return workChair; &#125; public ReentrantLock getLock() &#123; return lock; &#125; public Barber(WorkChair workChair) &#123; this.workChair = workChair; this.lock = new ReentrantLock(); this.cond = this.lock.newCondition(); &#125; public String getName() &#123; return name; &#125; /** * 理发师睡觉 * * @throws InterruptedException */ public void sleep() throws InterruptedException &#123; // 如果理发椅上没有顾客就睡觉 if (workChair.get() == null) &#123; lock.lock(); try &#123; if (workChair.get() == null) &#123; // 在这里理发师不会睡在理发椅上 System.out.println(name + " is sleeping"); cond.await(); System.out.println(name + " is awake"); &#125; &#125; finally &#123; if (lock.isLocked()) lock.unlock(); &#125; &#125; &#125; /** * 给顾客理发 * * @throws InterruptedException */ public void work() throws InterruptedException &#123; Customer customer = workChair.get(); if (customer == null) &#123; System.out.println("no customer in chair, the barber is confused"); return; &#125; System.out.println(name + " is working"); customer.enjoy(); customer.bye(this); ++times; System.out.println(name + " is completed, times " + times); &#125;&#125; 顾客： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125package com.chain.test.day07;import java.util.concurrent.locks.ReentrantLock;/** * 顾客 * * @author chain * */public class Customer &#123; // 顾客序号 private int id; // 顾客姓名 private String name; // 顾客是否进入店里 private volatile boolean enter; // 顾客理过的次数 private long times; public Customer(int id) &#123; this.id = id; this.name = "customer-" + id; &#125; public int getId() &#123; return id; &#125; public String getName() &#123; return name; &#125; /** * 顾客理发中 * * @throws InterruptedException */ public void enjoy() throws InterruptedException &#123; System.out.println(name + " is enjoying"); process(100); times++; System.out.println(name + " is finished, times " + times); &#125; public long getTimes() &#123; return times; &#125; /** * 顾客尝试叫醒理发师，成功叫醒理发师的顾客能得到理发 * * @param waitChairs * @param barber * @return * @throws InterruptedException */ public boolean awake(Chair waitChairs, Barber barber) throws InterruptedException &#123; ReentrantLock lock = barber.getLock(); WorkChair workChair = barber.getWorkChair(); // 在这里如果理发椅有人，则理发师一定醒着并在理发中，则该顾客放弃叫醒理发师，继续保持等待 if (!workChair.isFull()) &#123; if (lock.tryLock()) &#123; try &#123; if (!workChair.isFull()) &#123; // 顾客先尝试坐在理发椅上 workChair.sit(this); // 然后再离开等待椅 waitChairs.leave(this); System.out.println(name + " has left wait-chair, and sit on the work-chair"); // 之后通知理发师 barber.getCondition().signal(); return true; &#125; &#125; finally &#123; if (lock.isLocked()) lock.unlock(); &#125; &#125; &#125; return false; &#125; public void outdoor() throws InterruptedException &#123; process(50); &#125; public void dosth() throws InterruptedException &#123; process(30); &#125; // cost越小，越接近高并发 private void process(int cost) throws InterruptedException &#123; Thread.sleep(cost * ((int) (Math.random() * 9) + 1)); &#125; /** * 顾客离开理发椅，并走出理发店 * * @param barber * @throws InterruptedException */ public void bye(Barber barber) throws InterruptedException &#123; barber.getWorkChair().leave(); leave(); &#125; public void leave() &#123; this.enter = false; &#125; public void enter() &#123; this.enter = true; &#125; public boolean isEntered() &#123; return enter; &#125;&#125; 椅子（等待椅）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.chain.test.day07;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;/** * 椅子 * * 不同类型的椅子看成一个整体 * * 类似一个阻塞队列 * * @author chain * */public class Chair &#123; // 已经坐在椅子上的顾客 private Map&lt;Integer, Customer&gt; customers; // 已经坐在椅子上的顾客的数量 protected int n; // 该种类椅子总共的数量 protected volatile int limit; // 椅子类型 private String name; public Chair(String name, int limit) &#123; this.name = name; this.limit = limit; this.customers = new ConcurrentHashMap&lt;&gt;(limit &lt;&lt; 1); &#125; public String getName() &#123; return name; &#125; /** * 顾客尝试坐下 * * @throws InterruptedException */ public synchronized void sit(Customer customer) throws InterruptedException &#123; // 避免直接使用ConcurrentHashMap.size() while (n &gt;= limit) wait(); customers.put(customer.getId(), customer); ++n; notify(); &#125; /** * 顾客尝试离开 * * @throws InterruptedException * */ public synchronized void leave(Customer customer) throws InterruptedException &#123; while (n &lt;= 0) wait(); customers.remove(customer.getId()); --n; notify(); &#125; /** * 获得椅子上的顾客 * * @return */ public Customer get(Customer customer) &#123; return customers.get(customer.getId()); &#125; /** * 椅子是否坐满了 * * @return */ public boolean isFull() &#123; return n &gt;= limit; &#125; /** * 已经坐在椅子上的顾客 * * @return */ public int current() &#123; return n; &#125;&#125; 理发椅： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.chain.test.day07;/** * 理发椅 * * @author chain * */public class WorkChair extends Chair &#123; private Customer customer; public WorkChair(String name, int limit) &#123; super(name, limit); &#125; @Override public synchronized void sit(Customer customer) throws InterruptedException &#123; // 避免直接使用ConcurrentHashMap.size() while (n &gt;= limit) wait(); this.customer = customer; ++n; notify(); &#125; @Override public synchronized void leave(Customer customer) throws InterruptedException &#123; while (n &lt;= 0) wait(); this.customer = null; --n; notify(); &#125; /** * 获得椅子上的顾客 * * @return */ public Customer get() &#123; return customer; &#125; /** * 顾客离开椅子 * * @throws InterruptedException */ public synchronized void leave() throws InterruptedException &#123; leave(null); &#125;&#125; 主测试方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206package com.chain.test.day07;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.Semaphore;import org.junit.Test;/** * 主测试方法 * * @author chain * */public class Main &#123; private BarberThread barberThread; private CustomerThread[] customerThreads; private Semaphore door; private Chair waitChairs; private WorkChair workChair; private Barber barber; private Customer[] customers; private int customersNum; private CyclicBarrier barrier; private MonitorThread monitorThread; @Test public void test() throws Exception &#123; customersNum = (int) (Math.random() * 8) + 2; System.out.println("there is " + customersNum + " customers"); barrier = new CyclicBarrier(customersNum + 1); door = new Semaphore(1); workChair = new WorkChair("work-chair", 1); // 等待椅的数量小于顾客的数量 waitChairs = new Chair("wait-chair", customersNum / 2); System.out.println("there is " + customersNum / 2 + " wait-chairs"); barber = new Barber(workChair); customers = new Customer[customersNum]; for (int i = 0; i &lt; customersNum; i++) customers[i] = new Customer(i); barberThread = new BarberThread(); customerThreads = new CustomerThread[customersNum]; for (int i = 0; i &lt; customersNum; i++) customerThreads[i] = new CustomerThread(customers[i]); monitorThread = new MonitorThread(); barberThread.start(); for (int i = 0; i &lt; customersNum; i++) customerThreads[i].start(); monitorThread.start(); barberThread.join(); for (int i = 0; i &lt; customersNum; i++) customerThreads[i].join(); calcResult(); &#125; private void calcResult() &#123; System.out.println(); System.out.println("============= calc result ============="); long barberTimes = barber.getTimes(); long customersTimes = 0; for (int i = 0; i &lt; customersNum; i++) &#123; long ct = customers[i].getTimes(); customersTimes += ct; System.out.println(customers[i].getName() + " times：" + ct); &#125; System.out.println("barber times：" + barberTimes); System.out.println("customers total times：" + customersTimes); System.out.println("correct：" + (barberTimes == customersTimes)); &#125; private class MonitorThread extends Thread &#123; @SuppressWarnings("deprecation") @Override public void run() &#123; try &#123; // 持续运行10分钟 Thread.sleep(10 * 60 * 1000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; barberThread.close(); for (int i = 0; i &lt; customersNum; i++) customerThreads[i].close(); barberThread.interrupt(); for (int i = 0; i &lt; customersNum; i++) customerThreads[i].interrupt(); barberThread.stop(); for (int i = 0; i &lt; customersNum; i++) customerThreads[i].stop(); &#125; &#125; private class CustomerThread extends Thread &#123; private volatile boolean status; private Customer customer; public CustomerThread(Customer customer) &#123; this.customer = customer; &#125; @Override public void run() &#123; try &#123; status = true; barrier.await(); String name = customer.getName(); System.out.println(name + " is ready"); while (status) &#123; System.out.println(name + " try to enter this barbershop"); try &#123; if (!door.tryAcquire()) continue; customer.enter(); System.out.println(name + " has entered this barbershop"); try &#123; if (waitChairs.isFull()) &#123; System.out.println(name + " failed to sit for full"); customer.leave(); continue; &#125; waitChairs.sit(customer); System.out.println(name + " has sit on one wait-chair, current " + waitChairs.current()); &#125; finally &#123; door.release(); &#125; int max = (int) (Math.random() * 5) + 5; int wait = 0; while (wait++ &lt; max &amp;&amp; !customer.awake(waitChairs, barber)) customer.dosth(); // 此时等的不耐烦的顾客可能正要走时却成功叫醒了理发师 if (wait &gt;= max &amp;&amp; waitChairs.get(customer) != null) &#123; waitChairs.leave(customer); customer.leave(); System.out.println(name + " couldn't wait any more"); &#125; &#125; finally &#123; while (customer.isEntered()) customer.dosth(); System.out.println(name + " leave this barbershop"); customer.outdoor(); &#125; &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; public void close() &#123; this.status = false; &#125; &#125; private class BarberThread extends Thread &#123; private volatile boolean status; @Override public void run() &#123; try &#123; status = true; barrier.await(); System.out.println(barber.getName() + " is ready"); while (status) &#123; barber.sleep(); barber.work(); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; public void close() &#123; this.status = false; &#125; &#125;&#125; 程序持续运行较长时间后的某一个片段截图（忙碌的理发师，只能小憩一会）： 程序正常退出时的运行结果： 每个顾客理发的次数也是近似相等的。 原先的代码会导致运行一段时间后出现一个顾客都无法得到理发师理发机会的情况，排查了好久才发现原来的代码会出现一个极端情况，即顾客坐上理发椅后刚换醒理发师，理发师接着自己又睡过去了。从打印输出的结果也可以看出，在某一个时刻，顾客刚刚sit到work-chair，而后紧接着理发师sleep了，再之后就出现所有的顾客无法理发的情况。现在已经解决了这个问题，并重新更换了截图和相关代码。 总结思考将复杂问题分解，分解的过程中自己拿起笔，用文字和图片将抽象的问题形象化，具体化，清晰化。 多线程问题的锻炼也能提高自己在编码时思维的严谨，简单的步骤也需要打磨很久。 在多线程和并发下，各种意想不到的情况都会发生，需要平时的经验积累和深入思考。 源码]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程之吸烟者问题]]></title>
    <url>%2F2017%2F12%2F08-java-multithreads-smokers-learn%2F</url>
    <content type="text"><![CDATA[Java多线程之吸烟者问题吸烟者问题有点类似生产者消费者问题，但是生产者的生产的商品是多样的，商品不一样，对应的消费者也不一样。 操作系统原理之进程和线程管理Java的多线程和并发知识纲要Java多线程之生产者和消费者模式Java多线程之哲学家就餐问题Java多线程之读者写者问题 问题描述假设有三个抽烟者和一个供应者。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要同时具备三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有无限烟草、第二个拥有无限纸，第三个拥有无限胶水，抽烟者之间互不提供材料，各自缺失的另外两种材料仅由供应者提供。供应者能无限地提供这三种材料，但是供应者每次只会将其中的两种材料放在桌子上，并等待抽烟者的信号。此时拥有缺失的那种材料的抽烟者可以从桌子上拿走材料，卷上一根烟并抽掉它。抽烟者卷好烟后（不需要等到抽完）就会给供应者一个信号，告诉供应者可以了，供应者就会清理并随机再选两种材料放在桌上，这种过程一直重复。 问题分析供应者和吸烟者是同步关系，当供应者提供好材料时，吸烟者可以进行卷烟操作；吸烟者卷好烟后，供应者就可以重新放置材料。但是，供应者每次只能满足一个吸烟者，也就是说吸烟者之间的卷烟动作是互斥的。 这里的材料可以用信号量来表示，表示的方法可以有两种。 第一种：烟草、纸、胶水各自为单独信号量，每个吸烟者等待各自需要的两个材料（两个信号量）。第二种：烟草+纸，纸+胶水，胶水+烟草组合作为信号量，每个吸烟者等待各自需要的那个信号量。 我的解决无论是烟草、纸、胶水的单独信号量，还是烟草+纸，纸+胶水，胶水+烟草的组合信号量，其实本质上都是一样的。 公共类和方法供应者抽象类： 1234567891011121314151617package com.chain.test.day06;/** * 供应者抽象类 * * @author chain * */public abstract class AbstractSupplier &#123; /** * 供应者提供材料 * * @throws Exception */ public abstract void put() throws Exception;&#125; 吸烟者抽象类： 123456789101112131415161718package com.chain.test.day06;/** * 吸烟者抽象类 * * @author chain * */public abstract class AbstractSmoker &#123; /** * 吸烟者等待材料 * * @throws Exception */ public abstract void take() throws Exception;&#125; 材料的抽象类： 12345678910111213141516171819202122232425262728package com.chain.test.day06;import java.util.HashMap;import java.util.Map;/** * 材料的抽象类 * * @author chain * */public abstract class AbstractMaterials &#123; protected Map&lt;Integer, String&gt; list; public AbstractMaterials() &#123; list = new HashMap&lt;&gt;(); &#125; /** * 获取材料的名称 * * @param id * @return */ public abstract String get(int id);&#125; 主测试方法、吸烟者、提供者、材料以及信号量的具体实现参看文末的源码链接。 具体做法材料、吸烟者、提供者、信号量需要根据不同的情况一一对应。 烟草、纸、胶水的单独信号量提供者每次提供三种材料中的两个，比如烟草、纸。吸烟者等待自己需要的两种材料。 test.properties： 1234smoker.class=com.chain.test.day06.SmokerAsupplier.class=com.chain.test.day06.SupplierAsemaphore.class=com.chain.test.day06.SemaphoreAmaterial.class=com.chain.test.day06.MaterialsA 吸烟者：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.chain.test.day06;/** * 吸烟者 * * 烟草、纸、胶水的单独信号量 * * @author chain * */public class SmokerA extends AbstractSmoker &#123; private AbstractSemaphore[] takes; public SmokerA(int id, AbstractSemaphore[] semaphores, AbstractSemaphore finish, AbstractMaterials materials) &#123; super(id, semaphores, finish, materials); takes = semaphores; &#125; @Override public void take() throws Exception &#123; int mlen = takes.length; int notTake = getId(); StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; mlen; i++) &#123; if (i == notTake) continue; sb.append(materials.get(i) + " "); &#125; String msg = sb.toString(); // 等待供应者的材料 System.out.println(getName() + " wait for materials： " + msg); for (int i = 0; i &lt; mlen; i++) &#123; if (i == notTake) continue; takes[i].P(); &#125; System.out.println(getName() + " get materials： " + msg); // 告知供应者自己的到所需要的材料 finish.V(); System.out.println(getName() + " signal supplier"); process(); &#125; /** * 卷烟和吸烟 */ private void process() &#123; try &#123; Thread.sleep(100 * ((int) (Math.random() * 9 + 1))); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; System.out.println(getName() + " cigarette and smoke"); &#125;&#125; 提供者： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.chain.test.day06;import java.util.Random;/** * 供应者 * * 烟草、纸、胶水的单独信号量 * * @author chain * */public class SupplierA extends AbstractSupplier &#123; private Random random; public SupplierA(int id, AbstractSemaphore[] semaphores, AbstractSemaphore finish, AbstractMaterials materials) &#123; super(id, semaphores, finish, materials); this.random = new Random(); &#125; @Override public void put() throws Exception &#123; int mlen = semaphores.length; int notMake = Math.abs(random.nextInt()) % mlen; System.out.println(getName() + " make materials"); StringBuffer sb = new StringBuffer(); sb.append(getName() + " has put materials： "); for (int i = 0; i &lt; mlen; i++) &#123; if (i == notMake) continue; sb.append(materials.get(i) + " "); &#125; String msg = sb.toString(); process(); for (int i = 0; i &lt; mlen; i++) &#123; if (i == notMake) continue; semaphores[i].V(); &#125; System.out.println(msg); finish.P(); &#125; // 处理其他事情 private void process() &#123; try &#123; Thread.sleep(100 * ((int) (Math.random() * 9 + 1))); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 材料： 123456789101112131415161718192021222324252627282930313233package com.chain.test.day06;/** * 材料 * * 烟草、纸、胶水的单独信号量 * * @author chain * */public class MaterialsA extends AbstractMaterials &#123; public MaterialsA() &#123; // 编译器会自动添加 // super(); init(); &#125; private void init() &#123; // 烟草 list.put(0, "tobacco"); // 胶水 list.put(1, "gluewater"); // 纸 list.put(2, "paper"); &#125; @Override public String get(int id) &#123; return list.get(id); &#125;&#125; 烟草+纸，纸+胶水，胶水+烟草的组合信号量提供者每次提供三种材料组合中的任意一个，比如烟草+纸。吸烟者等待自己需要的材料组合。 test.properties： 1234semaphore.class=com.chain.test.day06.SemaphoreAsmoker.class=com.chain.test.day06.SmokerBsupplier.class=com.chain.test.day06.SupplierBmaterial.class=com.chain.test.day06.MaterialsB 供应者： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.chain.test.day06;import java.util.Random;/** * 供应者 * * 烟草+纸，纸+胶水，胶水+烟草的组合信号量 * * @author chain * */public class SupplierB extends AbstractSupplier &#123; private Random random; public SupplierB(int id, AbstractSemaphore[] semaphores, AbstractSemaphore finish, AbstractMaterials materials) &#123; super(id, semaphores, finish, materials); this.random = new Random(); &#125; @Override public void put() throws Exception &#123; int toMake = Math.abs(random.nextInt()) % semaphores.length; String material = materials.get(toMake); System.out.println(getName() + " make materials"); // 提供者放置材料 process(); semaphores[toMake].V(); System.out.println(getName() + " has put materials： " + material); // 等待吸烟者取走材料 finish.P(); &#125; // 处理其他事情 private void process() &#123; try &#123; Thread.sleep(100 * ((int) (Math.random() * 9 + 1))); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 吸烟者： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.chain.test.day06;/** * 吸烟者 * * 烟草+纸，纸+胶水，胶水+烟草的组合信号量 * * @author chain * */public class SmokerB extends AbstractSmoker &#123; private AbstractSemaphore take; public SmokerB(int id, AbstractSemaphore[] semaphores, AbstractSemaphore finish, AbstractMaterials materials) &#123; super(id, semaphores, finish, materials); take = semaphores[id]; &#125; @Override public void take() throws Exception &#123; String material = materials.get(getId()); System.out.println(getName() + " wait for material " + material); // 等待供应者的材料 take.P(); System.out.println(getName() + " get material " + material); // 告知供应者自己的到所需要的材料 finish.V(); System.out.println(getName() + " signal supplier"); process(); &#125; /** * 卷烟和吸烟 */ private void process() &#123; try &#123; Thread.sleep(100 * ((int) (Math.random() * 9 + 1))); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; System.out.println(getName() + " cigarette and smoke"); &#125;&#125; 材料： 123456789101112131415161718192021222324252627282930313233package com.chain.test.day06;/** * 材料 * * 烟草+纸，纸+胶水，胶水+烟草的组合信号量 * * @author chain * */public class MaterialsB extends AbstractMaterials &#123; public MaterialsB() &#123; // 编译器会自动添加 // super(); init(); &#125; private void init() &#123; // 烟草+纸 list.put(0, "tobacco+paper"); // 胶水+纸 list.put(1, "gluewater+paper"); // 烟草+胶水 list.put(2, "gluewater+tobacco"); &#125; @Override public String get(int id) &#123; return list.get(id); &#125;&#125; 第二种方式运行结果和第一种效果一致，但是第二种代码更简洁，运行速度也会快一点。 总结思考无论是烟草、纸、胶水的单独信号量，还是烟草+纸，纸+胶水，胶水+烟草的组合信号量，其实本质上都是一样的，差别就在于信号量具体的PV操作。但是使用组合方式，是这个问题比较好的解决方案。 吸烟者问题有点类似生产者消费者问题，但是生产出的商品是多样的，消费者也是多样的。 搞定经典问题，做到举一反三。 源码]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于UDP的可用于公网的多线程设计的多人聊天室]]></title>
    <url>%2F2017%2F12%2F05-udp-chat-room%2F</url>
    <content type="text"><![CDATA[基于UDP的可用于公网的多线程设计的多人聊天室一转眼大四上学期也快过去了，最近也在巩固多线程的基础知识。我的感觉是，多线程和并发编程既需要不断的去接触和思考，不断的去深入挖掘，也需要项目实战的经验积累。之前在学习Java基础时写过一个简单的单线程局域网的UDP聊天室，现在结合多线程知识，设计一个复杂一点的利用多线程的聊天室。在设计过程中，也更进一步学习了NAT和路由打洞的一些知识。 源码下载欢迎下载使用 使用时注意修改conf下的chatroom.properties，服务器端在命令行模式下运行，客户端可直接打开运行。 源码在这里 知识难点Java编程： 1、线程的唤醒和等待可以使用三种方式：1）Object自带的wait/notify2）JUC的Condition中的await/signal3）while循环中使用Thread.sleep和if判断 2、多线程中保证并发访问的三种方式：1）Java的关键字synchronized2）JUC的ReentrantLock3）CAS无锁算法 3、多线程并发访问下可使用的集合类：1）ConcurrentHashMap2）ConcurrentLinkedQueue3）LinkedBlockingQueue 4、多线程并发访问下的一个特殊关键字：volatile 5、生产者和消费者的模型 计算机网络与通信： 1、心跳机制的实现和意义2、路由的消息转发和寻路、NAT、打洞3、心跳机制和路由打洞的联系4、UDP通信和UDP编程 相关知识点这里就不解释了。 架构设计具体的UML类图和时序图、流程图就不画了，需要费很大功夫。 客户端：png 服务器：png 其中客户端和服务器都还有一个Register，所需的Service等都注册于其中，方便管理和控制。 客户端和服务器之间的通信所有的数据是存储在Msg中。发送数据时，Msg会转成Json字符串，进而转成byte数据；接受数据时，会将byte数据转成Json字符串，进而转成Msg对象。其中Msg存储的data数据可以是各种类型。 Msg中成员变量有： Msg.Type即消息类型总共有一下几种： 客户端和服务器的Service的handle方法会根据Msg具体的Type类型进行相应的处理。 测试截图阿里云公网服务器工作截图： 客户端截图（每个客户端都在不同的主机和不同的网路环境下）： 具体的测试环境：移动4G网，电信4G网，校园宽带网 客户端可以在同一台电脑上运行多个实例，另外即使电脑的网络环境发生变化（比如切换到不同的网络）也能做到不掉线。 这个聊天DEMO没有确保UDP消息一定能做到可靠，没有遗漏，只是为了学习多线程和计算机网络与通信。 总结感悟自己虽然是通信专业，但是在编程过程中才发现自己的理论的学习只是浮于表面，比如路由的转发，只是学到了一些文字上的IP的替换，路由的寻路方法。在这个知识背景下，开始的做法就是，当客户端发送消息给服务器时，服务器收到了消息，然后根据存储的客户端的IP和Port转发给客户端，却发现在跨网段情况下客户端并不能接收到数据包，局域网下是可以的。路由从内而外很容易，但是由外而内却不能直接访问。这就涉及到了打洞知识，而后也就能顺利的解决了问题，实现了公网下的聊天。心跳机制一方面是为了告诉服务器当前客户端是在线的，另一方面也是为了路由的打洞，及时的更新服务器中存储客户端NAT后的不断变化的IP和Port，便于服务器使用这个新的IP和Port和客户端进行通信。 自己在做一些小项目时，其中最大的感受就是（也是一种软件开发的模式），一定要先想好大致的框架和流程，画好草图，想好模块的大致和软件的分层，然后在具体的实施过程对每一个模块进行细致的设计，这样开发出的软件结构优美，秩序井然，且易于修改和增减功能。 当和实验室的伙伴一起测试可以在公网下进行聊天的服务器时，心里的那个激动，爽哈!]]></content>
      <categories>
        <category>案例</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
        <tag>案例</tag>
        <tag>计算机网络与通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程之读者写者问题]]></title>
    <url>%2F2017%2F11%2F25-java-multithreads-read-write-learn%2F</url>
    <content type="text"><![CDATA[Java多线程之读者写者问题读者写者问题也是经典的多线程问题，在实际生产应用中也是存在必要的意义的。 操作系统原理之进程和线程管理Java的多线程和并发知识纲要Java多线程之生产者和消费者模式Java多线程之哲学家就餐问题 问题描述有读者和写者两组并发进程，共享一个文件。当两个或以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。 因此要求：①允许多个读者可以同时对文件执行读操作；②只允许一个写者往文件中写信息；③任一写者在完成写操作之前不允许其他读者或写者工作；④写者执行写操作前，应让已有的读者和写者全部退出。 问题分析分析问题容易看出，读者和写者是互斥的，写者和写者也是互斥的，而读者和读者之间不存在互斥问题。 当读者和写者都存在时，就会出现优先级问题，到底是读的优先还是写的人优先。 因此，这个问题可以分为读者优先、弱写者优先（公平竞争）、强写者优先三种情况。 对每一种情况要具体问题具体分析，找出每种情况下的访问规则。 我的解决不论当前的状态如何，任意写者进程与其他任何进程都互斥，用互斥信号量的PV操作即可。读者的问题比较复杂，它必须实现与写者互斥的同时还要实现与其他读者的同步。 因此，仅仅简单的一对PV操作是无法解决的。这里可以使用一个计数器count，用它来判断当前是否有读者读文件。当有读者的时候写者是无法写文件的，此时读者会一直占用文件；当没有读者的时候写者才可以写文件。同时不同的读者对该计数器的访问也应该是互斥的。 这里我假设了以下的情景：写者进程针对share.txt不断进行写操作，读者进程则不断读取share.txt中的内容，并写到另一个文件中。从而实现文件的实时拷贝，可以用于的场景比如：写服务器不断的去记录log到同一个文件，然后其他服务器不断的去抓取这个log文件的内容拷贝到自己本地。 公共类和方法读者的抽象类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.chain.test.day05;import java.io.OutputStream;import java.io.RandomAccessFile;/** * 读者抽象类 * * @author chain * */public abstract class AbstractReader &#123; protected volatile RandomAccessFile file; protected OutputStream os; private int id; private String name; public AbstractReader(int id, RandomAccessFile file, OutputStream os) &#123; this.id = id; this.name = "Reader-" + id; this.file = file; this.os = os; &#125; public int getId() &#123; return id; &#125; public String getName() &#123; return name; &#125; /** * 读文件 * * @throws Exception */ public abstract void read() throws Exception; /** * 停止读取 */ public abstract void stop(); /** * 开始读取 */ public abstract void begin(); /** * 是否已完成工作 * * @return */ public abstract boolean isFinished(); /** * 休息一会 * * @throws InterruptedException */ public void rest() throws InterruptedException &#123; System.out.println(getName() + " have a rest"); Thread.sleep(100 * ((int) (Math.random() * 9) + 0)); &#125;&#125; 写者的抽象类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.chain.test.day05;import java.io.RandomAccessFile;import java.util.Random;/** * 写者抽象类 * * @author chain * */public abstract class AbstractWriter &#123; protected volatile RandomAccessFile file; protected Random rand; private int id; private String name; public AbstractWriter(int id, RandomAccessFile file) &#123; this.id = id; this.name = "Writer-" + id; this.file = file; this.rand = new Random(); &#125; public int getId() &#123; return id; &#125; public String getName() &#123; return name; &#125; /** * 写文件 * * @throws Exception */ public abstract void write() throws Exception; /** * 停止读取 */ public abstract void stop(); /** * 开始读取 */ public abstract void begin(); /** * 是否已完成工作 * * @return */ public abstract boolean isFinished(); /** * 休息一会 * * @throws InterruptedException */ public void rest() throws InterruptedException &#123; System.out.println(getName() + " have a rest"); Thread.sleep(100 * ((int) (Math.random() * 9) + 0)); &#125;&#125; 读者写者规则的抽象类： 123456789101112131415161718192021222324252627package com.chain.test.day05;/** * 读者写者的规则的抽象类 * * @author chain * */public abstract class AbstractReaderWriterMethod &#123; /** * 读者读文件 * * @param reader * @throws Exception */ public abstract void read(AbstractReader reader) throws Exception; /** * 写者写文件 * * @param writer * @throws Exception */ public abstract void write(AbstractWriter writer) throws Exception;&#125; 主测试方法、Reader、Writer、读写规则、自定义信号量等的具体实现可以参看文末的源码链接。 读者优先test.properties： 12345readers.num=5writers.num=5method.class=com.chain.test.day05.ReaderWriterMethod01file.path=C:\\Temps\\reader_writerfile.name=share.txt 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.chain.test.day05;/** * 读者优先算法 * * 自定义信号量做法 * * @author chain * */public class ReaderWriterMethod01 extends AbstractReaderWriterMethod &#123; // 用于记录当前读者进程在读的数量 private volatile int count; // 保证count的互斥操作 private AbstractSemaphore mutex; // 用于保证读者和写者能互斥的访问文件 private AbstractSemaphore rw; public ReaderWriterMethod01() &#123; rw = new Semaphore01(1); mutex = new Semaphore01(1); &#125; @Override public void read(AbstractReader reader) throws Exception &#123; System.out.println(reader.getName() + " wait for reading"); // 读者进程互斥访问count mutex.P(); if (count == 0) // 阻止写者进程写 rw.P(); // 在执行读操作的读者进程+1 ++count; mutex.V(); reader.read(); mutex.P(); --count; if (count == 0) // 允许写者进程写 rw.V(); mutex.V(); System.out.println(reader.getName() + " finish reading"); reader.rest(); &#125; @Override public void write(AbstractWriter writer) throws Exception &#123; System.out.println(writer.getName() + " wait for writing"); // 阻止读者进程读 rw.P(); writer.write(); // 允许读者进程读 rw.V(); System.out.println(writer.getName() + " finish writing"); writer.rest(); &#125;&#125; 在该算法中，读者进程是优先的，也就是说，当存在读者进程时，写者操作将被推后。而且只要有一个读者进程活跃（在读文件），随后而来的读者进程也是允许读取文件的。这样的方式下，可能会导致写者进程长时间等待，即存在写者进程“饿死”的情况。 如果读者和写者的数量都为1时，可以看到两者交替进行，比较融洽： 如果读者数量为1，写者数量为多个（2个），可以看到写者不会同时写，读者和写者也是互斥的，工作也是正常的： 如果读者数量较少（2个），写者数量适中，可以看到大部分都是读者进程在执行，但是写者进程还是有机会进行写操作的： 但是如果读者数量较多（5个），可以看到写者进程进行写操作的机会很少，基本是读者进程在进行读操作： 程序正常结束运行后检查各个文件的信息，可以看到信息一致。 修改方法中的信号量为JavaAPI信号量也是可以的，运行效果一致。 （强）写者优先要让写者能优先得到执行的机会，可以参照读者优先中read如何让读者优先的部分，对照设计写者write部分。 具体做法：为了能做到写者优先，需要对读者部分增加一个队列信号量q，由写者进程控制这个队列信号量q。每当有一个写进程在执行写操作时，队列就+1；直到队列为0，读进程才能进行读操作。换句话说，只要有一个写进程得到了队列信号量q，那么之后就会一直占着q不放，直到所有的写进程都完成了写操作后才会释放q，这样的做法就能提高了写进程的优先级。 12345readers.num=5writers.num=5method.class=com.chain.test.day05.ReaderWriterMethod04file.path=C:\\Temps\\reader_writerfile.name=share.txt 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.chain.test.day05;/** * 写者优先 * * 自定义信号量做法 * * @author chain * */public class ReaderWriterMethod04 extends AbstractReaderWriterMethod &#123; // 用于记录当前读者进程在读的数量 private volatile int readCount; // 保证readCount的互斥操作 private AbstractSemaphore readMutex; // 用于记录当前写者进程在写的数量 private volatile int writeCount; // 保证writeCount的互斥操作 private AbstractSemaphore writeMutex; // 用于保证读者和写者能互斥的访问文件 private AbstractSemaphore w; private AbstractSemaphore q; public ReaderWriterMethod04() &#123; w = new Semaphore01(1); q = new Semaphore01(1); writeMutex = new Semaphore01(1); readMutex = new Semaphore01(1); &#125; @Override public void read(AbstractReader reader) throws Exception &#123; System.out.println(reader.getName() + " wait for reading"); // 只有当没有写进程在执行时，才能进行读操作 q.P(); readMutex.P(); if (readCount == 0) w.P(); ++readCount; readMutex.V(); q.V(); reader.read(); readMutex.P(); --readCount; if (readCount == 0) w.V(); readMutex.V(); System.out.println(reader.getName() + " finish reading"); reader.rest(); &#125; @Override public void write(AbstractWriter writer) throws Exception &#123; System.out.println(writer.getName() + " wait for writing"); writeMutex.P(); if (writeCount == 0) q.P(); ++writeCount; writeMutex.V(); w.P(); writer.write(); w.V(); writeMutex.P(); --writeCount; if (writeCount == 0) // 没有要写操作的写者，读者可以读文件 q.V(); writeMutex.V(); System.out.println(writer.getName() + " finish writing"); writer.rest(); &#125;&#125; 在该算法中，写者进程是优先的，也就是说，当存在写者进程时，读者操作将被推后。写操作之间通过w信号量保证互斥，读和写进程通过w信号量保持互斥，写进程通过q信号量控制写进程。这样的方式下，可能会导致读者进程长时间等待，即存在读者进程“饿死”的情况。 如果读者和写者的数量都为1时，可以看到两者交替进行，比较融洽： 如果读者和写者的数量都为2时，可以看到大部分都是写者进程在执行，但是读者进程还是有机会进行读操作的： 但是如果写者数量较多（3个），可以看到读者进程很少有机会进行读操作，基本是写者进程在进行写操作： 程序正常结束运行后检查各个文件的信息，可以看到信息一致。 由于这是强写者优先，所以都为3的情况下，读进程读完所有的内容时间所需太长（读进程获得执行的机会太少），不过可以修改Reader中一次buffer的大小，加快读取的速度。 读写公平（弱写者优先）如果希望读写公平，即在多次操作下，读写操作的执行频率是差不多的。 具体的做法：在读者优先的基础上只增加一个信号量q就可以做到读写公平。 test.properties： 12345readers.num=10writers.num=10method.class=com.chain.test.day05.ReaderWriterMethod05file.path=C:\\Temps\\reader_writerfile.name=share.txt 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.chain.test.day05;/** * 公平算法，在读者优先的基础上 * * 使用自定义信号量实现 * * @author chain * */public class ReaderWriterMethod05 extends AbstractReaderWriterMethod &#123; // 用于记录当前读者进程在读的数量 private volatile int count; // 保证count的互斥操作 private AbstractSemaphore mutex; // 用于保证读者和写者能互斥的访问文件 private AbstractSemaphore w; // 用于保证只有在写进程不需要写文件时读进程才去读文件 private AbstractSemaphore q; public ReaderWriterMethod05() &#123; q = new Semaphore01(1); w = new Semaphore01(1); mutex = new Semaphore01(1); &#125; @Override public void read(AbstractReader reader) throws Exception &#123; System.out.println(reader.getName() + " wait for writer to have a rest"); // 只有在写进程不需要写文件时读进程才去读文件 q.P(); System.out.println(reader.getName() + " wait for reading"); mutex.P(); if (count == 0) w.P(); ++count; mutex.V(); // 写进程可以尝试去写文件 // 但是写进程仍然需要去判断rw q.V(); reader.read(); mutex.P(); --count; if (count == 0) w.V(); mutex.V(); System.out.println(reader.getName() + " finish reading"); reader.rest(); &#125; @Override public void write(AbstractWriter writer) throws Exception &#123; System.out.println(writer.getName() + " wait for reader to have a rest"); // 写进程在读进程无需读取时进入 q.P(); System.out.println(writer.getName() + " wait for writing"); w.P(); writer.write(); // 读进程可以进行读操作 q.V(); w.V(); System.out.println(writer.getName() + " finish writing"); writer.rest(); &#125;&#125; 这样修改后，即使有再多的读写进程，两种操作的频率是差不多的： 程序正常结束运行后检查各个文件的信息，可以看到信息一致： 总结思考为了做到读者之间互斥，可以给读者的读操作增加一个信号量w。为了做到读者和写者之间的互斥，可以使用上面的信号量w。 为了做到读者优先，可以个读者操作增加一个计数器read_count，只要有一个读者能得到执行，就会阻止写者进行操作，从而其他的读者也能执行。直到没有读者去进行读操作时，写者才有机会去执行。 为了做到读写公平，可以在读者优先的基础上，给读者增加一个信号量q，这个信号量由写者控制。如果写者想执行操作，可以阻塞q，使得读者不能进行read_count操作，进而也就不能进行读操作。这种情况也被称为弱写者优先。 为了做到写者优先，可以在读者优先的基础上，给写者也配备一个计数器write_count，读者增加一个信号量q，这个信号量由写者控制。如果写者想执行操作，和弱写者优先一样，阻塞q即可。但是不同的是，一旦写者获得执行权，写者的计数器write_count的作用和read_count一样，会保证其他的写者也能得到执行。直到没有写者去进行写操作时，读者才有机会去执行。这种情况也被称为强写者优先。 源码]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程之哲学家就餐问题]]></title>
    <url>%2F2017%2F11%2F20-java-multithreads-philosopher-dinner-learn%2F</url>
    <content type="text"><![CDATA[Java多线程之哲学家就餐问题哲学家就餐问题是在计算机科学中的一个经典问题，常常被用来面试。这个问题显示了多线程同步(Synchronization)时产生的问题。 在1971年，由著名的计算机科学家艾兹格•迪科斯彻提出，即假设有五台计算机都试图访问五份共享的磁带驱动器。不久，为了便于理解和生动化，这个问题又被托尼•霍尔重新表述为哲学家就餐问题。该问题可以用来解释死锁和资源竞争。 操作系统原理之进程和线程管理Java的多线程和并发知识纲要Java多线程之生产者和消费者模式 问题描述一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭，如下图所示。哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响他人。每个哲学家思考的时间是固定的，不是永久都在思考。只有当哲学家饥饿的时候，才试图拿起左、 右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。这个等待可能是一直等待，也有可能是等待一会就放弃（同时放下手中已有的筷子）。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐。同样，每个哲学家吃饭的时间是固定的，不是一直都在吃饭。当进餐完毕后，放下筷子继续思考。 问题分析5名哲学家与左右邻居对其中间筷子的访问是互斥关系，可以把哲学家比作五个进程。问题的关键是如何让一个哲学家能吃到饭而不造成死锁或者饥饿现象。 每一个哲学家的状态可以分为：思考（无需筷子）、饥饿（需要筷子）、吃饭（占有两个筷子）。 如果不设计好哲学家的吃饭规则，那么会导致死锁和饥饿。假设五个哲学家按顺序分别是A，B，C，D，E。 死锁的例子：大家都同时拿起左边的筷子，然后等待右边的筷子。即A拿到了筷子2，然后等待筷子1；E拿到了1，再等待5；D拿到了5，再等待4；C拿到了4，再等待3；B拿到了3，再等待2；而A一直不放下筷子2。那么就形成了死锁。 饥饿的例子：基于死锁的例子，不同的是，大家先检查右边的筷子是否可以拿，发现可以，然后都同时拿起左边的筷子，接着又同时去拿右边的筷子，但是发现右边拿不到（相对的），就同时放下了左手的筷子，放下筷子后又发现自己右边的筷子可以拿了，就又同时拿起了左边的筷子。循环往复，那么就形成了饥饿。 在这个问题中，不难发现，最多只有两个哲学家能同时就餐，而正确的情况是每个哲学家都能吃到饭。 我的解决解决这个问题需要设计正确的吃饭规则，不能想吃就吃。 比如：1）同时只允许一位哲学家就餐。2）对哲学家顺序编号，要求奇数号哲学家先抓左边的叉子，然后再抓他右边的叉子；而偶数号哲学家刚好相反，先抓右边的叉子，然后再抓他左边的叉子。3）当且仅当某一个哲学家他的左右两边的叉子都可用时，才允许抓起叉子。 做法一可行但是效率低，本来可以最多两个哲学家吃饭，现在只能是一个。做法二可行，不过需要对哲学家分类，也就是进程分类，操作比较麻烦，需要制定两套方案。做法三也是可行的，同时也是不错的解决方法，每个哲学家都是平等的。 PV操作模型可以直观的表示这些方法，不过落实到具体的代码上就不是模型表现的那么简单了，好在JavaAPI已经提供了相关的类或方法可以直接使用。 公共类和方法抽象的筷子类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.chain.test.day04;/** * 筷子的抽象类 * * 临界资源，只能同时被一个哲学家使用（抓起） * * @author chain * */public abstract class AbstractChopstick &#123; // 筷子序号 protected int id; public AbstractChopstick(int id) &#123; this.id = id; &#125; /** * 获得筷子序号 * * @return */ public int getId() &#123; return id; &#125; /** * 获得筷子名字 * * @return */ public String getName() &#123; return "Chopstick-" + getId(); &#125; /** * 筷子是否被使用 * * @return */ public abstract boolean isUse(); /** * 使用（抓起）筷子 * * @throws Exception */ public abstract void use() throws Exception; /** * 放下筷子 */ public abstract void drop();&#125; 哲学家抽象类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.chain.test.day04;/** * 哲学家抽象类 * * @author chain * */public abstract class AbstractPhilosopher &#123; // 哲学家序号 protected int id; public AbstractPhilosopher(int id) &#123; this.id = id; &#125; /** * 获得哲学家的序号 * * @return */ public int getId() &#123; return id; &#125; /** * 获得哲学家的名字 * * @return */ public String getName() &#123; return "Philosopher-" + getId(); &#125; /** * 思考 * * @throws Exception */ public abstract void think() throws Exception; /** * 抓筷子 * * @throws Exception */ public abstract void take(AbstractChopstick chopstick) throws Exception; /** * 放筷子 */ public abstract void put(AbstractChopstick chopstick); /** * 就餐 * * @throws Exception */ public abstract void eat() throws Exception;&#125; 哲学家就餐的方法的抽象类： 12345678910111213141516171819package com.chain.test.day04;/** * 哲学家抓放筷子的方法的抽象类 * * @author chain * */public abstract class AbstractPhilosopherMethod &#123; /** * 哲学家 * * 吃饭在前，思考在后 * * @throws Exception */ public abstract void method(Philosopher p, AbstractChopstick[] cs) throws Exception;&#125; 测试方法、Philosopher、Chopstick的具体实现可以文章底部源码连接中可以查阅到。 对于Chopstick这个临界资源，实现PV操作的方式有多种。 先拿起左叉子，再拿起右叉子test.properties： 123chopstick.class=com.chain.test.day04.Chopstick01philosopher.class=com.chain.test.day04.Philosopherphilosopher.method.class=com.chain.test.day04.PhilosopherMethod01 123456789101112131415161718192021222324252627package com.chain.test.day04;/** * 每个哲学家先拿起左叉子，再拿起右叉子 * * @author chain * */public class PhilosopherMethod01 extends AbstractPhilosopherMethod &#123; @Override public void method(Philosopher p, AbstractChopstick[] cs) throws Exception &#123; int left = p.getId(); int right = (left + 1) % cs.length; p.take(cs[left]); p.take(cs[right]); p.eat(); p.put(cs[left]); p.put(cs[right]); p.think(); &#125;&#125; 这个方法绝大多数情况下是能正常工作的，但是也是存在问题的，比如如果每个哲学家同时拿起左叉子，都在等待右叉子时就会造成死锁。当然也不是不能打破这个死锁，可以设置等待超时时间。这样这个方案虽然不能避免死锁，但是能打破死锁。 死锁发生时的情况： 同时只允许一位哲学家就餐同时只允许一位哲学家就餐，换句话说就是某一个哲学家取筷子的时候，把所有的筷子都霸占，使得其他哲学家都不能碰筷子。把所有的筷子作为一个整体是一个临界资源。 test.properties： 123chopstick.class=com.chain.test.day04.Chopstick01philosopher.class=com.chain.test.day04.Philosopherphilosopher.method.class=com.chain.test.day04.PhilosopherMethod02 1234567891011121314151617181920212223242526272829package com.chain.test.day04;/** * 同时只允许一位哲学家就餐 * * @author chain * */public class PhilosopherMethod02 extends AbstractPhilosopherMethod &#123; @Override public void method(Philosopher p, AbstractChopstick[] cs) throws Exception &#123; int left = p.getId(); int right = (left + 1) % cs.length; synchronized (cs) &#123; p.take(cs[left]); p.take(cs[right]); &#125; p.eat(); p.put(cs[left]); p.put(cs[right]); p.think(); &#125;&#125; 这样做，会造成效率降低。从运行结果中可以看到运行速度降低，并且每次确实只有一个哲学家在抓筷子。 哲学家分成奇偶死锁之所以会发生主要是在P操作，释放筷子的V操作不会发生阻塞。 test.properties： 123chopstick.class=com.chain.test.day04.Chopstick01philosopher.class=com.chain.test.day04.Philosopherphilosopher.method.class=com.chain.test.day04.PhilosopherMethod03 123456789101112131415161718192021222324252627282930313233package com.chain.test.day04;/** * 哲学家分成奇偶 * * @author chain * */public class PhilosopherMethod03 extends AbstractPhilosopherMethod &#123; @Override public void method(Philosopher p, AbstractChopstick[] cs) throws Exception &#123; int id = p.getId(); int left = id; int right = (left + 1) % cs.length; if ((id &amp; 1) == 1) &#123; p.take(cs[left]); p.take(cs[right]); &#125; else &#123; p.take(cs[right]); p.take(cs[left]); &#125; p.eat(); p.put(cs[left]); p.put(cs[right]); p.think(); &#125;&#125; 这样的解决可行，不过不算很通用。 当且仅当两个筷子都可以要么不拿，要么就拿两把筷子。 哲学家此时就有三种状态：思考状态（不用筷子）、饥饿状态（等待左右筷子）、就餐状态（使用筷子）。 此时的操作就是对哲学家的状态的操作，哲学家的“状态”成为临界资源，而筷子就能合理分配，不需要再做互斥处理，可以简化设计。 当某个哲学家在饥饿状态时，他需要筷子吃饭，如果此时他的两边哲学家都不在就餐状态时，他就可以顺利的拿到左右手的筷子吃到饭，并进入就餐状态。当某个哲学家在饥饿状态时，两边只要有一个在就餐，那么他就不可以拿到左右手的筷子，也就吃不到饭，一直保持饥饿状态（或者等待一会后放弃继续进入思考状态）。当某个哲学家吃完饭后，放下筷子后通知两边的哲学家，接着进入思考状态。 test.properties： 123chopstick.class=com.chain.test.day04.Chopstick01philosopher.class=com.chain.test.day04.Philosopherphilosopher.method.class=com.chain.test.day04.PhilosopherMethod04 哲学家Status： 123public enum Status &#123; THINK, HUNGRY, EAT&#125; 使用Object的wait和notify实现对Status的PV操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.chain.test.day04;/** * 当且仅当两个筷子都可以 * * 使用wait和notify * * @author chain * */public class PhilosopherMethod04 extends AbstractPhilosopherMethod &#123; private volatile Status[] status; public PhilosopherMethod04() &#123; status = new Status[Main.PHILOSOPHER_NUM]; for (int i = 0; i &lt; status.length; i++) status[i] = Status.HUNGRY; &#125; @Override public void method(AbstractPhilosopher p, AbstractChopstick[] cs) throws Exception &#123; takes(p, cs); p.eat(); puts(p, cs); p.think(); &#125; /** * 放下手中的筷子，并通知其他所有的哲学家 * * @param p * @param cs */ private synchronized void puts(AbstractPhilosopher p, AbstractChopstick[] cs) &#123; int id = p.getId(); int right = (id + 1) % Main.PHILOSOPHER_NUM; p.put(cs[id]); p.put(cs[right]); status[p.getId()] = Status.THINK; this.notifyAll(); &#125; /** * 尝试同时抓起两边的筷子 * * @param p * @param cs * @throws Exception */ private synchronized void takes(AbstractPhilosopher p, AbstractChopstick[] cs) throws Exception &#123; int id = p.getId(); status[id] = Status.HUNGRY; trial(p, cs); while (status[id] != Status.EAT) &#123; this.wait(); trial(p, cs); &#125; &#125; private synchronized void trial(AbstractPhilosopher p, AbstractChopstick[] cs) throws Exception &#123; int id = p.getId(); int n = Main.PHILOSOPHER_NUM; int left = (id - 1 + n) % n; int right = (id + 1) % n; if (status[id] == Status.HUNGRY &amp;&amp; status[left] != Status.EAT &amp;&amp; status[right] != Status.EAT) &#123; p.take(cs[id]); p.take(cs[right]); status[id] = Status.EAT; this.notifyAll(); &#125; &#125;&#125; test.properties： 123chopstick.class=com.chain.test.day04.Chopstick01philosopher.class=com.chain.test.day04.Philosopherphilosopher.method.class=com.chain.test.day04.PhilosopherMethod05 使用ReentrantLock和Condition实现Status的PV操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.chain.test.day04;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;/** * 当且仅当两个筷子都可以 * * 使用ReentrantLock和Condition * * @author chain * */public class PhilosopherMethod05 extends AbstractPhilosopherMethod &#123; private ReentrantLock lock; private Condition[] cond; private volatile Status[] status; public PhilosopherMethod05() &#123; status = new Status[Main.PHILOSOPHER_NUM]; for (int i = 0; i &lt; status.length; i++) status[i] = Status.HUNGRY; lock = new ReentrantLock(); cond = new Condition[Main.PHILOSOPHER_NUM]; for (int i = 0; i &lt; cond.length; i++) cond[i] = lock.newCondition(); &#125; @Override public void method(AbstractPhilosopher p, AbstractChopstick[] cs) throws Exception &#123; takes(p, cs); p.eat(); puts(p, cs); p.think(); &#125; /** * 放下手中的筷子，并通知两边的哲学家 * * @param p * @param cs */ private void puts(AbstractPhilosopher p, AbstractChopstick[] cs) &#123; lock.lock(); try &#123; int id = p.getId(); int n = Main.PHILOSOPHER_NUM; int left = (id - 1 + n) % n; int right = (id + 1) % n; p.put(cs[id]); p.put(cs[right]); status[p.getId()] = Status.THINK; trial(left, cs); trial(right, cs); &#125; finally &#123; if (lock.isLocked()) lock.unlock(); &#125; &#125; /** * 尝试同时抓起两边的筷子 * * @param p * @param cs * @throws Exception */ private void takes(AbstractPhilosopher p, AbstractChopstick[] cs) throws Exception &#123; lock.lock(); try &#123; int id = p.getId(); status[id] = Status.HUNGRY; trial(id, cs); while (status[id] != Status.EAT) cond[id].await(); if (status[id] == Status.EAT) &#123; int right = (id + 1) % Main.PHILOSOPHER_NUM; p.take(cs[id]); p.take(cs[right]); &#125; &#125; finally &#123; if (lock.isLocked()) lock.unlock(); &#125; &#125; private void trial(int id, AbstractChopstick[] cs) &#123; int n = Main.PHILOSOPHER_NUM; int left = (id - 1 + n) % n; int right = (id + 1) % n; if (status[id] == Status.HUNGRY &amp;&amp; status[left] != Status.EAT &amp;&amp; status[right] != Status.EAT) &#123; status[id] = Status.EAT; cond[id].signal(); &#125; &#125;&#125; 在别的博客看到还有另外一种做法，将筷子和哲学家进行颠倒，哲学家成为临界资源，而由筷子去选择哲学家。 思考总结修改test.properties中的chopstick.class也是类似的效果，比如同时抓起左筷子并等待右筷子时会死锁。 正常的情况如下： 解决这个问题的一开始自然的想法就是，所有的哲学家先尝试去拿左边的筷子，如果拿到了就再去尝试拿右边的筷子，如果没有拿到左边的筷子，就一直处于饥饿状态，直到可以拿到左边的筷子。如果拿到了右边的筷子，哲学家就进入就餐状态，就餐状态执行一段时间后哲学家放下手中的两只筷子，并进入思考状态。放下筷子后两边的哲学家就可以得到他们需要的左手筷子或右手筷子。 这样的方法乍一看上去是没有问题的，但是如果所有的哲学家都同时成功的拿起了左边的筷子，然后去等待右边的筷子，而右边的筷子显然一直会被右边的哲学家抓在他的左手中。那么就会造成死锁。除非有哲学家主动放下左手中的筷子，这个死锁才可能解除。 解决这个问题的方法主要有三种。 第一种简单粗暴，就是只允许同时只有一个哲学家能去拿筷子，注意不是整个就餐，只要保证拿筷子的过程是独占的即可。这样的操作自然不会有死锁问题，缺陷就是原本最多可以有两个哲学家能同时并成功的拿到筷子，现在只能有一个。执行的效率会降低。 第二种比较有技巧性，就是将哲学家分成奇偶。奇数先尝试拿左再拿右，偶数先尝试拿右再拿左。这样仔细分析一下：如果奇数的哲学家先拿到了左手的筷子，然后去拿右手边的筷子，而与此同时偶数的哲学家（就在奇数的哲学家两旁），会先去尝试拿右边的筷子，左边的筷子只会在右边的筷子成功拿到后才会去尝试拿。对于奇数的哲学家来说，右手的筷子直接可以拿到，因为他旁边的哲学家（也是偶数哲学家）在尝试拿他的右手边的筷子，根本不会去管他左边的筷子。对于偶数的哲学家来说，他想先去拿右手边得筷子，但是发现右手边的筷子被他右边的哲学家已经握在了左手中，就会一直处于饥饿状态等待。当奇数的哲学家拿到筷子并饱餐一顿放下筷子后，偶数的哲学家也就能拿到一直渴望的右手边的筷子，拿到右手边的筷子后，由于奇数的哲学家刚刚吃完在思考并不会去碰筷子，偶数的哲学家也能顺利的拿到左手边的筷子开始就餐。这样循环下去，能正常执行。 第三种，对问题进行了升华。哲学家要么一次拿起面前的两双筷子开吃，要么就不拿。原本筷子是临界资源，这种方法将临界资源改为哲学家的“状态”（同时原本的筷子无需再进行独占设计）。哲学家的状态可以划分为三种：思考状态（无需筷子）、饥饿状态（需要筷子）、就餐状态（占有筷子）。具体分析一下：需要就餐，处在饥饿状态的哲学家会先看看他两边的哲学家的状态。如果两边的哲学家都沉浸在自己的思考中，即思考状态，并不需要筷子，那么这个哲学家可以拿起两边的筷子开始就餐，进入就餐状态。如果他两边只要有一个哲学家在就餐状态，那么也就意味着他面前的筷子是不足两只的，他就保持饥饿状态等待。就餐完毕的哲学家放下手中的筷子，在进入思考状态前“告知”一下旁边的两位哲学家，“我已经吃完，你们可以拿我刚放下的筷子了”，然后就立即进入思考状态。因为不会存在相邻两个哲学家都在就餐的情况，只会存在相邻两个哲学家都在思考或饥饿，所以获得通知的饥饿中的哲学家会再次尝试去判断他两边哲学家的状态，如果两边的哲学家都处于思考状态，那么这个哲学家可以拿起两边的筷子并进入就餐状态，如果仍然不行则继续等待。这种方法能保证最多两个哲学家同时就餐，最多三个哲学家同时在等待，不会都在等待状态，所以能正常执行。 经典问题搞懂，能做到举一反三。 源码]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java实现基于哈夫曼的压缩算法]]></title>
    <url>%2F2017%2F11%2F15-java-huffman-codec%2F</url>
    <content type="text"><![CDATA[Java实现基于哈夫曼的压缩/解压缩算法通信课信息论中介绍了哈夫曼编码，这里想着编程实现一下压缩和解压缩。 博主水平有限，有不正确的地方欢迎指正。 算法介绍David Huffman和他的压缩算法 —— Huffman Code，是一种通过字符出现频率，结合 Priority Queue 和二叉树来进行的一种压缩算法，这种二叉树又叫Huffman二叉树（一种带权重的树）。他又被称为最优二叉树，是一类带权路径长度最短的树。 压缩可以分为无损压缩和有损压缩。 有损压缩，指的是压缩之后就无法完整还原原始信息，但是压缩率可以很高，主要应用于视频、话音等数据的压缩，因为损失了一点信息，人是很难察觉的，或者说，也没必要那么清晰照样可以看可以听。 无损压缩，则用于文件等等必须完整还原信息的场合，ZIP自然就是一种无损压缩，在通信原理中介绍数据压缩的时候，往往是从信息论的角度出发，引出香农所定义的熵的概念。 哈夫曼编码是一种无损编码，可以完全正确的压缩和还原数据，就是运算速度比较慢。 算法介绍可以参看这篇博客。 哈夫曼树具有如下特性：1）对于同一组权值，所能得到的哈夫曼树不一定是唯一的。2）哈夫曼树的左右子树可以互换，因为这并不影响树的带权路径长度。3）带权值的节点都是叶子节点，不带权值的节点都是某棵子二叉树的根节点。4）权值越大的节点越靠近哈夫曼树的根节点，权值越小的节点越远离哈夫曼树的根节点。5）哈夫曼树中只有叶子节点和度为2的节点，没有度为1的节点。6）一棵有n个叶子节点的哈夫曼树共有2n-1个节点。7）每个字符编码不会成为另一个编码的前缀。 Huffman编码的过程大致如下：1、统计一个文件以各个字符出现的次数2、以各个字符出现的次数为权值建立哈夫曼树3、根据哈夫曼树计算出每个字符的哈夫曼编码（可以用从树根到该字符所在到叶子节点的路径来表示）4、将原文件的各个字符用编出的码字替换5、将各个字符出现的次数信息和新生成的数据结合存储，则为压缩过程。 Huffmana解码的过程大致如下：1、获得存储的压缩文件中的各个字符出现的次数信息2、根据各个字符出现的次数信息重新构建哈夫曼树3、对压缩数据依次进行检索，根据每次检索的位数据获得对应的哈夫曼码，进而获得对应的字符。4、将翻译出的字符连接起来，则为解压缩过程。 构树的过程大致有两种(来自百度)： 但是与这篇博客介绍的方法不同的是，本文实现的构树算法是采用(a)，而前者使用的是(b)。方法(a)编出的码字更加均匀一点。 原本需要1B空间存储的数据，比如字符’a’，需要一个字节来存储，可能对应的哈夫曼编码只是11，即只需要两个bit来存储，进而起到压缩效果。 算法源码源码可以从这里访问。 测试结果这里就只贴出测试的结果。 java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172orgin string: 11a11aa1aa1a111aaadecode string: 11a11aa1aa1a111aaaorigin-data-length: 144encode-data-length: 18encode-times: 8.0encode-percent: 0.13decode-data-length: 144orgin string: 11a11aa1aa1a111aaadecode string: 11a11aa1aa1a111aaaorigin-data-length: 144encode-data-length: 144encode times: 1.0encode percent: 1.0decode-data-length: 144orgin string: 我和他说你很好，他和我说你很好，他和你说我很好，我和你说他很好，你和我说他很好，你和他说我很好，你很好，我很好，她很好，他和我很好，你和我很好，你和他很好，他和我很好，他和你很好，我和你很好，我和他很好，你和他和他很好，我和他和他很好，他和你和你很好，他和我和他很好，很好很好很好很好很好很好很好很好很好很好很好，好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好decode string: 我和他说你很好，他和我说你很好，他和你说我很好，我和你说他很好，你和我说他很好，你和他说我很好，你很好，我很好，她很好，他和我很好，你和我很好，你和他很好，他和我很好，他和你很好，我和你很好，我和他很好，你和他和他很好，我和他和他很好，他和你和你很好，他和我和他很好，很好很好很好很好很好很好很好很好很好很好很好，好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好origin-data-length: 4896encode-data-length: 2241encode-times: 2.18encode-percent: 0.46decode-data-length: 4896orgin string: 我和他说你很好 ...decode string: 我和他说你很好 ...origin-data-length: 4896encode-data-length: 3184encode times: 1.54encode percent: 0.65decode-data-length: 4896C:\Temps\huffman_test\test.txtorgin string: 123abc123abc ...decode string: 123abc123abc ...origin-data-length: 10368encode-data-length: 3456encode-times: 3.0encode-percent: 0.33decode-data-length: 10368orgin string: 123abc123abc ...decode string: 123abc123abc ...origin-data-length: 10368encode-data-length: 3768encode times: 2.75encode percent: 0.36decode-data-length: 10368C:\Temps\huffman_test\数字.txtorigin-data-length: 5743272encode-data-length: 2421825encode-times: 2.37encode-percent: 0.42decode-data-length: 5743272origin-data-length: 5743272encode-data-length: 2422432encode times: 2.37encode percent: 0.42decode-data-length: 5743272C:\Temps\huffman_test\圣经.txtorigin-data-length: 35741304encode-data-length: 20348325encode-times: 1.76encode-percent: 0.57decode-data-length: 35741304origin-data-length: 35741304encode-data-length: 20352048encode times: 1.76encode percent: 0.57decode-data-length: 35741304C:\Temps\huffman_test\简爱.txtorigin-data-length: 8919976encode-data-length: 5176611encode-times: 1.72encode-percent: 0.58decode-data-length: 8919976origin-data-length: 8919976encode-data-length: 5180864encode times: 1.72encode percent: 0.58decode-data-length: 8919976C:\Temps\huffman_test\test.jpgorigin-data-length: 8535152encode-data-length: 8285268encode-times: 1.03encode-percent: 0.97decode-data-length: 8535152origin-data-length: 8535152encode-data-length: 8297584encode times: 1.03encode percent: 0.97decode-data-length: 8535152C:\Temps\huffman_test\test.bmporigin-data-length: 3026224encode-data-length: 467555encode-times: 6.47encode-percent: 0.15decode-data-length: 3026224origin-data-length: 3026224encode-data-length: 469120encode times: 6.45encode percent: 0.16decode-data-length: 3026224C:\Temps\huffman_test\test.mp4origin-data-length: 4956832encode-data-length: 4955436encode-times: 1.0encode-percent: 1.0decode-data-length: 4956832origin-data-length: 4956832encode-data-length: 4967752encode times: 1.0encode percent: 1.0decode-data-length: 4956832C:\Temps\huffman_test\test.exeorigin-data-length: 27959936encode-data-length: 20832169encode-times: 1.34encode-percent: 0.75decode-data-length: 27959936origin-data-length: 27959936encode-data-length: 20844488encode times: 1.34encode percent: 0.75decode-data-length: 27959936C:\Temps\huffman_test\test.ziporigin-data-length: 110320encode-data-length: 110023encode-times: 1.0encode-percent: 1.0decode-data-length: 110320origin-data-length: 110320encode-data-length: 122336encode times: 0.9encode percent: 1.11decode-data-length: 110320C:\Temps\huffman_test\test.pdforigin-data-length: 13177832encode-data-length: 13163269encode-times: 1.0encode-percent: 1.0decode-data-length: 13177832origin-data-length: 13177832encode-data-length: 13175584encode times: 1.0encode percent: 1.0decode-data-length: 13177832worst testorigin-data-length: 2048encode-data-length: 2048encode-times: 1.0encode-percent: 1.0decode-data-length: 2048 汇总如下（不严谨）： 文件类型 压缩比 纯数字(txt) 0.42 英文文学(txt) 0.58 图片(jpg) 0.97 图片(bmp) 0.16 视频(mp4) 1.0 程序(exe) 0.75 压缩文件(zip) 1.0 pdf 1.0 最糟糕的情况就是：文本中总共有256种字符，每种字符出现的频率（次数、概率）相同；或者在二进制文件中，每个字节的二进制都存在，即有256种情况，每种情况出现的概率相同。这样编出来的哈夫曼树也是一颗满二叉树，树的高度为9。 测试中的部分详细信息如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344第一个测试：orgin string: 11a11aa1aa1a111aaadecode string: 11a11aa1aa1a111aaaorigin-data-length: 144encode-data-length: 18encode-times: 8.0encode-percent: 0.13decode-data-length: 144detail: huffman-tree-height: 2huffman-statistics-table: 0, key: 49, times: 91, key: 97, times: 9origin-data-length: 144encode-data-length: 18encode-times: 8.0encode-percent: 0.13最糟糕的测试：worst testorigin-data-length: 2048encode-data-length: 2048encode-times: 1.0encode-percent: 1.0decode-data-length: 2048detail: huffman-tree-height: 9huffman-statistics-table: 0, key: 0, times: 11, key: 1, times: 12, key: 2, times: 13, key: 3, times: 1...n, key: n, times: 1...253, key: 253, times: 1254, key: 254, times: 1255, key: 255, times: 1origin-data-length: 2048encode-data-length: 2048encode-times: 1.0encode-percent: 1.0 补充说明计算一下哈夫曼编码的压缩性能。 假设在计算中忽略哈夫曼树的本身额外的存储（换句话说，只有原文件不仅体积大，而且包含的字符数量多时才可以忽略哈夫曼本身的存储消耗）。 用len表示原数据串长度，path(i)表示每i个字符的编码长度。那么根据原理可以知道，原数据串通过哈夫曼压缩后的长度为： hlen = sum(path(i)) ; 1 &lt;= i &lt;= len 这个式子虽然正确但是不直观，所以假设一种平均情况进行估算： 假如一个串长度为n，一共包含m个不同的字符，那么所构建成的哈夫曼树的总结点数为 2*m-1。 如果n很大，那么可以忽略树本身的保存所需要占用的空间。 如果假设此串中每个字符出现的次数都是相同的，那么也可以假设，它们所生成的哈夫曼树是完全二叉树。即每个叶子(字符)的深度为log(m)+1，则路径长度为log(m)。 log(m) 即为该串字符的平均路径长度，那么压缩后的串长为log(m)/8。 由上可以得出平均压缩比的公式为： n log(2 m - 1)/8/n = log(2 * m - 1)/8; 可见压缩比的大小主要与m有关，即不同的字符越少越好。 ASCII码的范围为0～255，共有256种不同字符，代入上式得： log(2*256-1) ＝ 6.23 … 向上取整为7(路径个数哪有小数)。进一步有： 7/8 = 0.875 = %87.5 所以哈夫曼编码的平均压缩比为 %87.5。 参考文章伯乐在线csdnwikipedia]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何搭建免费又好用的静态博客]]></title>
    <url>%2F2017%2F11%2F01-how-to-make-hexo-site%2F</url>
    <content type="text"><![CDATA[如何搭建免费又好用的静态博客最近有小学弟咨询如何搭建一个自己的博客，大家的学习热情都很高，这是好事。 博客主要有静态博客和动态博客两种。这里我主要介绍静态博客搭建的注意事项。 目前我采用的方法： Hexo + GitHub + Coding.net 历史方案介绍一下我自己的博客搭建历程： 1）使用WordPress搭建于阿里云学生版服务器2）使用Hexo搭建于阿里云学生版服务器3）使用本地虚拟机+GitHub+CDN4）使用本地虚拟机+GitHub+阿里云学生版服务器5）使用本地虚拟机+GitHub+Coding.net 搭建博客最好有一个自己的域名，我的域名是在阿里云上申请并备案的。 目前做法1）博客采用Hexo平台，是安装在本地VirtualBox虚拟机里，虚拟机的好处是不用担心任何安全问题，且即使自己更换操作系统或新的电脑，可以随时备份虚拟机存储文件vdi，而不用担心重新配置的问题。 Hexo的安装可以参阅官网。使用的主题Next可以参阅官网。 2）由Hexo生成静态网页后可以在本地虚拟机先进行预览，再修改。 3）通过Hexo的部署命令可以将生成的网站push到github和coding.net中。 4）github pages 和 coding pages 可以参阅这两篇博客： github pages。coding pages。 当然也有一些其他的更详细的教程。 补充说明1）github的静态网页在国内访问不是很稳定，因此采用coding来等效实现github pages的功能。而且两者都是免费的，coding的功能更完善。 2）github pages 可以通过添加CNAME文件来使得访问xxx.github.io时能跳转到自己的域名上；同样的，coding pages 也可以在设置中直接添加自己的域名，而且支持https。 3）阿里云服务器还是需要支付一定的费用的，不过我本人更倾向于使用阿里云服务器做一些项目开发和学习。 4）至于如何将自己的域名添加到搜索引擎，谷歌和必应的添加是很简单的，只要提交一下自己的域名即可。百度的提交比较麻烦，而且不一定能添加成功。 Hexo支持各种sitemap。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库范式的通俗解释]]></title>
    <url>%2F2017%2F10%2F28-paradigm-of-database%2F</url>
    <content type="text"><![CDATA[数据库范式的通俗解释数据库的设计范式是数据库设计所需要满足的规范，满足这些规范的数据库是简洁的、结构明晰的，同时，不会发生插入（insert）、删除（delete）和更新（update）操作异常。反之则是乱七八糟，不仅给基于数据库的业务编写制造麻烦，而且面目可憎，可能存储了大量不需要的冗余信息。 基础概念范式：英文名称是 Normal Form，它是英国人 E.F.Codd（关系数据库的老祖宗）在上个世纪70年代提出关系数据库模型后总结出来的，范式是关系数据库理论的基础，也是我们在设计数据库结构过程中所要遵循的规则和指导方法。 目前有迹可寻的共有8种范式，依次是：1NF，2NF，3NF，BCNF（巴斯-科德范式），4NF，5NF（完美范式，PJNF），DKNF，6NF。 通常所用到的只是前三个范式，即：第一范式（1NF），第二范式（2NF），第三范式（3NF）。 第一范式要求确保表中每列的原子性，也就是不可拆分；第二范式要求确保表中每列与主键相关，而不能只与主键的某部分相关（主要针对联合主键），主键列与非主键列遵循完全函数依赖关系，也就是完全依赖；第三范式确保主键列之间没有传递函数依赖关系，也就是消除传递依赖。 一个数据库设计如果符合第二范式，一定也符合第一范式。如果符合第三范式，一定也符合第二范式，以此类推。 各种范式呈递次规范，越高的范式数据库冗余越小。 各种名词： 1）实体：现实世界中客观存在并可以被区别的事物。比如“一个学生”、“一本书”、“一门课”等等。值得强调的是这里所说的“事物”不仅仅是看得见摸得着的“东西”，它也可以是虚拟的，比如说“老师与学校的关系”。 2）属性：教科书上解释为：“实体所具有的某一特性”，由此可见，属性一开始是个逻辑概念。比如说，“性别”是“人”的一个属性。在关系数据库中，属性又是个物理概念，属性可以看作是“表的一列”。 3）元组：表中的一行就是一个元组。 4）分量：元组的某个属性值。在一个关系数据库中，它是一个操作原子，即关系数据库在做任何操作的时候，属性是“不可分的”。否则就不是关系数据库了。 5）码：表中可以唯一确定一个元组的某个属性（或者属性组），如果这样的码有不止一个，那么大家都叫候选码，我们从候选码中挑一个出来做老大，它就叫主码。 6）全码：如果一个码包含了所有的属性，这个码就是全码。 7）主属性：一个属性只要在任何一个候选码中出现过，这个属性就是主属性。 8）非主属性：与上面相反，没有在任何候选码中出现过，这个属性就是非主属性。 9）外码：一个属性（或属性组），它不是码，但是它别的表的码，它就是外码。 10）候选码： 若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何真子集都不能再标识，则称该属性组为（超级码）候选码。 范式解释第一范式第一范式（1NF）：属性不可分 1NF是对属性的原子性约束，要求属性具有原子性，不可再分解。 name tel age Josh 13612345678 021－9876543 22 Wang 13988776655 010－1234567 21 很明显，tel这个属性还可以进行分解，分解成手机和座机这两个属性，不满足第一范式的数据库，不是关系数据库！所以，我们在任何关系数据库管理系统中，做不出这样的“表”来。 第二范式第二范式（2NF）：符合1NF，并且非主属性完全依赖于码。 2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性，更通俗说有主键ID。 如果这都不能理解，只能看看如下科学的解释了：一个候选码中的主属性也可能是好几个。如果一个主属性，它不能单独做为一个候选码，那么它也不能确定任何一个非主属性。 给一个反例：我们考虑一个小学的教务管理系统，学生上课指定一个老师，一本教材，一个教室，一个时间，大家都上课去吧，没有问题。那么数据库怎么设计？ 学生 课程 老师 老师职称 教材 教室 上课时间 小明 一年级语文（上） 大宝 副教授 《小学语文1》 101 14：30 一个学生上一门课，一定在特定某个教室。所以有（学生，课程）－&gt;教室一个学生上一门课，一定是特定某个老师教。所以有（学生，课程）－&gt;老师一个学生上一门课，他老师的职称可以确定。所以有（学生，课程）－&gt;老师职称一个学生上一门课，一定是特定某个教材。所以有（学生，课程）－&gt;教材一个学生上一门课，一定在特定时间。所以有（学生，课程）－&gt;上课时间 因此（学生，课程）是一个码。 然而，一个课程，一定指定了某个教材，一年级语文肯定用的是《小学语文1》，那么就有课程－&gt;教材。（学生，课程）是个码，课程却决定了教材，这就叫做不完全依赖，或者说部分依赖。 出现这样的情况，就不满足第二范式！ 有什么不好吗？你可以想想：1、校长要新增加一门课程叫“微积分”，教材是《大学数学》，怎么办？学生还没选课，而学生又是主属性，主属性不能空，课程怎么记录呢，教材记到哪呢？ 郁闷了吧？ (插入异常)2、下学期没学生学一年级语文（上）了，学一年级语文（下）去了，那么表中将不存在一年级语文（上），也就没了《小学语文1》。这时候，校长问：一年级语文（上）用的什么教材啊？郁闷了吧？(删除异常)3、校长说：一年级语文（上）换教材，换成《大学语文》。有10000个学生选了这么课，改动好大啊！改累死了，郁闷了吧？（修改异常） 那应该怎么解决呢？投影分解，将一个表分解成两个或若干个表 学生 课程 老师 老师职称 教室 上课时间 小明 一年级语文（上） 大宝 副教授 101 14：30 学生上课表 课程 教材 一年级语文（上） 《小学语文1》 第三范式第三范式（3NF）：符合2NF，并且，消除传递依赖。 3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。 没有数据冗余的数据库并不一定是最好的数据库，所以有没有冗余的设计，要综合来考虑。 上面的“学生上课表”符合2NF，可以这样验证：两个主属性单独使用，不用确定其它四个非主属性的任何一个。但是它有传递依赖！在“老师”和“老师职称”这里，一个老师一定能确定一个老师职称。 如果不消除这种传递依赖，有可能会出现：1、老师升级了，变教授了，要改数据库，表中有N条，改了N次。（修改异常）2、没人选这个老师的课了，老师的职称也没了记录。（删除异常）3、新来一个老师，还没分配教什么课，他的职称记到哪？（插入异常） 那应该怎么解决呢？和上面一样，投影分解成多个表： 学生 课程 老师 教室 上课时间 小明 一年级语文（上） 大宝 101 14：30 老师 老师职称 大宝 副教授 更多范式BCNF： BCNF：符合3NF，并且，主属性不依赖于主属性。若关系模式属于第二范式，且每个属性都不传递依赖于键码，则R属于BC范式。 通常，BC范式的条件有多种等价的表述：每个非平凡依赖的左边必须包含键码；每个决定因素必须包含键码。 BC范式既检查非主属性，又检查主属性。当只检查非主属性时，就成了第三范式。满足BC范式的关系都必然满足第三范式。还可以这么说：若一个关系达到了第三范式，并且它只有一个候选码，或者它的每个候选码都是单属性，则该关系自然达到BC范式。 一般，一个数据库设计符合3NF或BCNF就可以了。 第四范式： 要求把同一表内的多对多关系删除。 第五范式： 从最终结构重新建立原始结构。 补充说明第二范式（2NF）和第三范式（3NF）的概念很容易混淆，区分它们的关键点在于：2NF：非主键列是完全依赖于主键，还是依赖于主键的一部分。3NF：非主键列是直接依赖于主键，还是直接依赖于非主键列。 另外，没有冗余的数据库设计是可以做到的。但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。 换句话说，应用的范式登记越高，则表越多。 表多会带来很多问题：1）查询时要连接多个表，增加了查询的复杂度。2）查询时需要连接多个表，降低了数据库查询性能。 现在磁盘空间成本基本可以忽略不计，所以数据冗余所造成的问题也不是首先要考虑的。 因此，并不是应用的范式越高越好，要看实际情况而定。第三范式已经很大程度上减少了数据冗余，并且减少了造成插入异常，更新异常，和删除异常了。我个人观点认为，大多数情况应用到第三范式已经足够，在一定情况下第二范式也是可以的。 最典型的就是在一些数据表中不仅存作为外键的user_id,同样存user_name,这样虽然违反数据库范式增加了user_name字段，但是却提高了效率，减少了获取user_id后再去user表中获取\user_name的操作。 实际中，我们只需要考虑数据库满足第三范式就可以了。 参考文章1234]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>学习</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题]]></title>
    <url>%2F2017%2F10%2F21-java-8-queen%2F</url>
    <content type="text"><![CDATA[N皇后问题（常见解法 Java实现）N皇后问题也是算法题中的经典题目，也有很多种不同的解法。这里就实现并总结一下常见的解法。 背景简介N皇后问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出： 在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 主要是回溯思想的体现。 下面将介绍常见的N皇后四种做法，当然还有很多其他的做法。 递归求解N皇后问题，在递归解法下，第一种自然的做法是采用二维数组来表示棋盘。 二维数组表示棋盘还是比较直观好理解的。 贴上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.chain.algorithm.test.day02;import java.time.Duration;import java.time.Instant;import java.util.ArrayList;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;/** * 八皇后问题的递归解法-二维数组 * * @author Chain * */public class NQueen01 &#123; // 总共有多少种解法 private int count; // 二维数组表示棋盘 private boolean[][] chess; // 皇后的数量 private int N; // 记录具体的结果 private List&lt;int[]&gt; result; private NQueen01() &#123; this(8); &#125; private NQueen01(int n) &#123; this.N = n; &#125; private NQueen01(int n, boolean save) &#123; this(n); if (save) result = new ArrayList&lt;&gt;(); &#125; public static Map&lt;String, Object&gt; calc(int n) &#123; return calc(n, false); &#125; public static Map&lt;String, Object&gt; calc(int n, boolean save) &#123; NQueen01 nq = new NQueen01(n, save); nq.chess = new boolean[n][n]; Instant start = Instant.now(); nq.put(0); Instant end = Instant.now(); Map&lt;String, Object&gt; res = new HashMap&lt;&gt;(); res.put("count", nq.count); res.put("time", Duration.between(start, end).toMillis()); res.put("result", nq.result); return res; &#125; private void put(int row) &#123; if (row == N) &#123; add(); return; &#125; for (int i = 0; i &lt; N; i++) if (check(row, i)) &#123; chess[row][i] = true; put(row + 1); reset(row); &#125; &#125; private void reset(int row) &#123; Arrays.fill(chess[row], false); &#125; private boolean check(int row, int pos) &#123; // 倒过来，从下而上 for (int i = row - 1; i &gt; -1; i--) &#123; // 垂直方向 if (chess[i][pos]) return false; // 反斜线方向（左斜） if (pos - row + i &gt; -1 &amp;&amp; chess[i][pos - row + i]) return false; // 正斜线方向（右斜） if (pos + row - i &lt; N &amp;&amp; chess[i][pos + row - i]) return false; &#125; return true; &#125; private void add() &#123; count++; if (result == null) return; int[] r = new int[N]; for (int i = 0; i &lt; N; i++) for (int j = 0; j &lt; N; j++) if (chess[i][j]) r[i] = j + 1; result.add(r); &#125;&#125; 递归方法-二维数组方法的测试结果： 12345678910111213141516queen: 4count: 2time: 0result: 1: 2 4 1 3 2: 3 1 4 2 queen: 8count: 92time: 2result: nullqueen: 16count: 14772512time: 734411result: null 分析代码可知，二维数组的情况下，在比较时的操作次数是非常惊人的，下面尝试使用一维数组来进行改进。 第二种做法，将二维数组改成一维数组。既降低了时间复杂度，也压缩了空间复杂度。 一维数组下标表示棋盘的行数，值表示该行的皇后放置的位置。 贴上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.chain.algorithm.test.day02;import java.time.Duration;import java.time.Instant;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;/** * 八皇后问题的递归解法-一维数组 * * @author Chain * */public class NQueen02 &#123; // 总共有多少种解法 private int count; // 一维数组表示棋盘（存储皇后放置的位置） private int[] chess; // 皇后的数量 private int N; // 记录具体的结果 private List&lt;int[]&gt; result; private NQueen02() &#123; this(8); &#125; private NQueen02(int n) &#123; this.N = n; &#125; private NQueen02(int n, boolean save) &#123; this(n); if (save) result = new ArrayList&lt;&gt;(); &#125; public static Map&lt;String, Object&gt; calc(int n) &#123; return calc(n, false); &#125; public static Map&lt;String, Object&gt; calc(int n, boolean save) &#123; NQueen02 nq = new NQueen02(n, save); nq.chess = new int[n]; Instant start = Instant.now(); nq.put(0); Instant end = Instant.now(); Map&lt;String, Object&gt; res = new HashMap&lt;&gt;(); res.put("count", nq.count); res.put("time", Duration.between(start, end).toMillis()); res.put("result", nq.result); return res; &#125; private void put(int row) &#123; if (row == N) &#123; add(); return; &#125; for (int i = 0; i &lt; N; i++) if (check(row, i)) &#123; chess[row] = i; put(row + 1); &#125; &#125; private boolean check(int row, int pos) &#123; /// 倒过来 for (int i = row - 1; i &gt; -1; i--) &#123; // 垂直 if (chess[i] == pos) return false; // 斜线 if (Math.abs(row - i) == Math.abs(pos - chess[i])) return false; &#125; return true; &#125; private void add() &#123; count++; if (result == null) return; int[] r = new int[N]; for (int i = 0; i &lt; N; i++) r[i] = chess[i] + 1; result.add(r); &#125;&#125; 递归方法-一维数组方法的测试结果： 12345678910111213141516queen: 4count: 2time: 0result: 1: 2 4 1 3 2: 3 1 4 2 queen: 8count: 92time: 0result: nullqueen: 16count: 14772512time: 388009result: null 由此可见，在递归方法下使用一维数组的话效率提升近一倍。 当然还有一种改进，就是用手动栈来代替系统栈，不过就单从效率上比较的话，和使用系统递归的做法相比不明显，不如直接使用循环。 循环求解这里使用一维数组来记录值，将递归改造成循环。效率和递归相比，没有多少变化。 贴上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.chain.algorithm.test.day02;import java.time.Duration;import java.time.Instant;import java.util.ArrayList;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;/** * 八皇后问题的循环解法-一维数组 * * @author Chain * */public class NQueen03 &#123; // 总共有多少种解法 private int count; // 一维数组表示棋盘（存储皇后放置的位置） private int[] chess; // 皇后的数量 private int N; // 记录具体的结果 private List&lt;int[]&gt; result; private NQueen03() &#123; this(8); &#125; private NQueen03(int n) &#123; this.N = n; &#125; private NQueen03(int n, boolean save) &#123; this(n); if (save) result = new ArrayList&lt;&gt;(); &#125; public static Map&lt;String, Object&gt; calc(int n) &#123; return calc(n, false); &#125; public static Map&lt;String, Object&gt; calc(int n, boolean save) &#123; NQueen03 nq = new NQueen03(n, save); nq.chess = new int[n]; Instant start = Instant.now(); nq.put(); Instant end = Instant.now(); Map&lt;String, Object&gt; res = new HashMap&lt;&gt;(); res.put("count", nq.count); res.put("time", Duration.between(start, end).toMillis()); res.put("result", nq.result); return res; &#125; private void put() &#123; int row = 0; Arrays.fill(chess, -1); while (row &gt;= 0) &#123; chess[row]++; while (chess[row] &lt; N &amp;&amp; !check(row, chess[row])) chess[row]++; if (chess[row] &lt; N) &#123; if (row == N - 1) add(); else row++; &#125; else &#123; chess[row] = -1; row--; &#125; &#125; &#125; private boolean check(int row, int pos) &#123; /// 倒过来 for (int i = row - 1; i &gt; -1; i--) &#123; // 垂直 if (chess[i] == pos) return false; // 斜线 if (Math.abs(row - i) == Math.abs(pos - chess[i])) return false; &#125; return true; &#125; private void add() &#123; count++; if (result == null) return; int[] r = new int[N]; for (int i = 0; i &lt; N; i++) r[i] = chess[i] + 1; result.add(r); &#125;&#125; 循环方法-一维数组方法的测试结果： 12345678910111213141516queen: 4count: 2time: 0result: 1: 2 4 1 3 2: 3 1 4 2 queen: 8count: 92time: 0result: nullqueen: 16count: 14772512time: 428106result: null 位运算法由于数据在计算机中是以二进制的形式存储的，因此位运算指令的执行速度是很快的。如果判断冲突时,能够使用位运算代替算术运算,可以取得较高的运行效率。 位运算采用递归做法，循环做法并不能带来明显的效率提升。 贴上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122package com.chain.algorithm.test.day02;import java.time.Duration;import java.time.Instant;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;/** * * 八皇后问题的递归解法-位运算 * * @author Chain * */public class NQueen04 &#123; // 总共有多少种解法 private int count; // 整数表示棋盘（存储棋盘的大小，在这里最多是32） private int chess; // 皇后的数量 private int N; // 记录具体的结果 private List&lt;int[]&gt; result; private NQueen04() &#123; this(8); &#125; private NQueen04(int n) &#123; this.N = n; &#125; private NQueen04(int n, boolean save) &#123; this(n); if (save) result = new ArrayList&lt;&gt;(); &#125; public static Map&lt;String, Object&gt; calc(int n) &#123; return calc(n, false); &#125; public static Map&lt;String, Object&gt; calc(int n, boolean save) &#123; NQueen04 nq = new NQueen04(n, save); nq.chess = (1 &lt;&lt; n) - 1; Instant start = Instant.now(); nq.put(); Instant end = Instant.now(); Map&lt;String, Object&gt; res = new HashMap&lt;&gt;(); res.put("count", nq.count); res.put("time", Duration.between(start, end).toMillis()); res.put("result", nq.result); return res; &#125; private void put() &#123; int[] r = new int[N]; fun(0, 0, 0, 0, r); &#125; // 位运算求解，col表示列，ld表示反斜线（左斜），rd表示正斜线（右斜） // 整个放置皇后的过程是每次都是按列从右往左尝试放置，每次执行时对应棋盘的行数为该次递归调用的次数 // t为递归调用的次数，也是棋盘对应的操作的行数 private void fun(int col, int ld, int rd, int t, int[] r) &#123; if (col == chess) &#123; add(r); return; &#125; // col列，ld，rd进行逻辑或运算，求得当前行不能放置皇后的位置，均为1 // 再取反，就可以求得当前行可以放置皇后的位置，均为1 // 再和chess进行逻辑与，是为了去除超出棋盘的位置（ld，rd） int empty = chess &amp; ~(col | ld | rd); // 用来记录从右往左看第一个可以放置皇后的位置 int p; // 判断还有没有地方可以放置 while (empty != 0) &#123; // 获得从右往左看第一个可以放置皇后的位置 // -empty 等价于 ~empty + 1 p = empty &amp; -empty; // 在p位置放置皇后，该位置0 empty -= p; // 存储 save(r, t, p); // col | p 表示col列已经被放置了皇后，下一次就不能再放在col列了 // (ld + p) &lt;&lt; 1 表示col列放置皇后后，下一次左斜不能再放置皇后的位置 // (rd | p) &gt;&gt; 1 表示col列放置皇后后，下一次右斜不能再放置皇后的位置 // 等价做法（位运算更快）：fun(col + p, (ld + p) &lt;&lt; 1, (rd + p) &gt;&gt; 1, t + 1, r); fun(col | p, (ld | p) &lt;&lt; 1, (rd | p) &gt;&gt; 1, t + 1, r); &#125; &#125; private void save(int[] r, int t, int p) &#123; if (result == null) return; int i = 1; // p不会为0 while (p != 1) &#123; p &gt;&gt;&gt;= 1; i++; &#125; r[t] = i; &#125; private void add(int[] r) &#123; count++; if (result == null) return; result.add(r.clone()); &#125;&#125; 递归方法-位运算方法的测试结果： 12345678910111213141516queen: 4count: 2time: 0result: 1: 2 4 1 3 2: 3 1 4 2 queen: 8count: 92time: 0result: nullqueen: 16count: 14772512time: 13153result: null 由此可见，使用位运算的速度提升是非常明显的，这也是目前比较快的做法。 在求解的结果中，可以发现有些是对称的，因此还可以进行进一步的剪枝，这里就不做研究了。 测试代码最后再补充贴上测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.chain.algorithm.test.day02;import java.util.List;import java.util.Map;import org.junit.Test;public class NQueueTest &#123; @Test public void test1() &#123; print(4, NQueen01.calc(4, true)); print(8, NQueen01.calc(8, false)); print(16, NQueen01.calc(16, false)); &#125; @Test public void test2() &#123; print(4, NQueen02.calc(4, true)); print(8, NQueen02.calc(8, false)); print(16, NQueen02.calc(16, false)); &#125; @Test public void test3() &#123; print(4, NQueen03.calc(4, true)); print(8, NQueen03.calc(8, false)); print(16, NQueen03.calc(16, false)); &#125; @Test public void test4() &#123; print(4, NQueen04.calc(4, true)); print(8, NQueen04.calc(8, false)); print(16, NQueen04.calc(16, false)); &#125; @SuppressWarnings("unchecked") private void print(int qn, Map&lt;String, Object&gt; res) &#123; System.out.println("queen: " + qn); System.out.println("count: " + res.get("count")); System.out.println("time: " + res.get("time")); List&lt;int[]&gt; result = (List&lt;int[]&gt;) res.get("result"); System.out.print("result: "); if (result == null) &#123; System.out.println("null"); return; &#125; System.out.println(); int len = result.size(); for (int i = 0; i &lt; len; i++) &#123; int[] a = result.get(i); System.out.print((i + 1) + ": "); for (int j = 0; j &lt; a.length; j++) System.out.print(a[j] + " "); System.out.println(); &#125; &#125;&#125; 参考博客cnblogs]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rand5实现rand7]]></title>
    <url>%2F2017%2F10%2F17-java-rand5-to-rand7%2F</url>
    <content type="text"><![CDATA[利用rand5来实现rand7（Java）这是一道很有趣的笔试题，考察随机和概率。这里整理一下。 考试题目已知rand5能等概率产生1, 2, 3, 4, 5， 现要用rand5来实现rand7。（rand7的意思是要等概率产生1, 2, 3, 4, 5, 6, 7）。 我的解决这个涉及概率和随机，应当用数学的方式去解决，而不是凑结果。 Java的API库实现的Math.random是等概率的，可以用它来实现rand5()。 rand5()产生从1-5的等概随机数，然后可以用rand5来实现rand7。 rand5()可以实现1-5，那么rand5()-1可以实现等概产生0-4。 如果将上者的结果再线性扩大5被，那么就可以等概产生0，5，10，15，20。 这样再将原来的rand5插入其中，就可以等概的产生0到24。 方程可以概括为： 1(rand5() - 1) * 5 + (rand5() - 1) 以上的过程其实就是将一个随机数经过加上常数和扩大的过程，整个过程是线性的。 接着有了0-24后，需要得到0-6，则需要先裁剪0-24，使之满足7的倍数，即裁剪为0-20这21个数。 最后就可以根据和7取模得到等概的0-6。进而可以得到1-7。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.chain.javase.test.day11;import org.junit.Test;/** * 由rand5()计算出rand7() * * @author Chain * */public class Test11 &#123; private static final long M = 10_0000_0000L; // rand5()测试 @Test public void test1() &#123; int[] t = new int[5]; for (long i = 0; i &lt; M; i++) &#123; t[rand5() - 1]++; &#125; print(t); &#125; // rand7()测试 @Test public void test2() &#123; int[] t = new int[7]; for (long i = 0; i &lt; M; i++) &#123; t[rand7() - 1]++; &#125; print(t); &#125; // 使用rand5()产生rand7()，等概产生1-7这7个数 private int rand7() &#123; while (true) &#123; // 产生的数字从0到24，共25个数字，这25个数字的产生是等可能的 // 但是25不是7的倍数，最近的是21 int r = (rand5() - 1) * 5 + (rand5() - 1); // 剔除21, 22, 23, 24 if (r &gt; 20) // 虽然每次计算的时间不一样，需要有若干次循环，但是仍然是等概率的 continue; else // 映射到1-7 return r % 7 + 1; &#125; &#125; // 等概产生1-5这5个数 private int rand5() &#123; return (int) (Math.random() * 5 + 1); &#125; private void print(int[] a) &#123; for (int i = 0; i &lt; a.length; i++) System.out.println(a[i]); System.out.println(); &#125;&#125; 思考一下，如果是已知rand7，要求实现rand5呢？ 道理其实是一样的。 17 * (rand7() - 1) + (rand7() - 1) 可以等概生成0-48，共49个数。 45是5的倍数，所以循环中剔除46,47,48,49。 然后使用 1t % 5 + 1 可以得到结果。 测试结果先测试rand5()： 12345200010915200002853199990426199994398200001408 再测试rand7()： 1234567142861771142856121142860575142858382142858689142843816142860646 可以看到rand5是等概的结果，rand7也是等概的结果。 参考博客csdn]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
        <tag>求职</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java自定义实现集合框架]]></title>
    <url>%2F2017%2F10%2F15-java-my-collections-framework%2F</url>
    <content type="text"><![CDATA[Java自定义实现集合框架（Collection Framework） DO IT ! 提示：自定义实现的集合框架源码在这里。 Java实现自定义双端队列Java实现自定义队列Java实现自定义排序二叉树 这篇博文主要介绍自己实现的Java的集合框架，框架还在不断完善中，还有很多的不足之处，还望指正和提出意见。 框架只是为了学习数据结构和算法的知识，存在很多不足和错误，不能被用于真正的生产开发中。 框架介绍博文仍在整理中。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java实现自定义双端队列（链表和数组两种方式）]]></title>
    <url>%2F2017%2F10%2F12-java-array-deque%2F</url>
    <content type="text"><![CDATA[Java实现自定义双端队列（链表和数组两种方式）前面写过单端队列，文章链接。 提示：自定义实现的集合框架源码在这里。 单端队列有数组和链表两种实现方式。数组的实现方式相对比链表复杂一些，需要理解数学关系。 接下来，是时候实现双端队列了。 简单介绍单端队列只能从一端插入元素，另一端取出元素。而双端队列则可以在两端均可以插入和删除元素。 双端队列可以充当单端队列，也可以用于充当栈。 在Java中，LinkedList的内部使用双端链表队列原理实现，而ArrayList的内部使用双端数组队列原理实现。 基本方法双端队列接口Deque和Queue以及Stack中对应的方法如下： 数组实现数组实现的方法和单端队列时实现的方式差不多，都是规定了一个head和tail。 head用来表示头元素的位置，或者翻译官方API的话是即将删除和查看的那个元素。tail用来表示尾元素的下一个位置，或者翻译官方API的话是元素即将被插入的位置。 在这里需要注意的是和单端队列的实现方式不同的是这里核心的数学表达式采用的是逻辑与操作，以此来确定元素的操作位置。 首先数组的初始容量capacity__必须是2的指数倍__，可以是8、16，但不能是10或者20。 以tail为例，在add方法中，使用的数学表达式如下： 1tail = (tail + 1) &amp; (capacity - 1); 这样的效果和下面的表达式是等价的： 1tail = (tail + 1) % capacity; 这是为什么呢？ 因为capacity为2的指数倍，比如8。其二进制的表示为1000，那么capacity - 1为7，对应的二进制的表示为0111，其低位均为1。假设tail是4，那么4&amp;7就为4；若tail是7，那么tail+1是8，而8&amp;7为0，则tail下一个插入的位置是0，结果是正确的。如果是head进行addFirst操作的话，那么就是head-1，head-1可能是负数，使用(head-1)&amp;(capacity-1)可以解决负数的问题。如果是使用求模符号，则为(head+capacity-1)%capacity。 使用逻辑运算的速度一般快于四则运算的速度，所以使用逻辑与运算操作是更好的。 链表实现使用链表实现，不同与单端队列，链表节点需要同时记录前一个节点和后一个节点。 单端队列的实现，我采用的做法是头结点只是起到引导作用，牵住整个链表，没有实际的存储意义，这样操作起来会比较方便。而双端队列所有的节点都是有意义的。 在双端队列的增删改的操作中，需要仔细考虑被操作节点与前后节点（即使没有）的关系。 源码下载源码我放在了[这里]，这是自己实现Java集合框架的一部分。欢迎提出宝贵意见。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[群硕校招-同色三角形]]></title>
    <url>%2F2017%2F10%2F10-qunshuo-school-test1%2F</url>
    <content type="text"><![CDATA[群硕校招-同色三角形这是一道编程题，一开始还想到了图的遍历。后来仔细阅读后发现，这条题目其实还是挺简单的。 考试题目平面上有6个点，每两个点之间都以红线或黑线连接，任意三点均不共线。现在，已知下列点之间的连线是红色的，剩下的连线都是黑色的。要求计算这些点组成的三角形中有多少是同色的? 已知的红色连线(6,5) (1,2) (1,3) (2,3) (2,5) (3,6)。 我的解决一开始以为线相交的点也要算进去，甚至还想到用图来解决。再次阅读后，发现使用暴力法就能解决问题。 先画个图，方便分析。 6个点总共可以构成的三角形数量为C[6,3]=20。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.chain.blog.test.day11;import java.util.Scanner;//同色三角形public class QunShuoTest2 &#123; public static void main(String[] args) &#123; test1(); &#125; private static void test1() &#123; try (Scanner in = new Scanner(System.in)) &#123; // 点个数 int n = in.nextInt(); // 红色连线个数 int m = in.nextInt(); // 红色连线存储，邻接矩阵 int[][] t = new int[n][n]; for (int i = 0; i &lt; m; i++) &#123; int d1 = in.nextInt() - 1; int d2 = in.nextInt() - 1; t[d1][d2] = 1; t[d2][d1] = 1; &#125; long sum = 0; long tri = 0; // 从第一个点开始依次暴力 for (int i = 0; i &lt; n - 2; i++) &#123; for (int j = i + 1; j &lt; n - 1; j++) &#123; for (int k = j + 1; k &lt; n; k++) &#123; int s1 = t[i][j]; int s2 = t[j][k]; int s3 = t[i][k]; if (s1 == s2 &amp;&amp; s2 == s3) &#123; sum += 1; System.out.println("发现同色三角形：" + (i + 1) + " " + (j + 1) + " " + (k + 1)); &#125; tri += 1; &#125; &#125; &#125; System.out.println("总共有三角形个数：" + tri); System.out.println("同色三角形的个数：" + sum); &#125; &#125;&#125; 测试结果测试是按照题意输入的数据。 12345678910111213146 66 51 21 32 32 53 6发现同色三角形：1 2 3发现同色三角形：1 4 5发现同色三角形：1 4 6发现同色三角形：2 4 6发现同色三角形：3 4 5总共有三角形个数：20同色三角形的个数：5 其他答案可能还有其他的更好的解答吧。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
        <tag>求职</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的题目，编程的思想]]></title>
    <url>%2F2017%2F10%2F10-talk-about-4x-add-6y-equals-20%2F</url>
    <content type="text"><![CDATA[简单的题目，编程的思想实验室需要带萌新，简单帮学弟入门编程，自己也是在大学的最后一年了。 出了一道简单的编程题： 求满足4x+6y=20的所有非负整数解。 自己当时也没想太多，纯粹是让练练手，不过大家提交的答案却能投射出编程的一些思想。 做法一循环执行次数：21*21=441。 这个也是最直观的做法。 12345678private static void test1() &#123; for (int i = 0; i &lt;= 20; i++) &#123; for (int j = 0; j &lt;= 20; j++) &#123; if (4 * i + 6 * j == 20) System.out.println(i + " " + j); &#125; &#125;&#125; 做法二利用2层while循环，在执行过程判断x,y的和与20的关系。 循环执行次数：5+4+4+3+2+2=20。 1234567891011121314151617181920private static void test2() &#123; int x = 0; int y = 0; int z = 20; while (true) &#123; y = 0; while (true) &#123; int sum = 4 * x + 6 * y; if (sum == z) &#123; System.out.println(x + " " + y); &#125; else if (sum &gt; z) &#123; break; &#125; y++; &#125; x++; if (4 * x &gt; z) break; &#125;&#125; 做法三较做法1缩小了范围。 化简4x+6y=20为2x+3y=10。 循环执行次数：4*6=24。 123456789private static void test3() &#123; for (int y = 0; y &lt;= 3; y++) &#123; for (int x = 0; x &lt;= 5; x++) &#123; int sum = 4 * x + 6 * y; if (sum == 20) System.out.println(x + " " + y); &#125; &#125;&#125; 做法四是做法三的改进，一个简单的数学不等式，将一个未知数用另一个未知数表示。 循环执行次数：14。 123456789private static void test4() &#123; for (int y = 0; y &lt;= 3; y++) &#123; for (int x = 0; x &lt;= (10 - 3 * y) / 2; x++) &#123; int sum = 4 * x + 6 * y; if (sum == 20) System.out.println(x + " " + y); &#125; &#125;&#125; 做法五利用做法四的数学关系，进一步优化。 循环执行次数：4。 123456789private static void test5() &#123; for (int y = 0; y &lt;= 3; y++) &#123; int t = 10 - 3 * y; int x = t / 2; int n = t % 2; if (n == 0 &amp;&amp; x &gt;= 0 &amp;&amp; x &lt;= 5) System.out.println(x + " " + y); &#125;&#125; 总结简单的题目，详细探究还是能体现编程的一些思想的。 接下来，在一起讨论下，总结出了以下的通用做法，还是很不错的哈。 求解二元一次方程的通用做法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private static void test6(int x, int y, int z) &#123; // 先进行优化，化简 &#123; int t = gcd(x, y); t = gcd(t, z); if (t != 1) &#123; x = x / t; y = y / t; z = z / t; &#125; &#125; final int m = max(x, y); final int n = min(x, y); final int p = z / m; final int q = z / n; for (int i = 0; i &lt;= p; i++) &#123; int e = z - m * i; int u = e / n; int r = e % n; if (r == 0 &amp;&amp; u &gt;= 0 &amp;&amp; u &lt;= q) &#123; if (m == x) &#123; System.out.println("x=" + i + ",y=" + u); &#125; else &#123; System.out.println("x=" + u + ",y=" + i); &#125; &#125; &#125;&#125;// 循环法求最大公约数private static int gcd(final int i, final int j) &#123; int m = min(i, j); int n = max(i, j); int t = 0; while (true) &#123; if (m == 0) return n; t = m; m = n % m; n = t; &#125;&#125;private static int min(final int m, final int n) &#123; return m &gt; n ? n : m;&#125;private static int max(final int m, final int n) &#123; return m &gt; n ? m : n;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的数组排序算法（补充）]]></title>
    <url>%2F2017%2F10%2F09-sort-integer-array-extra%2F</url>
    <content type="text"><![CDATA[常见的数组排序算法（Java版 补充）之前写过一篇排序的算法，原文链接。 现在再来补充其他的一些算法，或者原来算法的改进方法，并结合一些其他的博文，做一些知识点总结。 推荐一个常见算法的动态演示网站：https://visualgo.net/ 本文：源码在这里。测试在这里。 文中插图来自网络。 排序算法一些排序算法的补充或改进。 笔试面试最常涉及到的12种排序算法： 冒泡排序、鸡尾酒排序；插入排序、二分插入排序，希尔排序；选择排序；快速排序；堆排序；归并排序；桶排序；计数排序；基数排序。 鸡尾酒排序这种排序算法又被称为鸡尾酒排序，或者叫定向冒泡排序。 这种改进算法与传统的冒泡排序的不同之处在于：从低到高然后又从高到低，而冒泡排序则仅是从低到高的去比较。 鸡尾酒排序可以得到比冒泡排序稍微好一点的效能，但是在乱数序列的状态下，鸡尾酒排序与冒泡排序的效率都很差劲。 1234567891011121314151617181920212223242526272829303132333435/*** 定向冒泡排序，或鸡尾酒排序：从低到高然后又从高到低* * @param a* 要排序的数组*/public static void cockTailSort(int[] a) &#123; checkArray(a); int n = a.length; boolean flag = false;// false代表没有排好序 int left = 0; int right = n - 1; while (left &lt; right &amp;&amp; !flag) &#123; // 先从左到右，升序 for (int i = left; i &lt; right &amp;&amp; !flag; i++) &#123; if (a[i] &gt; a[i + 1]) &#123; flag = false; swap(a, i, i + 1); &#125; &#125; if (flag) break; right--; // 在从右到左，降序 for (int i = right; i &gt; left &amp;&amp; !flag; i--) &#123; if (a[i - 1] &gt; a[i]) &#123; flag = false; swap(a, i - 1, i); &#125; &#125; if (flag) break; left++; &#125;&#125; 二分插入排序插入排序中，要插入的元素再找到自己的插入位置时，是依次（顺序）查找，这样的查找比较缓慢。所以可以融入二分查找，以提高在查找插入位置时的效率。 当n较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差，所当以元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。 但是，二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列，减少的是查找时间。 1234567891011121314151617181920212223242526/*** 类二分查找的插入排序，适合元素数量较多的情况。* * @param a* 要排序的数组*/public static void binarySearchInsertSort(int[] a) &#123; checkArray(a); int n = a.length; for (int i = 1; i &lt; n; i++) &#123; int t = a[i]; int left = 0; int right = i - 1; while (left &lt;= right) &#123; int mid = (right - left) / 2 + left; if (a[mid] &gt; t) right = mid - 1; else left = mid + 1; &#125; for (int j = i - 1; j &gt;= left; j--) &#123; a[j + 1] = a[j]; &#125; a[left] = t; &#125;&#125; 计数排序非比较型排序算法，在排序的时候就知道元素的正确位置，那么只需扫描一遍即可放入正确位置。如此以来，只需知道有多大范围就可以了。这就是计数排序的思想。 性能：时间复杂度O(n+k)，线性时间，并且稳定。优点：不需比较，利用地址偏移，对范围固定在[0,k]的整数排序的最佳选择。是排序字符串最快的排序算法。缺点：用来计数的数组的长度取决于带排序数组中数据的范围（等于待排序数组的最大值和最小值的差加1），这使得计数排序对于数据范围很大的数组，需要大量时间和空间，即牺牲空间换取时间。 123456789101112131415161718192021222324252627282930313233343536/** * 计数排序：适用于数值范围较小的数组，比如字符串排序，0-9排序等。 * * 非比较排序 * * @param a * 要排序的数组 */public static void countSort(int[] a) &#123; checkArray(a); int n = a.length; int[] r = new int[n]; int max = a[0]; int min = max; for (int i : a) &#123; if (i &gt; max) max = i; if (i &lt; min) min = i; &#125; // 用于统计 int len = max - min + 1; int[] f = new int[len]; // 统计出现的次数 for (int i = 0; i &lt; n; i++) f[a[i] - min]++; // 计算相对位移 for (int i = 1; i &lt; len; i++) f[i] += f[i - 1]; // 倒序输出数组（稳定） for (int i = n - 1; i &gt; -1; i--) r[--f[a[i] - min]] = a[i]; // 再拷贝回去 for (int i = 0; i &lt; n; i++) a[i] = r[i];&#125; 归并排序归并排序是创建在归并操作上的一种有效的排序算法，效率为O(nlogn)。1945年由冯·诺伊曼首次提出。 归并排序的实现分为递归实现与非递归(迭代)实现。 递归实现的归并排序：是算法设计中分治策略的典型应用，我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。非递归(迭代)实现的归并排序：首先进行是两两归并，然后四四归并，然后是八八归并，一直下去直到归并了整个数组。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/*** 归并排序：自顶而下，递归做法* * @param a* 要排序的数组*/public static void mergeSort(int[] a) &#123; checkArray(a); int n = a.length; int low = 0; int high = n - 1; mergeSortPartSort(a, low, high);&#125;private static void mergeSortPartMerge(int[] a, int low, int mid, int high) &#123; // 两个指针 int p = low; int q = mid + 1; int len = high - low + 1; // 临时数组，用于排序的备份 int[] t = new int[len]; for (int i = low; i &lt;= high; i++) t[i - low] = a[i]; for (int i = low; i &lt;= high; i++) &#123; // 左半边已无剩余 if (p &gt; mid) &#123; a[i] = t[q++ - low]; &#125; // 右半边已无剩余 else if (q &gt; high) &#123; a[i] = t[p++ - low]; &#125; // 右半边当前元素小于左半边当前元素，取右半边的元素 else if (t[q - low] &lt; t[p - low]) &#123; a[i] = t[q++ - low]; &#125; // 右半边当前元素大于或等于左半边当前元素，取左半边的元素 else &#123; a[i] = t[p++ - low]; &#125; &#125;&#125;// 自顶而下，递归做法private static void mergeSortPartSort(int[] a, int low, int high) &#123; // 分到每组一个元素为止 if (low &gt;= high) return; int mid = (high - low) / 2 + low; // 左右两边分治，分别进行排序 mergeSortPartSort(a, low, mid); mergeSortPartSort(a, mid + 1, high); // 左右两边归并 mergeSortPartMerge(a, low, mid, high);&#125;/*** 归并排序：自底而上，循环做法* * @param a* 要排序的数组*/public static void buttomUpMergeSort(int[] a) &#123; checkArray(a); int n = a.length; int high = n - 1; // 进行logN次两两归并 // p代表size int delta = 0; for (int p = 1; p &lt;= high; p = delta) &#123; delta = p &lt;&lt; 1; // 每个size下对每一个划分的小组进行归并 for (int low = 0; low &lt;= high - p; low += delta) &#123; mergeSortPartMerge(a, low, low + p - 1, Math.min(low + delta - 1, high)); &#125; &#125;&#125; 对归并排序进行一些改进可以提高合并排序的效率。 当划分到较小的子序列时，通常可以使用插入排序替代合并排序。 如果已经排好序了就不用合并了。 并行化。 归并排序和快速排序一样都是时间复杂度为nlgn的算法，但是和快速排序相比，合并排序是一种稳定性排序，也就是说排序关键字相等的两个元素在整个序列排序的前后，相对位置不会发生变化，这一特性使得合并排序是稳定性排序中效率最高的一个。在Java中对引用对象进行排序，Perl、C++、Python的稳定性排序的内部实现中，都是使用的合并排序。 具体可以参考这篇博客。 基数排序非比较型排序算法，原理是将整数按位切割成不同数字，然后按每个位数分别比较。 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零，然后从最低位开始，依次进行一次排序，这样从最低位排序一直到最高位排序完成后，数列就变成有序的。 基数排序会使用到计数排序作为每一位数位时的排序方式。 因为是0-9排序，所以中间过程使用计数排序相对较快，当然也可以使用其他排序方式。 基数排序的时间复杂度是O(n*dn)，其中n是待排序元素个数，dn是数字位数。这个时间复杂度不一定优于O(nlogn)，dn的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小； 数字位数dn决定了需要进行多少次处理，而n是每次处理的操作数目。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 基数排序：非比较排序算法，这里是最低位优先基数排序LSD(Least significant digit) * * @param a * 要排序的数组 */public static void radixSort(int[] a) &#123; checkArray(a); radixSort(a, 10);&#125;private static void radixSort(int[] a, int radix) &#123; int max = a[0]; int min = max; for (int i : a) &#123; if (i &gt; max) max = i; if (i &lt; min) min = i; &#125; // 最大和最小的差 int delta = max - min; // 指数 int exponent = 1; // 从低位开始往高位依次进行按位计数排序 while (delta / exponent &gt;= 1) &#123; countSortByDigit(a, radix, exponent, delta, min); exponent *= radix; &#125;&#125;private static void countSortByDigit(int[] a, int radix, int exponent, int delta, int min) &#123; int n = a.length; // 用于统计 int len = delta + 1; int[] f = new int[len]; // 统计出现的次数（频率） int findex = 0; for (int i = 0; i &lt; n; i++) &#123; // 取数组元素的第exponent位。 // 比如exponent等于1，则取最后一位（个位）；exponent等于10，则取十位。 // 如果超过位数，则计算下来也正好是0，起到补0的效果。 findex = ((a[i] - min) / exponent) % radix; f[findex]++; &#125; // 计算相对位移 for (int i = 1; i &lt; len; i++) f[i] += f[i - 1]; // 反序输出到中间数组（这样确保稳定） int[] r = new int[n]; for (int i = n - 1; i &gt; -1; i--) &#123; findex = ((a[i] - min) / exponent) % radix; r[--f[findex]] = a[i]; &#125; // 再拷贝回去 for (int i = 0; i &lt; n; i++) a[i] = r[i];&#125; 如果考虑和比较排序进行对照，基数排序的形式复杂度虽然不一定更小，但由于不进行比较，因此其基本操作的代价较小，而且如果适当的选择基数，dn一般不大于logn，所以基数排序一般要快过基于比较的排序，比如快速排序。 由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序除了可以进行整数排序，也可以进行其他排序。 桶排序桶排序也叫箱排序，为非比较型排序算法。 工作的原理是将数组元素映射到有限数量个桶里，利用计数排序可以定位桶的边界，每个桶再各自进行桶内排序（可以使用其它排序算法或以递归方式继续使用桶排序）。 就像分拣邮件那样。主要在于桶的大小和桶的数量的选择，这里的桶的大小和桶的数量的选择仅做参考。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * 桶排序：先使用计数排序进行分桶操作，然后对每个非空桶进行排序。 * * 非比较排序，又叫箱排序。 * * @param a * 要排序的数组 */public static void bucketSort(int[] a) &#123; checkArray(a); int n = a.length; int max = a[0]; int min = max; for (int i : a) &#123; if (i &gt; max) max = i; if (i &lt; min) min = i; &#125; // 桶的容量 int size = 1; int delta = max - min; int t = delta; while (t &gt; 0) &#123; size *= DECIMAL; t /= 10; &#125; // 桶的数量 int bs = n % size == 0 ? n / size : n / size + 1; // 记录桶的边缘 int[] b = new int[bs]; // 计数排序进行分桶 countSortForBucket(a, b, size, min); // 每个桶进行单独排序 for (int i = 0; i &lt; bs; i++) &#123; int start = b[i]; int end = i == bs - 1 ? n - 1 : b[i + 1] - 1; // 这里使用选择排序，其他排序方法也是可以的 selectSortForBucket(a, start, end); &#125;&#125;private static void countSortForBucket(int[] a, int[] bucket, int size, int min) &#123; int n = a.length; int bn = bucket.length; int[] r = new int[n]; // 统计出现的次数 int findex = 0; for (int i = 0; i &lt; n; i++) &#123; findex = (a[i] - min) / size; bucket[findex]++; &#125; // 计算相对位移 for (int i = 1; i &lt; bn; i++) bucket[i] += bucket[i - 1]; // 倒序输出数组（稳定） for (int i = n - 1; i &gt; -1; i--) &#123; findex = (a[i] - min) / size; // 桶的边缘被更新：bucket[i]为第i号桶中第一个元素所在r中的位置 r[--bucket[findex]] = a[i]; &#125; // 再拷贝回去 for (int i = 0; i &lt; n; i++) a[i] = r[i];&#125;private static void selectSortForBucket(int[] a, int start, int end) &#123; // 都是闭合区间 for (int i = start; i &lt; end; i++) &#123; int min = i; for (int j = i + 1; j &lt;= end; j++) &#123; if (a[j] &lt; a[min]) min = j; &#125; if (min != i) &#123; swap(a, min, i); &#125; &#125;&#125; 桶排序不是比较排序，不受到O(nlogn)下限的影响，它是鸽巢排序的一种归纳结果，当所要排序的数组值分散均匀的时候，桶排序拥有线性的时间复杂度。 什么时候是最好情况呢？输入数组在一个范围内均匀分布。 什么时候是最坏情况呢？数组的所有元素都进入同一个桶。 堆排序堆排序是指利用堆这种数据结构所设计的一种选择排序算法。堆是一种近似完全二叉树的结构（通常堆是通过一维数组来实现的）。 以最大堆（也叫大根堆、大顶堆）为例，其中父结点的值总是大于它的孩子节点，或完全二叉树中所有非叶子结点的值均不大于（或不小于）其左、右孩子结点的值。 堆排序其实也是一种选择排序，是一种树形选择排序。 其基本思想为(大顶堆)：1） 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；2） 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；3） 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成，得到升序序列。 以上思想可归纳为两个操作：1）根据初始数组去构造初始堆（构建一个完全二叉树，保证所有的父结点都比它的孩子结点数值大）。2）每次交换第一个和最后一个元素，输出最后一个元素（最大值），然后把剩下元素重新调整为大根堆。当输出完最后一个元素后，这个数组已经是按照从小到大的顺序排列了。 若想得到升序，则建立大顶堆；若想得到降序，则建立小顶堆。 对于堆排序，最重要的两个操作就是构造初始堆和调整堆，其实构造初始堆事实上也是调整堆的过程，只不过构造初始堆是对所有的非叶节点都进行调整。 堆排序的具体原理和过程这两篇博客1和博客2讲的很好。 如下图，这是一个初始堆，接下来的代码可以参考这个图。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 堆排序：利用数组来实现堆，利用堆的性质来排序。 * * 因为这个堆是使用数组实现的，所以元素节点不需要复杂操作的左孩子和右孩子，只是有数学上的关系而已。 * * 堆的含义是：完全二叉树中所有非叶子结点的值均不大于（或不小于）其左、右孩子结点的值。 * * @param a */public static void heapSort(int[] a) &#123; checkArray(a); int n = a.length; // 构造初始大顶堆 heapSortBuild(a); // 无序区的元素个数大于1，则代表未完成排序 // n==1时即排序完成，最后一个元素无需调整 while (n &gt; 1) &#123; // 每次将第一个元素（堆顶元素）和最后一个元素（叶子节点）交换 // 交换不仅会破环原来的堆结构，也会改变相对位置，所以堆排序是非稳定的 swap(a, 0, --n); // 从新的堆顶元素开始向下重新进行堆调整，使其成为一个新堆，时间复杂度O(logn) heapify(a, 0, n); &#125;&#125;// 构建大顶堆其实也是堆调整的过程private static void heapSortBuild(int[] a) &#123; int n = a.length; // 从最后一个非叶子结点开始向上进行调整 for (int i = n / 2 - 1; i &gt; -1; i--) &#123; heapify(a, i, n); &#125;&#125;// 堆调整，对大小为0-size的堆中第index个元素进行调整，使其满足大顶堆private static void heapify(int[] a, int index, int size) &#123; // 该节点，节点的左孩子，节点的右孩子哪个最大 int max = index; // 左孩子节点是该节点的2*index+1 int left = 2 * index + 1; if (left &lt; size &amp;&amp; a[left] &gt; a[max]) max = left; // 右孩子节点是该节点的2*index+2 int right = 2 * index + 2; if (right &lt; size &amp;&amp; a[right] &gt; a[max]) max = right; if (max != index) &#123; // 将最大的节点调整为父节点 swap(a, max, index); // 递归调用，继续将交换到max节点的被破坏部分进行调整 heapify(a, max, size); &#125;&#125; 动画在排序过程之前简单的表现了创建堆的过程以及堆的逻辑结构。 堆排序是不稳定的排序算法，不稳定发生在堆顶元素与A[i]交换的时刻。 堆排序方法对记录数较少的文件并不值得提倡，但对n较大的文件还是很有效的。因为其运行时间主要耗费在建初始堆和调整建新堆时进行的反复“筛选”上。 堆排序在最坏的情况下，其时间复杂度也为O(nlogn)。相对于快速排序来说，这是堆排序的最大优点。此外，堆排序仅需一个记录大小的供交换用的辅助存储空间。 堆排序的应用在于优先级队列，比如绝大多数手机分配给来电的优先级都会比其他应用高。 排序小结排序分内排序和外排序。 内排序:指在排序期间数据对象全部存放在内存的排序。外排序:指在排序期间全部对象个数太多,不能同时存放在内存,必须根据排序过程的要求,不断在内、外存之间移动的排序。 内排序的方法有许多种,按所用策略不同,可归纳为五类:插入排序、选择排序、交换排序、归并排序、分配排序和计数排序。 插入排序主要包括直接插入排序，折半插入排序和希尔排序两种;选择排序主要包括直接选择排序和堆排序;交换排序主要包括冒泡排序和快速排序;归并排序主要包括二路归并(常用的归并排序)和自然归并。分配排序主要包括箱排序和基数排序。计数排序就一种。 基于比较排序的算法，时间复杂度下界是O(nlogn)。非比较类型的排序算法如计数排序，桶排序，基数排序，是可以突破O(nlogn)的下界的。换句话说非比较类型的排序可能比基于排序的算法更好。但是非基于比较的排序算法使用限制比较多。比如：计数排序进对较小整数进行排序，且要求排序的数据规模不能过大；基数排序可以对长整数进行排序，但是不适用于浮点数；桶排序可以对浮点数进行排序。 排序的稳定稳定排序:假设在待排序的文件中,存在两个或两个以上的记录具有相同的关键字,在用某种排序法排序后,若这些相同关键字的元素的相对次序仍然不变,则这种排序方法是稳定的。 其中冒泡,插入,基数,归并属于稳定排序;选择,快速,希尔,堆属于不稳定排序。 排序算法稳定性的简单形式化定义为： 如果Ai = Aj，排序前Ai在Aj之前，排序后Ai还在Aj之前，则称这种排序算法是稳定的。通俗地讲就是保证排序前后两个相等的数的相对顺序不变。 对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性； 而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。 需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。例如，对于冒泡排序，原本是稳定的排序算法，如果将记录交换的条件改成A[i] &gt;= A[i + 1]，则两个相等的记录就会交换位置，从而变成不稳定的排序算法。其次，说一下排序算法稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位排序后元素的顺序在高位也相同时是不会改变的。 每种排序算法都各有优缺点。因此，在实用时需根据不同情况适当选用，甚至可以将多种方法结合起来使用。 算法的选择影响排序的因素有很多，平均时间复杂度低的算法并不一定就是最优的。相反，有时平均时间复杂度高的算法可能更适合某些特殊情况。同时，选择算法时还得考虑它的可读性，以利于软件的维护。一般而言，需要考虑的因素有以下四点： 1．待排序的记录数目n的大小；2．记录本身数据量的大小，也就是记录中除关键字外的其他信息量的大小；3．关键字的结构及其分布情况；4．对排序稳定性的要求。 设待排序元素的个数为n. 1）当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序。 快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；堆排序：如果内存空间允许且要求稳定性的，归并排序：它有一定数量的数据移动，所以我们可能过与插入排序组合，先获得一定长度的序列，然后再合并，在效率上将有所提高。 2）当n较大，内存空间允许，且要求稳定性 =》归并排序 3）当n较小，可采用直接插入或直接选择排序。 直接插入排序：当元素分布有序，直接插入排序将大大减少比较次数和移动记录的次数。直接选择排序 ：元素分布有序，如果不要求稳定性，选择直接选择排序 5）一般不使用或不直接使用传统的冒泡排序。 6）基数排序：它是一种稳定的排序算法，但有一定的局限性：a、关键字可分解。b、记录的关键字位数较少，如果密集更好c、如果是数字时，最好是无符号的，否则将增加相应的映射复杂度，可先将其正负分开排序。 算法基本思想常见的内部排序算法（摘自软考书）。 直接插入排序的基本思想：每步将个待排序的记录按其排序码值的大小，插到前面己经排好的文件中的适当位置，直到全部插入完为止。 希尔排序的基本思想：先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组，所有距离为d的倍数的记录放在间一个组中。先在各维内进行直接插入排序，然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量dt=1(dt&lt;dt-1&lt;O&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。该方法实质上是一种分组插入方法。 直接选择择序的基本思想:首先在所有记录中选出排序码最小的记录，把它与第1个记录交换，然后在其余的记录内选出排序码最小的记录，与第2个记录交换…依此类推，直到所有记录排完为止， 堆排序的基本思想：堆挂序是一种树形选择排序，是对直接选择排序的有效改进。它通过建立初始堆和不断地重建堆，逐个地将排序关键字按顺序输出，从而达到排序的目的。 冒泡排序的基本思想：将被排序的记录数组R[1..n]重直排列，每个记录R[i]看作是重量为ki的气泡。根据轻气泡不能在重气泡之下的原则，从F往上扫描数组R，凡扫描到违反本原则的轻气泡，就使其向上“飘浮”。如此反复进行，直到最后任何两个气泡都是轻者在上，重者在下为止。 快速排序的基本思想:采用了一种分治的策略，将原问题分解为若于个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。 归并排序的基本思想:将两个或两个以上的有序子表合并成个新的有序表。初始时，把含有n个结点的待排序序列看作由n个长度都为1的有序子表所组成，将它们依次两两归并得到长度为2的若千有序子表，再对它们两两合并，直到得到长度为n的有序表为止，排序结束。 基数排序的基本思想:从低位到高位依次对待排序的关键码进行分配和收集，经过d趟分配和收集，就可以得到一个有序序列。 参考文章1、csdn2、cnblogs3、cnblogs4、segmentfault5、cnblogs]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契数列]]></title>
    <url>%2F2017%2F10%2F08-java-fibonacci-sequence%2F</url>
    <content type="text"><![CDATA[斐波那契数列放完国庆假期，自己也该投入学习中了。先温故学习一下斐波那契数列，又称黄金分割数列，它是算法题经典中的经典，斐波那契数列在数学和生活以及自然界中都非常有用，具体的编程求解方法也有很多。这里整理一下，做个记录。 起源定义参考知乎。 斐波那契数列最早被提出是印度数学家Gopala，他在研究箱子包装物件长度恰好为1和2时的方法数时首先描述了这个数列。 也就是这个问题： 有n个台阶，你每次只能跨一阶或两阶，上楼有几种方法？ 而最早研究这个数列的当然就是斐波那契（Leonardo Fibonacci）了，他当时是为了描述如下情况的兔子生长数目： 第一个月初有一对刚诞生的兔子第二个月之后（第三个月初）它们可以生育每月每对可生育的兔子会诞生下一对新兔子兔子永不死去 这个数列出自他赫赫有名的大作《计算之书》，后来就被广泛的应用于各种场合了。 这个数列是这么定义的： （注意，并非满足第三条的都是斐波那契数列，卢卡斯数列（A000032 - OEIS）也满足这一特点，但初始项定义不同） 求解方法目前整理了斐波那契数列的4种解法。 斐波那契数列： Fib(0) = 0Fib(1) = 1Fib(n) = Fib(n-1) + Fib(n-2)F() = 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 … 在生活中，斐波那契数列有如下的自然现象： 诸如此类的还有向日葵、蜂巢、蜻蜓翅膀、海螺、人类耳朵轮廓等等。 递归做法递归还是挺好理解的，斐波那契数列也是递归原理讲解的经典题目。 12345678910111213/** * 递归做法，递归图是一个树形结构 * * 时间复杂度：O(2^n) * * @param n * @return */public int recursion(int n) &#123; if (n &lt; 2) return n; return recursion(n - 1) + recursion(n - 2);&#125; 由于每一次调用recursion方法都会再调用recursion两次，就像树节点下的两个子节点。斐波那契数列树因此而来。 比如求解f(5)，有以下的树结构： 递归调用的时间复杂度是很恐怖的，O(n)=2^n。如果计算超过100，计算速度就很慢了，而且可能会造成栈溢出异常。 循环做法循环做法可以借助一个数组，来存储中间的计算过程，便于查询和计算。 比如算n=50后，再计算n=6可以直接在数组中取即可，无需再计算。 1234567891011121314151617181920/** * 循环做法(借助数组，可以用于打印前n个元素) * * 时间复杂度：O(n) * * @param n * @return */public int circle(int n) &#123; if (n &lt; 2) return n; int[] f = new int[n + 1]; f[1] = 1; for (int i = 2; i &lt;= n; i++) f[i] = f[i - 1] + f[i - 2]; return f[n];&#125; 当然，也可以直接计算，减少存储空间的浪费。 123456789101112131415161718192021222324/** * 循环做法(无数组，直接计算，无需记忆) * * 时间复杂度：O(n) * * @param n * @return */public int circleWithoutArray(int n) &#123; if (n &lt; 2) return n; int f0 = 0; int f1 = 1; int f2 = f0 + f1; for (int i = 2; i &lt;= n; i++) &#123; f2 = f0 + f1; f0 = f1; f1 = f2; &#125; return f2;&#125; 循环做法在时间复杂度上肯定是优于递归做法的。 矩阵做法参考博客。 矩阵做法需要一定的线性代数的知识，主要是矩阵的相乘，矩阵的基本性质，单位矩阵。 矩阵的基本性质回顾： 乘法结合律：(AB)C=A(BC)．乘法左分配律：(A+B)C=AC+BC乘法右分配律：C(A+B)=CA+CB对数乘的结合性：k(AB=(kA)B=A(kB)转置：(AB)T=BTAT矩阵乘法一般不满足交换律。 首先是矩阵的相乘： 123456789101112131415161718192021222324252627282930/** * 两个二阶矩阵相乘 * * 注意：只有第一个矩阵的列的个数等于第二个矩阵的行的个数，这样的两个矩阵才能相乘。 * * @param m1 * @param m2 * @return */private int[][] multiply(int[][] m1, int[][] m2) &#123; // m1c == m2r int m1r = m1.length; int m2r = m2.length; int m1c = m1[0].length; int m2c = m2[0].length; // m*p x p*n = m*n int[][] m3 = new int[m1r][m2c]; for (int i = 0; i &lt; m1r; i++) &#123; for (int j = 0; j &lt; m2c; j++) &#123; int sum = 0; for (int k = 0; k &lt; m1c; k++) &#123; sum += m1[i][k] * m2[k][j]; &#125; m3[i][j] = sum; &#125; &#125; return m3;&#125; 然后是一个矩阵的n次幂，矩阵的幂就是矩阵的连乘： 比如： 116=2*2*2*2 类比于 1A^9=A*((A^2)^2)^2) 代码的话可以这样编写： 123456789101112131415161718192021222324252627282930313233343536/** * 某一个二阶矩阵的n次快速幂 * * 例：&lt;br&gt; * 1）A^9 = A*((A^2)^2)^2) &lt;br&gt; * 2）A^15 = ((A^2)^2)^2)*((A^2)^2)*(A^2)*A * * 二分分治思想，将其由线性的转为对数的 * * @param m * @param n * @return */private int[][] pow(int[][] m, int n) &#123; int e = m.length; int[][] r = new int[e][e]; // 构建单位矩阵 for (int i = 0; i &lt; e; i++) r[i][i] = 1; while (n &gt; 1) &#123; int i = 1; int[][] s = m; while (true) &#123; int t = i &lt;&lt; 1; if (t &gt; n) break; s = multiply(s, s); i = t; &#125; n -= i; r = multiply(r, s); &#125; if (n == 1) r = multiply(r, m); return r;&#125; 接下来就是斐波那契数列递推公式的推导过程了： 数列的递推公式为：f(1)=1，f(2)=2，f(n)=f(n-1)+f(n-2) (n&gt;=3) 用矩阵表示为： 进一步，可以得出直接推导公式： 由于矩阵乘法满足结合律，在程序中可以事先给定矩阵的64，32，16，8，4，2，1次方，加快程序的执行时间。给定的矩阵次幂，与二进制有关是因为，如下的公式存在解，满足Xi={0或1}： 为了保证解满足 Xi={0或1}，对上述公式的求解从右向左，即求解顺序为Xn,Xn-1,Xn-2,….,X1,X0。 公式做个概括就是如下： 有了公式，再结合上面的矩阵运算的方法，可以很轻松的写出代码： 1234567891011121314151617/** * 矩阵做法，根据矩阵运算公式即可，计算无误差。 * * 时间复杂度：O(logn) * * @param n * @return */public int matrix(int n) &#123; if (n &lt; 2) return n; int[][] m = &#123; &#123; 1, 1 &#125;, &#123; 1, 0 &#125; &#125;; int[][] f = &#123; &#123; 1 &#125;, &#123; 0 &#125; &#125;; int[][] r = multiply(pow(m, n - 1), f); return r[0][0];&#125; 使用矩阵的n次快速幂，可以使得计算由线性而升高一个纬度，转为对数计算，计算时间大大减少。 算法的时间复杂度为O(n)=logn。 公式做法公式的推导过程可以参考百度百科，目前有三种证明方法，分别是初等代数下的利用待定系数法构造等比数列的两种方法和利用线性代数中矩阵特征方程求解。 值得注意的是公式本身是正确的，而在于计算机在计算根号和除法时可能会有误差。 这里粘上特征方程证明法： 123456789101112131415161718/** * 公式做法，通项公式，推导可以参考百度百科；&lt;br&gt; * 注意：公式本身没有误差，但是计算会有一定的误差。 * * 时间复杂度：O(1) * * @param n * @return */public int formula(int n) &#123; if (n &lt; 2) return n; double sqrt5 = Math.sqrt(5); double phi = (1 + sqrt5) / 2.0; Double fn = (Math.pow(phi, n) - Math.pow(1 - phi, n)) / sqrt5; return fn.intValue();&#125; 测试结果先贴上完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197/** * 求解斐波那契数列，仅为算法演示，不考虑溢出和其他特殊情况 * * @author Chain * */class Fibonacci &#123; /** * 递归做法，递归图是一个树形结构 * * 时间复杂度：O(2^n) * * @param n * @return */ public int recursion(int n) &#123; if (n &lt; 2) return n; return recursion(n - 1) + recursion(n - 2); &#125; /** * 循环做法(借助数组，可以用于打印前n个元素) * * 时间复杂度：O(n) * * @param n * @return */ public int circle(int n) &#123; if (n &lt; 2) return n; int[] f = new int[n + 1]; f[1] = 1; for (int i = 2; i &lt;= n; i++) f[i] = f[i - 1] + f[i - 2]; return f[n]; &#125; /** * 循环做法(无数组，直接计算，无需记忆) * * 时间复杂度：O(n) * * @param n * @return */ public int circleWithoutArray(int n) &#123; if (n &lt; 2) return n; int f0 = 0; int f1 = 1; int f2 = f0 + f1; for (int i = 2; i &lt;= n; i++) &#123; f2 = f0 + f1; f0 = f1; f1 = f2; &#125; return f2; &#125; /** * 公式做法，通项公式，推导可以参考百度百科；&lt;br&gt; * 注意：公式本身没有误差，但是计算会有一定的误差。 * * 时间复杂度：O(1) * * @param n * @return */ public int formula(int n) &#123; if (n &lt; 2) return n; double sqrt5 = Math.sqrt(5); double phi = (1 + sqrt5) / 2.0; Double fn = (Math.pow(phi, n) - Math.pow(1 - phi, n)) / sqrt5; return fn.intValue(); &#125; /** * 矩阵做法，根据矩阵运算公式即可，计算无误差。 * * 时间复杂度：O(logn) * * @param n * @return */ public int matrix(int n) &#123; if (n &lt; 2) return n; int[][] m = &#123; &#123; 1, 1 &#125;, &#123; 1, 0 &#125; &#125;; int[][] f = &#123; &#123; 1 &#125;, &#123; 0 &#125; &#125;; int[][] r = multiply(pow(m, n - 1), f); return r[0][0]; &#125; /** * 两个二阶矩阵相乘 * * 注意：只有第一个矩阵的列的个数等于第二个矩阵的行的个数，这样的两个矩阵才能相乘。 * * @param m1 * @param m2 * @return */ private int[][] multiply(int[][] m1, int[][] m2) &#123; // m1c == m2r int m1r = m1.length; int m2r = m2.length; int m1c = m1[0].length; int m2c = m2[0].length; // m*p x p*n = m*n int[][] m3 = new int[m1r][m2c]; for (int i = 0; i &lt; m1r; i++) &#123; for (int j = 0; j &lt; m2c; j++) &#123; int sum = 0; for (int k = 0; k &lt; m1c; k++) &#123; sum += m1[i][k] * m2[k][j]; &#125; m3[i][j] = sum; &#125; &#125; return m3; &#125; /** * 某一个二阶矩阵的n次快速幂 * * 例：&lt;br&gt; * 1）A^9 = A*((A^2)^2)^2) &lt;br&gt; * 2）A^15 = ((A^2)^2)^2)*((A^2)^2)*(A^2)*A * * 二分分治思想，将其由线性的转为对数的 * * @param m * @param n * @return */ private int[][] pow(int[][] m, int n) &#123; int e = m.length; int[][] r = new int[e][e]; // 构建单位矩阵 for (int i = 0; i &lt; e; i++) r[i][i] = 1; while (n &gt; 1) &#123; int i = 1; int[][] s = m; while (true) &#123; int t = i &lt;&lt; 1; if (t &gt; n) break; s = multiply(s, s); i = t; &#125; n -= i; r = multiply(r, s); &#125; if (n == 1) r = multiply(r, m); return r; &#125; // 打印二维数组 private void print(int[][] m) &#123; int r = m.length; int c = m[0].length; for (int i = 0; i &lt; r; i++) &#123; for (int j = 0; j &lt; c; j++) &#123; System.out.print(m[i][j] + " "); &#125; System.out.println(); &#125; &#125; public static void main(String[] args) &#123; Fibonacci f = new Fibonacci(); int[][] m1 = &#123; &#123; 3, 4, 2 &#125;, &#123; 5, 4, 3 &#125; &#125;; int[][] m2 = &#123; &#123; 5, 2, 1, 8 &#125;, &#123; 4, 3, 1, 9 &#125;, &#123; 5, 3, 4, 6 &#125; &#125;; int[][] m3 = f.multiply(m1, m2); int[][] m4 = &#123; &#123; 1, 1 &#125;, &#123; 1, 0 &#125; &#125;; int[][] m5 = f.pow(m4, 3); f.print(m3); f.print(m5); &#125;&#125; 再贴上测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class FibonacciTest &#123; private static Fibonacci fibonacci = new Fibonacci(); public static void main(String[] args) &#123; Random rand = new Random(); int n = rand.nextInt(100); n = 10; System.out.println("n is " + n); long start = System.currentTimeMillis(); test1(n); long step1 = System.currentTimeMillis(); test2(n); long step2 = System.currentTimeMillis(); test3(n); long step3 = System.currentTimeMillis(); test4(n); long step4 = System.currentTimeMillis(); test5(n); long step5 = System.currentTimeMillis(); System.out.println("test1 is " + (step1 - start)); System.out.println("test2 is " + (step2 - step1)); System.out.println("test3 is " + (step3 - step2)); System.out.println("test4 is " + (step4 - step3)); System.out.println("test5 is " + (step5 - step4)); &#125; private static void test1(int n) &#123; int r = fibonacci.recursion(n); System.out.println("recursion：" + r); &#125; private static void test2(int n) &#123; int r = fibonacci.circle(n); System.out.println("circle：" + r); &#125; private static void test3(int n) &#123; int r = fibonacci.circleWithoutArray(n); System.out.println("circleWithoutArray：" + r); &#125; private static void test4(int n) &#123; int r = fibonacci.matrix(n); System.out.println("matrix：" + r); &#125; private static void test5(int n) &#123; int r = fibonacci.formula(n); System.out.println("formula：" + r); &#125;&#125; 测试结果： 分别测试在n比较小情况下，和n比较大的情况下的测试结果。 1234567891011121314当n=10时：n is 10recursion：55circle：55circleWithoutArray：55matrix：55formula：55test1 is 0test2 is 0test3 is 0test4 is 0test5 is 0当n较大时，递归几乎无法计算。 文末总结斐波那契数列经典但也时编程的基本功题目。同时，它也能体现很多编程的技巧和算法的思想，比如理解递归，包含动态规划和分治的思想。 具体的经典变形比如：跳台阶，矩形覆盖（参见《剑指Offer》）。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[酷狗校招-买橙子]]></title>
    <url>%2F2017%2F09%2F27-kugou-school-test1%2F</url>
    <content type="text"><![CDATA[酷狗校招-买橙子酷狗的校招题目有点怪，和网易的有点像，编程题也少。好像只有一题编程题吧，在此也记录下，没有测试，所以代码可能不是正确的。 考试题目不得不说，QQ的识别文字功能真的很强大。 小明去附近的水果店买橙子,水果商贩只提供整袋购买,有每袋6个和每袋8个的包装(包装不可拆分)。可是小明只想购买恰好n个橙子，并且尽量少的袋数方便携带。如果不能购买恰好n个橙子,小明将不会购买。 请根据此实现一个程序。 要求：输入一个整数n,表示小明想购买n(1s n s 100)个苹果输出一个整数表示最少需要购买的袋数，如果不能买恰好n个橙子则输出- 1 例如：输入20，输出3。 我的解决直接上代码吧，暴力法。 大袋子由多至少，小袋子由少至多。 123456789101112131415161718192021222324252627282930313233343536373839404142package com.chain.blog.test.day06;import java.util.Scanner;public class BuyFruitTest &#123; public static void main(String[] args) &#123; try (Scanner in = new Scanner(System.in)) &#123; int min = test(in); System.out.println(min); &#125; &#125; private static final int M = 3; private static final int N = 4; private static int test(Scanner in) &#123; int n = in.nextInt(); if (n &lt; 1 || n &gt; 100 || n % 2 != 0) &#123; return -1; &#125; n &gt;&gt;= 1; int min = -1; int topN = n / N; for (int i = topN; i &gt;= 0; i--) &#123; int leftM = n - i * N; int topM = leftM / M; for (int j = 0; j &lt;= topM; j++) &#123; int r = M * j + N * i; if (r == n) &#123; int t = i + j; if (t &lt; min || min == -1) min = t; &#125; &#125; &#125; return min; &#125;&#125; 测试结果 输入：20 输出：3 其他答案可以参考牛客网上的解答。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
        <tag>求职</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划（Java）]]></title>
    <url>%2F2017%2F09%2F27-java-fullpack-dp%2F</url>
    <content type="text"><![CDATA[动态规划（Java）动态规划是经典的算法问题，也是常考问题。而背包问题又是其经典的例子，动态规划主要在于递推方程的建立。 背包问题主要分为01背包，完全背包，多重背包。 这里将分别研究这三种类型，也结合了一些别人的博客，并争取用通俗易懂的方式来解释下。 2017年09月27日，备注：目前只完成01背包问题的整理。 背景（仅仅是为便于理解算法） 小偷窃入一家金店，发现有若干种金子，每种金子的重量不一样，不同质量的金子的价值也不一样。可能是轻的价值高，有的确实是重的价值高。小偷的书包容量能承受的重量有限，问如何装配才能使所掠走的金子价值最大？ 01背包 给定N种物品和一个已知容量的背包。物品i的重量是Wi，其价值位Vi ，背包的容量为C。现在每种物品有且只有一个。问应该如何选择装入背包的物品，才能使装入背包的物品的总价值最大？ 背景分析1）首先最关键的一点是，01背包是指装入的物品要么全装入要么全不装入，或者也可以理解为每种物品只有一个。 2）动态规划与分治法类似，都是把大问题拆分成小问题，通过寻找大问题与小问题的递推关系，解决一个个小问题，最终达到解决原问题的效果。但不同的是，分治法在子问题和子子问题等上被重复计算了很多次，而动态规划则具有记忆性，通过填写表把所有已经解决的子问题答案纪录下来，在新问题里需要用到的子问题可以直接提取，避免了重复计算，从而节约了时间，所以在问题满足最优性原理之后，用动态规划解决问题的核心就在于填表，表填写完毕，最优解也就找到。 3）动态规划如果要求得最优解，则第i步的之前所有i-1步的结果是最优的。即局部最优到整体最优。 4）用蛮力法（暴力循环）也是可以解决此类问题，蛮力法可以解决大多数的算法问题，但是对于数量较大时的问题解决耗时太长。动态规划效率为线性，蛮力法效率为指数型。 递推方程使用V(i,j)来表示放入i个物品，已有重量为j时的总价值。 分析将物品放入背包的过程，存在以下的情况： 1）如果背包的剩余重量已经不足以放的下第i个物品，那么有： V(i,j)=V(i-1,j)。 2）如果背包的剩余重量能够放入第i个物品，那么此时可以选择放入这个物品，也可以选择不放入这个物品。 此时有： a）如果放入了这个物品，那么此时的书包内的物品总价值为没有放入这个物品之前i-1个物品的总价值加上这个物品的价值，即： V(i,j)=V(i-1,j-Wi)+Vi b）如果没有放入这个物品，那么此时的书包内的物品总价值不变： V(i,j)=V(i-1,j) 实现过程首先建立如下的表： 背包的最大的容量为10。 已知物品的重量和价值，求解在不同的背包容量下的背包中能存放的最大价值和具体的物品。 为什么要求解最大容量为1~9的情况呢？因为可以根据这些之前的情况来回溯求得最大时的所放的具体物品。 如果不需要回溯求解的话，那么使用一维数组直接求解容量为10时的最大就行了。 这里的填表时是从左向右，从下向上。当然也可以从左向右，从上向下。 表中填写的值是背包中的最大价值。 填完表后的情况如下： 下面选择几个来讲解一下： i）单元格E5的值。背包的总容量（最大承受重量）为2。如果不用上面的递推规则，则手动观察可以有：物品名为c,d,e的重量均大于2，所以一个都不能放入，能放入的价值总和为0；如果使用上面的递推规则：放入第i个物品，超出书包的剩余容量，所以V(i,j)=V(i-1,j)，而V(i-1,j)为0，所以此时V(i,j)=0； ii）单元格K3的值。背包的总容量（最大承受重量）为8。如果不用上面的递推规则，则手动观察可以有：最大的价值是a,b,e，有W(X1,X2,X5)=2+2+4=8，V(X1,X2,X5)=6+3+6=15；如果使用上面的递推规则：放入第i个物品，可以未超过书包的剩余容量， 所以有两种情况：a) 第i个物品放入，第i个物品为a，则V(i,j)=V(i-1,j-Wi)+Vi=V(i-1,8-2)+6=V(5-1,6)+6=V(4,6)+6=9+6=15；b) 第i个物品未放入，则V(i,j)=V(i-1,j)=9；两者取最大，则V(i,j)=15。 有了上面的表格，也能轻松找到总容量最大的情况。那么怎么找到容量最大时的具体装包方案呢？或者任意方案的具体安排？ 这里采用另一个博客的截图，能更好的说明这个解决方法，不过填表方式是从上而下，从左到右： 根据填表的递归方程可以有如下的寻解方式： 1） V(i,j)=V(i-1,j)时，说明没有选择第i个商品，则回到V(i-1,j)； 2） V(i,j)=V(i-1,j-w(i))+v(i)时，说明装了第i个商品，该商品是最优解组成的一部分，随后我们得回溯到装该商品之前，即回到V(i-1,j-w(i))； 3） 一直遍历到i＝0结束为止，所有解的组成都会找到。 如上例子， 1） 最优解为V(4,8)=10，而V(4,8)!=V(3,8)却有V(4,8)=V(3,8-w(4))+v(4)=V(3,3)+6=4+6=10，所以第4件商品被选中，并且回溯到V(3,8-w(4))=V(3,3)； 2） 有V(3,3)=V(2,3)=4，所以第3件商品没被选择，回溯到V(2,3)； 3） 而V(2,3)!=V(1,3)却有V(2,3)=V(1,3-w(2))+v(2)=V(1,0)+4=0+4=4，所以第2件商品被选中，并且回溯到V(1,3-w(2))=V(1,0)； 4） 有V(1,0)=V(0,0)=0，所以第1件商品没被选择； 现在再来看看本文的例子，挑选一个M3，为15。1）V(5,10)=15 != V(4,10)=11 ，却有 V(5,10)=V(4,10-W5)+V5=V(4,8)+6=15，所以a被选中，并回溯到V(4,8)；2）V(4,8)=9 != V(3,8)=6，却有 V(4,8)=V(3,8-W4)+V4=V(3,6)+3=6+3=9，所以b被选中，并回溯到V(3,6)；3) V(3,6)=6 == V(2,6)=6，继续回溯到V(2,6)；4）V(2,6)=6 == V(1,6)=6，继续回溯到V(1,6)；5）V(1,6)已经到底，所以e被选中。所以最后的具体放置方案是：15=6+3+6，即abe。 具体代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package com.chain.blog.test.day05;import java.util.ArrayList;import java.util.List;import java.util.Scanner;public class FullPackTest &#123; public static void main(String[] args) &#123; test1(); &#125; private static int m; private static int n; private static int[] w; private static int[] v; private static int[][] t; private static void test1() &#123; try (Scanner in = new Scanner(System.in)) &#123; // 背包的最大承受质量 m = in.nextInt(); // 物品的数量 n = in.nextInt(); // 物品的重量 w = new int[n]; // 物品的价值 v = new int[n]; for (int i = 0; i &lt; n; i++) &#123; w[i] = in.nextInt(); &#125; for (int i = 0; i &lt; n; i++) &#123; v[i] = in.nextInt(); &#125; t = new int[n][m]; process(); print(); detail(); &#125; &#125; private static void detail() &#123; // 在背包最大可承载质量下的最大可装载的价值为有上角的值 int maxValue = t[0][m - 1]; List&lt;Integer&gt; maxDetail = new ArrayList&lt;&gt;(); road(maxDetail, 0, m - 1); System.out.println("the bag max value: " + maxValue); System.out.println("the bag now weight: " + sum(maxDetail)); System.out.println("the detail: " + maxDetail); &#125; private static long sum(List&lt;Integer&gt; list) &#123; long sum = 0; for (Integer i : list) &#123; sum += w[i - 1]; &#125; return sum; &#125; private static void road(List&lt;Integer&gt; list, int i, int j) &#123; while (true) &#123; if (V(i, j) == 0) return; if (V(i + 1, j) != V(i, j)) break; else i++; &#125; list.add(i + 1); road(list, i + 1, j - w[i]); &#125; private static void process() &#123; for (int j = 0; j &lt; m; j++) &#123; // j+1即是书包承受的最大重量 for (int i = n - 1; i &gt; -1; i--) &#123; if (w[i] &gt; j + 1) &#123; t[i][j] = V(i + 1, j); &#125; else &#123; int nput = V(i + 1, j); int put = V(i + 1, j - w[i]) + v[i]; t[i][j] = nput &gt; put ? nput : put; &#125; &#125; &#125; &#125; private static int V(int i, int j) &#123; if (i &lt; 0 || j &lt; 0 || i &gt; n - 1 || j &gt; m - 1) return 0; return t[i][j]; &#125; private static void print() &#123; System.out.print("序号\t重量\t价值\t"); for (int i = 1; i &lt;= m; i++) &#123; System.out.print(i + "\t"); &#125; System.out.println(); for (int i = 0; i &lt; n; i++) &#123; System.out.print((i + 1) + "\t"); System.out.print(w[i] + "\t"); System.out.print(v[i] + "\t"); for (int j = 0; j &lt; m; j++) &#123; System.out.print(t[i][j] + "\t"); &#125; System.out.println(); &#125; System.out.println(); &#125;&#125; 测试结果两个测试结果： 12345678910111213842 3 4 53 4 5 6序号 重量 价值 1 2 3 4 5 6 7 8 1 2 3 0 3 4 5 7 8 9 10 2 3 4 0 0 4 5 6 6 9 10 3 4 5 0 0 0 5 6 6 6 6 4 5 6 0 0 0 0 6 6 6 6 the bag max value: 10the bag now weight: 8the detail: [2, 4] 12345678910111213141052 2 6 5 46 3 5 4 6序号 重量 价值 1 2 3 4 5 6 7 8 9 10 1 2 6 0 6 6 9 9 12 12 15 15 15 2 2 3 0 3 3 6 6 9 9 9 10 11 3 6 5 0 0 0 6 6 6 6 6 10 11 4 5 4 0 0 0 6 6 6 6 6 10 10 5 4 6 0 0 0 6 6 6 6 6 6 6 the bag max value: 15the bag now weight: 8the detail: [1, 2, 5] 补充说明可以使用一维数组来代替二维数组，在空间上能得到压缩，但是相应的如果需要输出最大价值时的具体放法就没法做到了。二维数组可以输出具体的组合。 _常见的经典算法概念（摘自软考书）： 递归法：递归法是指一个过程或函数在其定义或说明中又直接或间接调用自身的一种方法。在使用递归策略时，必须有一个明确的递归结束条件（边界），称为递归出口。在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。 递归次数过多容易造成栈溢出。 场合1: 数据的定义是按递归定义的(Fibonacci 函数)。场合2: 问题解法按递归算法实现(回溯)。场合3: 数据的结构形式是按递归定义的(树的遍历，图的搜索)。 两个步骤：分析递归关系，得出递推式；再确定最终终止条件，防止出现无限栈调用。 分治法：对于一个规模为n的问题，若该问题可以容易地解决(如说规模n较小)则可以直接解决；否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。 问题规模缩小到一定的程度就可以容易地解决，可以分解为若干个规模较小的相同问题，利用该问题分解出的子问题的解可以合并为该问题的解；该问题所分解出的各个子问题是相互独立的。 三个步骤：分解问题成小问题；找出小问题的解决方法；每次小问题解决后，逐渐合并，再利用相同的解决方法解决，最终解决原问题。 动态规划法：这种算法也用到了分治思想，它的做法是将问题实例分解为更小、相似的子问题，并存储子问题的解而避免计算重复的子问题。 动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其他的算法。 两个步骤：将问题划分成几种情况（阶段），找出每个情况下的状态方程；循环或递归的利用方程解决问题。 贪心算法：它是一种不追求最优解，只希望得到较为满意解的方法。贪心算法一般可以快速得到满意的解，因为它省去了为找到最优解而穷尽所有可能所必须耗费的大量时间。贪心算法常以当前情况为基础做最优选择，而不考虑各种可能的整体情况，所以贪心算法不要回溯。 这类问题一般具有两个重要的性质：贪心选择性质，最优子结构性质。 贪心法经典应用有背包问题、活动安排问题等。 一般采用自顶而下的方法，分阶段进行，每个阶段选择最好的方案，采用“有好处就占着”的贪心策略。 三个步骤：从问题的某一个满足条件的初始解出发；循环求解，每次求出可行解的其中一个最好解；将所有的解组合成问题的一个解。 回溯算法(试探法)：它是一种系统地搜索问题的解的方法。回溯算法的基本思想是: 从一条路往前走，能进则进，不能进则退回来，换一条路再试。其实现一般要用到递归和堆栈。 回溯是递归的一个特例，但它又有别于一般的递归法，用回翻法解题的一个显著特征是在搜索过程中动态产生问题的解空间。在任何时刻，算法只保存从根结点到当前扩展结点的路径。 经典应用有迷官搜索、N皇后问题，骑土巡游、正则表达式匹配等。 回溯一般伴随着约束条件。 三个步骤：定义问题的解空间；确定易于搜索的解空间结构；以深度优先的方式搜索解空间，并注意剪枝。 以上算法中的分治法和动态规划法通常要用到回溯算法，而回溯算法又一般要用到递归，只有贪心算法与递归联系最弱。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[艺龙校招-逃脱神凛幻域]]></title>
    <url>%2F2017%2F09%2F26-yilong-school-test1%2F</url>
    <content type="text"><![CDATA[艺龙校招-逃脱神凛幻域做了艺龙的在线笔试，题目难度不大，两道编程题都AC了，哈哈。这里贴一下最后一道题目。 最后一道题目主要在于理解题意，理解好后就容易多了。 考试题目不得不说，QQ的识别文字功能真的很强大。 逃脱神凛幻域 时间限制:C/C++ 语言1000MS ;其他语言3000MS内存限制:C/C++ 语言65536KB ;其他语言589824KB 题目描述：受到小人的设计，主人公暮小云落入一个名叫神凛幻域的奇特地方。对于迷失在这里的人而言这个空间没有绝对的方向，想要脱离这个地方就必须向前走出n步。由于在这个空间内没有方向的概念，无论何时向任何方向迈出一步都是等效的(哪怕你是原地转圈，只要走出N步即可脱离幻境)。不过，由于空间壁垒的原因，不同时刻向不同方向走所耗费的体力不同。现在已知不同时刻向某个方向跨出一步所需要耗费的体力，请你告诉暮小云怎么走最省体力，以及需要耗费的最小体力。 输入：有多个输入样例，输入的第一行是样例个数T(1&lt;= T &lt;= 50)。每个样例的第一行是一个整数n(1&lt; = n &lt; = 100000)。紧接着是四行，依次表示东南西北四个方向的体力耗费情况，每行n个数字，分别表示第n步向该方向走需要花费的体力值xi(0 &lt;= xi &lt;= 1000000)。某一步的多个方向体力值均为最小值时按照东南西北的顺序取优先方向。 输出：第一行输出需要的最小体力值。第二行输出行走方案分别用符号ESWN表示东南西北。 我的解决直接上代码吧。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.chain.blog.test.day04;import java.util.Scanner;public class MainTest &#123; public static void main(String[] args) &#123; test1(); &#125; private static void test1() &#123; Scanner in = null; try &#123; in = new Scanner(System.in); int n = in.nextInt(); for (int i = 0; i &lt; n; i++) &#123; process(in); &#125; &#125; finally &#123; in.close(); &#125; &#125; private static final int E = 0; private static final int S = 1; private static final int W = 2; private static final int N = 3; private static void process(Scanner in) &#123; int n = in.nextInt(); int[][] t = new int[n][4]; // 矩阵的转置 for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; t[j][i] = in.nextInt(); &#125; &#125; long cost = 0; StringBuffer sb = new StringBuffer(); // 找出每行的最小值的下标的模值 for (int i = 0; i &lt; n; i++) &#123; int min = 0; for (int j = 0; j &lt; 4; j++) &#123; if (t[i][j] &lt; t[i][min]) min = j; &#125; int r = min % 4; cost += t[i][min]; switch (r) &#123; case E: sb.append("E"); break; case S: sb.append("S"); break; case W: sb.append("W"); break; case N: sb.append("N"); break; &#125; &#125; System.out.println(cost); System.out.println(sb.toString()); &#125;&#125; 测试结果 输入：141 10 100 1000100 10 1000 110 10 10 1050 5 15 55 输出：17ENWS 其他答案可以参考牛客网上的解答。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
        <tag>求职</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring的事务提交和回滚]]></title>
    <url>%2F2017%2F09%2F26-java-spring-transaction-and-rollback%2F</url>
    <content type="text"><![CDATA[Spring的事务提交和回滚Spring是很多框架的大管家，凭借精巧的结构而整合了很多其他框架。常见的比如SSH、SSM等都用Spring作为“管家”。 AOP和IOC是Spring的灵魂所在，这里主要讨论的是Spring的事务，事务的提交和回滚也是面试常问的问题。 这两天整理了一下一些不错的博客，了解一下Spring的事务提交和回滚的基本知识和使用。 什么是事务先讲一个日常生活中最常做的事（尽管现在移动支付很火热）：取钱。 比如去ATM机取1000块钱，大体有两个步骤：1） 首先输入密码，然后输入取款金额1000，接着银行数据库里你的银行卡扣掉1000元；2） 最后ATM吐出1000元纸币。 这两个步骤必须是要么都执行要么都不执行。 如果银行卡扣除了1000块但是ATM出钱失败的话，你将会损失1000元；如果银行卡扣钱失败但是ATM却出了1000块，那么银行将损失1000元。 所以，如果一个步骤成功另一个步骤失败对双方都不是好事，如果不管哪一个步骤失败了以后，整个取钱过程都能回滚，也就是完全取消所有操作的话，这对双方都是没有问题的。 所以，就诞生了事务。事务（Transaction）就是用来解决类似问题的。 事务是一系列的动作，它们综合在一起才是一个完整的工作单元，这些动作必须全部完成，如果有一个失败的话，那么事务就会回滚到最开始的状态，仿佛什么都没发生过一样。 在企业级应用程序开发中，事务管理必不可少的技术，用来确保数据的完整性和一致性。 核心接口Spring事务管理的实现有许多细节，如果对整个接口框架有个大体了解会非常有利于我们理解事务，下面通过讲解Spring的事务接口来了解Spring实现事务的具体策略。 Spring事务管理涉及的接口的联系如下： 具体的实现关系如下： Spring所有的事务管理策略类都继承自org.springframework.transaction.PlatformTransactionManager接口。 PlatformTransactionManager： 12345678public interface PlatformTransactionManager &#123; TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException; void commit(TransactionStatus status) throws TransactionException; void rollback(TransactionStatus status) throws TransactionException;&#125; Spring提供了这个接口，交由具体的数据源如HibernateTransactionManager实现具体事务的提交(commit)和回滚(rollback)操作。 具体可以参看上面的实现关系图。 实现方式Spring支持编程式事务管理和声明式事务管理两种方式。 也有人认为有五种方式，其实是具体实现的方式的不同，大致可以分为以上两种。 五种方式分别为：第一种方式：每个Bean都有一个代理；第二种方式：所有Bean共享一个代理基类；第三种方式：使用拦截器；第四种方式：使用tx标签配置的拦截器；第五种方式：使用注解。 具体配置的方法参考。 编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，Spring推荐使用TransactionTemplate。 声明式事务管理建立在AOP之上的，其本质是对方法前后进行拦截（也可以理解为代理）。在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。 声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式)，便可以将事务规则应用到业务逻辑中。 显然声明式事务管理要优于编程式事务管理，这也正是Spring倡导的非侵入式的开发方式。 声明式事务管理使业务代码不受污染，一个普通的POJO对象，只要加上注解就可以获得完全的事务支持。和编程式事务相比，声明式事务唯一不足地方是，后者的最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。但是即便有这样的需求，也存在很多变通的方法，比如，可以将需要进行事务管理的代码块独立为方法等等。 声明式事务管理的两种常用的声明方式具体指的是：一种是基于tx和aop名字空间的xml配置文件；另一种就是基于@Transactional注解。 显然基于注解的方式更简单易用，更清爽。 事务特性在PlatfromTransactionManager中，又使用了TransactionDefinition接口和TransactionStatus接口中定义的属性。 这两个接口又包含了事务属性如隔离规则、回滚规则，传播行为，事务超时与只读。 接下来详细的看一下接口内容具体表示的意义： TransactionDefinition接口 事务隔离规则隔离级别是指若干个并发的事务之间的隔离程度。 TransactionDefinition 接口中定义了五个表示隔离级别的常量： 12345TransactionDefinition.ISOLATION_DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATION_READ_COMMITTED。TransactionDefinition.ISOLATION_READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。比如PostgreSQL实际上并没有此级别。TransactionDefinition.ISOLATION_READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。TransactionDefinition.ISOLATION_REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读。TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 接着还有一个表格能归纳一下上面的关系。 这里再补充一些概念： ACID： ACID，指数据库事务正确执行的四个基本要素的缩写。包含： 原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。 一个支持事务（Transaction）的数据库，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性，交易过程极可能达不到交易方的要求。 1）原子性整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 2）一致性一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。也就是说：如果事务是并发多个，系统也必须如同串行事务一样操作。其主要特征是保护性和不变性(Preserving an Invariant)，以转账案例为例，假设有五个账户，每个账户余额是100元，那么五个账户总额是500元，如果在这个5个账户之间同时发生多个转账，无论并发多少个，比如在A与B账户之间转账5元，在C与D账户之间转账10元，在B与E之间转账15元，五个账户总额也应该还是500元，这就是保护性和不变性。 3）隔离性隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。 4）持久性在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。由于一项操作通常会包含许多子操作，而这些子操作可能会因为硬件的损坏或其他因素产生问题，要正确实现ACID并不容易。ACID建议数据库将所有需要更新以及修改的资料一次操作完毕，但实际上并不可行。 目前主要有两种方式实现ACID：第一种是Write ahead logging，也就是日志式的方式(现代数据库均基于这种方式)。第二种是Shadow paging。 相对于WAL（Write ahead logging）技术，Shadow paging技术实现起来比较简单，消除了写日志记录的开销恢复的速度也快(不需要redo和undo)。Shadow paging的缺点就是事务提交时要输出多个块，这使得提交的开销很大，而且以块为单位，很难应用到允许多个事务并发执行的情况——这是它致命的缺点。 WAL的中心思想是对数据文件的修改（它们是表和索引的载体）必须是只能发生在这些修改已经记录了日志之后。也就是说，在日志记录冲刷到永久存储器之后。如果我们遵循这个过程，那么我们就不需要在每次事务提交的时候都把数据页冲刷到磁盘，因为我们知道在出现崩溃的情况下，我们可以用日志来恢复数据库。任何尚未附加到数据页的记录都将先从日志记录中重做（这叫向前滚动恢复，也叫做REDO），然后那些未提交的事务做的修改将被从数据页中删除 （这叫向后滚动恢复-UNDO）。 脏读、幻读、不可重复读： 1）脏读：脏读又称无效数据读出。一个事务读取另外一个事务还没有提交的数据叫脏读。例如：事务T1修改了一行数据，但是还没有提交，这时候事务T2读取了被事务T1修改后的数据，之后事务T1因为某种原因Rollback了，那么事务T2读取的数据就是脏的。 解决办法：把数据库的事务隔离级别调整到READ_COMMITTED 2）不可重复读：不可重复读是指在同一个事务内，两个相同的查询返回了不同的结果。例如：事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。 解决办法：把数据库的事务隔离级别调整到REPEATABLE_READ 3）幻读：例如：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样。这就叫幻读。 解决办法：把数据库的事务隔离级别调整到SERIALIZABLE_READ 脏读、不可重复读、幻读的级别高低是：脏读 &lt; 不可重复读 &lt; 幻读。 所以，设置了最高级别的SERIALIZABLE_READ就不用在设置REPEATABLE_READ和READ_COMMITTED了 事务传播行为所谓事务的传播行为（propagation behavior）是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。 在TransactionDefinition定义中包括了如下几个表示传播行为的常量： 1234567TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。 PROPAGATION_NESTED 与PROPAGATION_REQUIRES_NEW的区别: 1）两者比较类似,都是嵌套事务，且如果不存在一个活动的事务，都会开启一个新的事务。2）使用PROPAGATION_REQUIRES_NEW时，内层事务与外层事务就像两个独立的事务一样，一旦内层事务进行了提交后，外层事务不能对其进行回滚；换言之，两个事务之间互不影响。两个事务不是一个真正的嵌套事务。同时它需要JTA事务管理器的支持。类似的解释：PROPAGATION_REQUIRES_NEW 启动一个新的, 不依赖于环境的 “内部” 事务。这个事务可以独立的 commit 或 rollback 而不需要依赖于外部事务。 它拥有自己的隔离范围, 自己的锁, 等等。当内部事务开始执行时, 外部事务将被挂起；内务事务结束时, 外部事务将继续执行。3）使用PROPAGATION_NESTED时，外层事务的回滚可以引起内层事务的回滚。而内层事务的异常并不会导致外层事务的回滚，可能某一步出错但不影响整个事务的推进。即可以跳过这个内层事务继续推进。它是一个真正的嵌套事务。类似的解释：PROPAGATION_NESTED 开始一个 “嵌套的” 事务，它是已经存在事务的一个真正的子事务。嵌套事务开始执行时，它将取得一个savepoint。如果这个嵌套事务失败, 我们将回滚到此 savepoint，而不会继续推进事务，可以选择重试或者再手动放弃整个事务。嵌套事务是外部事务的一部分，只有外部事务结束后它才会被提交。DataSourceTransactionManager使用savepoint支持PROPAGATION_NESTED时，需要JDBC 3.0以上驱动及1.4以上的JDK版本支持。其它的JTA TrasactionManager实现可能有不同的支持方式。 由此可见, PROPAGATION_REQUIRES_NEW 和 PROPAGATION_NESTED 的最大区别在于： PROPAGATION_REQUIRES_NEW 完全是一个新的事务, 而 PROPAGATION_NESTED 则是外部事务的子事务。 PROPAGATION_REQUIRED是常用的事务传播行为，它能够满足我们大多数的事务需求。 事务的超时所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。 这样做的主要目的在于防止事务占用数据库时间太长。 在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。 默认设置为底层事务系统的超时值，如果底层数据库事务系统没有设置超时值，那么就是none，没有超时限制。 事务只读属性只读事务用于客户代码只读但不修改数据的情形，只读事务用于特定情景下的优化，比如使用Hibernate的时候。 默认为读写事务。 注意：“只读事务”并不是一个强制选项，它只是一个“暗示”，提示数据库驱动程序和数据库系统，这个事务并不包含更改数据的操作，那么JDBC驱动程序和数据库就有可能根据这种情况对该事务进行一些特定的优化，比方说不安排相应的数据库锁，以减轻事务对数据库的压力，毕竟事务也是要消耗数据库的资源的。 但是你非要在“只读事务”里面修改数据，也并非不可以，只不过对于数据一致性的保护不像“读写事务”那样保险而已。 因此，“只读事务”仅仅是一个性能优化的推荐配置而已，并非强制你要这样做不可。 事务回滚规则要使得Spring事务管理器能够回滚一个事务的推荐方法是： 在当前事务的上下文内抛出异常。 Spring事务管理器会捕捉任何未处理(unchecked)的异常(如RuntimeException)，然后依据事先配置好的规则决定是否回滚这个抛出异常的事务。 默认配置下，Spring只有在抛出的异常为运行时unchecked异常时才回滚该事务，也就是抛出的异常为RuntimeException的子类(Errors也会导致事务回滚)，而抛出checked异常则不会导致事务回滚。 但是可以明确的配置在抛出那些异常时回滚事务，这样就包括checked异常。同理，也可以明确定义那些异常抛出时不回滚事务。 还可以编程性的通过静态方法setRollbackOnly()方法来指示一个事务必须回滚，在调用完setRollbackOnly()后你所能执行的唯一操作就是回滚。 TransactionStatus接口上面讲到的调用PlatformTransactionManager接口的getTransaction()的方法得到的是TransactionStatus接口的一个实现。 这个接口的内容如下： 接口描述的是一些处理事务的过程中，提供简单的控制事务执行和查询事务状态的方法，在回滚或提交的时候需要应用对应的事务状态。 Transactional注解Transactional注解是声明式配置Spring的事务管理的一种方式，也是比较灵活的一种配置方式。 该注解的属性如下： 注解用法与注意事项: @Transactional 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。 虽然 @Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， @Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。 默认情况下，只有来自外部的方法调用才会被AOP代理捕获。也就是，类内部方法调用本类内部的其他方法并不会引起事务行为，即使被调用方法使用@Transactional注解进行修饰。 参考博客1、Spring事务管理（详解+实例）2、Spring事务机制详解3、spring事务配置]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>转载</tag>
        <tag>学习</tag>
        <tag>知识点</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中hashCode、equals、toString方法]]></title>
    <url>%2F2017%2F09%2F25-java-hashcode-equals%2F</url>
    <content type="text"><![CDATA[Java中hashCode、equals、toString方法这三个方法是Object类中的方法，换句话说是所有的类都会具有的方法。但是这三个方法对初学者来说一直有迷惑性，面试中也常被问到。现在整理一下，也写一写自己的理解。 Object中的这三个方法在Jdk中，所有的类的共同根父类Object.class中，这三个方法是这样定义的： 12345678910111213public class Object&#123; public native int hashCode(); public boolean equals(Object obj) &#123; return (this == obj); &#125; public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode()); &#125;&#125; 下面一一说明这三个方法： 1）toString： toString()在Object中的默认实现其实是打印出这个类的名称和这个对象实例的hash值。比如下面的结果： java.lang.Object@15db9742 在一些其他的类中，往往会重写这个方法，比如ArrayList的toString就是打印内部存储的数组。 重写toString的方法往往是为了便于调试，即在debug模式下能够很方便的看到一个对象的内部属性情况，当然也可以用System.out.println()打印输出。 ArrayList的toString()方法由父类AbstractList的父类AbstractCollection实现。 AbstractCollection.toString()： 123456789101112131415public String toString() &#123; Iterator&lt;E&gt; it = iterator(); if (! it.hasNext()) return "[]"; StringBuilder sb = new StringBuilder(); sb.append('['); for (;;) &#123; E e = it.next(); sb.append(e == this ? "(this Collection)" : e); if (! it.hasNext()) return sb.append(']').toString(); sb.append(',').append(' '); &#125;&#125; 2）equals： Object类中的默认equals()方法是对象之间使用“==”比较。默认的“==”是比较对象的内存引用。 所以默认的equals方法比较的是两个对象的内存引用是否相等。 但是，在开发或其他的类库中，比较对象的内存引用其实没有什么太大的意义，所以有很多类又会重写equals方法。 3）hashCode： Object类中的hashCode的实现是由JVM实现的，这是一个native方法。 查阅相关资料和结合API文档可以得知： hashCode方法可以这样理解： 首先JVM将对象存放的位置分为几块，或者叫几个“桶”，然后每一个新new出来的对象会先计算其在JVM内存中的“位置”，然后再根据这个“位置”放在合适的“桶”中。 为什么JVM要这样做呢？ 如果形象一点理解的话，可以有这样的情景： 假如要查找一个学校的某一个学生，怎样查找更快呢？是拿着点名簿从上往下一个一个找，还是先获得该学生的学号（hash值），再根据学号判断是哪个班级，接着再根据其他信息能直接定位到具体的这个学生，不用再遍历学生的信息表。 比如我的学校的某个学生的学号为：208140123，可以判断他所在的年级是14届，班级是01班，班内序号是23，这样能很快的定位到学生。 像HashSet、HashMap等都是利用hash的典型类库。 equals详解再来看看equals的方法： 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 其用法是obj1.equals(obj2)，顾名思义是比较两个对象是否相等。 那么两个对象相等具体是什么意思，换句话说什么是相等的对象？ API中有这样一段话（已翻译）： 123456789A 对称性（symmetric）：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。B 反射性（reflexive）：x.equals(x)必须返回是“true”。C 类推性（transitive）：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。D 一致性（consistent）：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。E 任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。 也就是说除非特殊需求，判断两个对象是否相等需要遵循以上的规则。 Object中的equals只有“==”，但是却完全符合上面的那个规则，是不是感觉很神奇。 下面写一个Person类，来方便理解。绝大数代码可以直接由Eclipse或者Idea生成，而且是正确的。 Person.java： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.chain.blog.test.day07;public class Person &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; StringBuilder builder = new StringBuilder(); builder.append("Person [name=").append(name).append(", age=").append(age).append("]"); return builder.toString(); &#125; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public Person() &#123; super(); &#125; @Override public int hashCode() &#123; // 初始化一个素数 final int prime = 31; // 初始化结果 int result = 1; result = prime * result + age; result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; &#125; // 需要满足对称性、反射性、类推性、一致性、和null总为false @Override public boolean equals(Object obj) &#123; // 反射性 if (this == obj) return true; // 和null进行比较 if (obj == null) return false; // 实例的类不相同的肯定不相等 // 如果有父类的话，需要使用父类的equals方法进行比较 if (getClass() != obj.getClass()) return false; Person other = (Person) obj; // 对象成员的具体比较，可以根据业务自行定制 if (age != other.age) return false; // 和null的比较 if (name == null) &#123; if (other.name != null) return false; &#125; // 调用成员对象的equals方法进行比较 else if (!name.equals(other.name)) return false; return true; &#125;&#125; 接下来再测试一下： 1234567891011121314151617181920212223242526272829private static void test3() &#123; Person peter = new Person("peter", 22); Person jack = new Person("jack", 21); Person peteralso = new Person("peter", 22); Person peteralso2 = new Person("peter", 22); // 对象通过“==”比较 System.out.println(peter == peter); System.out.println(peter == jack); System.out.println(peter == peteralso); System.out.println(peteralso == peter); System.out.println(peteralso == peteralso2); System.out.println(); // 反射性 System.out.println(peter.equals(peter)); // 对称性 System.out.println(peter.equals(jack)); System.out.println(jack.equals(peter)); // 对称性 System.out.println(peteralso.equals(peter)); // 类推性 System.out.println(peter.equals(peteralso)); System.out.println(peteralso.equals(peteralso2)); System.out.println(peter.equals(peteralso2)); // 和null总为false System.out.println(peter.equals(null));&#125; 测试结果： 1234567891011121314truefalsefalsefalsefalsetruefalsefalsetruetruetruetruefalse 由上可以基本掌握equals的用法。 hashCode的详解前面讲到hash的基本作用是为了便于快速查找。 那么hash还有其他作用吗？ Java中有一个很重要的集合类：HashSet。 Set具有确定性、互异性、无序性这三大特性。 HashSet的底层是由HashMap来实现。 先来看看HashSet.put()方法： 123public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; API文档中描述的是如果添加的元素重复（已存在）那么将这个待添加的元素被丢弃并返回false。 那么如何判断要添加的元素是否重复（也可以理解为已存在）呢？ 接着看看HashMap的put方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 有源码可以看出，一个新增add元素的大致过程：1）先计算对象的hash值2）判断hash表中这个对象的hash值对应的位置是否由元素， a) 如果没有元素，则添加上去，并返回； b) 如果有元素，则接着判断equals方法， i) 如果equals方法不想等，那么添加这个元素到这个hash所在位置链接的红黑树中； ii) 如果equals方法相等，那么可以判断元素重复添加，不执行添加操作且返回已存在的那个值。 由此也可以看出hashCode和equals方法的大致关系，后面再讲。 那么hash在查找get元素上的作用，删除remove元素上的作用呢？ 可以阅读源码发现和add的作用是类似的。 hashCode和equalshashCode和equals可谓是难兄难弟，需要“捆绑”在一起使用和修改。 前面已经知道，像HashSet之类在添加和删除元素时都需要先判断hashCode，然后再判断equals。 先使用hash一是为了快速找到元素，防止遍历查找，二是为了能大致先预判判断元素是否相等。 如果两个对象连hashCode都不相等，那么肯定不是相等的对象，也就不用再进一步判断equals了。 换句话说，如果两个对象不想等，那么hashCode可能相等也可能不想等。 所以如果对象需要修改equals方法的话，也要修改hashCode方法，否则将起不到预期的作用。 比如Person中，如果不重写hashCode方法，只是重写了equals方法，那么如果将Person添加到HashSet集合中时将会在先调用hashCode时返回不相等。这样就会出现peter和peteralso，乃至peteralso2都添加进了Set中。因为这三者都是不同的对象实例，所以hashCode都不一样的可能性很高。 所以应该谨慎对待hashCode和equals方法。 补充例子下面再来一个例子，更好的说明hashCode和equals方法： 1234567891011121314151617181920212223242526272829303132333435private static void test4() &#123; HashSet&lt;Person&gt; list = new HashSet&lt;&gt;(); Person p1 = new Person("p1", 22); Person p2 = new Person("p2", 23); Person p3 = new Person("p1", 22); Person p4 = new Person("p4", 25); Person p5 = new Person("p5", 26); list.add(p1); list.add(p2); list.add(p3); list.add(p4); list.add(p5); System.out.println(list.size()); System.out.println(list); list.remove(new Person("p5", 26)); System.out.println(list.size()); System.out.println(list); p2.setName("p2_x"); list.remove(new Person("p2", 23)); System.out.println(list.size()); System.out.println(list); list.remove(p2); System.out.println(list.size()); System.out.println(list);&#125; 猜一猜结果是什么？ 是不是这个： 123456784[Person [name=p1, age=22], Person [name=p2, age=23], Person [name=p4, age=25], Person [name=p5, age=26]]3[Person [name=p1, age=22], Person [name=p2, age=23], Person [name=p4, age=25]]2[Person [name=p1, age=22], Person [name=p4, age=25]]2[Person [name=p1, age=22], Person [name=p4, age=25]] 其实正确的是这个： 123456784[Person [name=p1, age=22], Person [name=p2, age=23], Person [name=p4, age=25], Person [name=p5, age=26]]3[Person [name=p1, age=22], Person [name=p2, age=23], Person [name=p4, age=25]]3[Person [name=p1, age=22], Person [name=p2_x, age=23], Person [name=p4, age=25]]3[Person [name=p1, age=22], Person [name=p2_x, age=23], Person [name=p4, age=25]] 这个是为什么呢？ 因为修改了p2的name属性后，这个对象的hash和equals都已经发生了改变。 首先hash已经改变，因为hash计算中name参与其中。 而HashSet在数据添加时，对象的位置已经根据对象自己的hash值添加到合适的位置。 而调用了remove方法时，remove方法会先计算要删除元素o的hash值，然后再根据这个hash值去已经成型的hash表中查找。而元素已经改变，因而很有可能是找不到这个元素的，就算找到了也有可能会出现误删。因此要么删除失败，要么就是误删除。 这是一个大坑，所以当使用HashSet之类时，要注意添加进Set的元素的hashCode值不能再改变了。同理equals的结果也一样，不然会违反一致性的要求。 当然hashCode和equals还有其他注意事项，以后继续学习再补充吧。 越是简单的东西有时却越是复杂。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发和学习中积累的常用工具类]]></title>
    <url>%2F2017%2F09%2F23-chain-utils%2F</url>
    <content type="text"><![CDATA[开发和学习中积累的常用工具类在开发和学习中，往往有很多方法会重复编写，也会碰到一些比较好的工具类。我选择其中一些并将它们整理、优化、完善，打成jar包，方便日后使用。 本工具类名称：chain-utils 查看GitHub源码 点击下载历史版本 点击下载最新版 点击下载文档 如果您在使用中存在问题，或者有改进建议，欢迎留言或提出Issues。 注：1、jar包内包含源码，使用时建议使用最新的JDK。2、根据具体情况，有的类可以通过new和getInstance方式获得实例后使用方法，有的也可以直接使用静态方法。3、对于异常处理，均会做log，且作为一个工具类，异常均会继续往上层抛出，但会选择对异常做适当的重新包装以减少纷繁的各种checked exception。 更新jar包：1、点击上面的下载链接。2、在命令行界面输入 java -jar chain-utils-xxxx.jar 就会自动下载最新版到当前目录。3、双击jar包运行就会自动下载最新版到当前目录。 版本信息： version window.onload=function(){ $("#util_version").empty().load('https://raw.githubusercontent.com/ChainGit/chain-utils/master/Chain-Utils/web/latest/version_web.txt'); $("#util_history").empty().load('https://raw.githubusercontent.com/ChainGit/chain-utils/master/Chain-Utils/web/latest/history.txt'); }]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL练习-学生表]]></title>
    <url>%2F2017%2F09%2F23-sql-test-student%2F</url>
    <content type="text"><![CDATA[SQL练习-学生表做面试题做到一道关于学生表的操作，原先有过一些学习，后来又总是断断续续的用起又遗忘，还是要多加练习的。 虽然学生表看着简单，没什么复杂的数据库表关系，但是对SQL的编写的要求却是千变万化，可以有很多变体。 这道面试题的确包含了SQL中不少注意事项，自己也有遗忘，唉。 SQL语句还是要多练习才行。 2017年9月23日更新：增加表的转置。 2017年9月28日更新：完善第一题。 基本表和数据这是一张普通的学生表，包含以下数据： 12345678910111213141516171819mysql&gt; select name,lesson,score from t_stu;+----+--------+--------+-------+| id | name | lesson | score |+----+--------+--------+-------+| 1 | 小明 | 语文 | 80 || 2 | 小明 | 数学 | 50 || 3 | 小明 | 英语 | 90 || 4 | 小刚 | 语文 | 70 || 5 | 小刚 | 英语 | 85 || 6 | 小刚 | 数学 | 90 || 7 | 小强 | 语文 | 85 || 8 | 小强 | 数学 | 80 || 9 | 小强 | 英语 | 70 || 10 | 小芳 | 语文 | 60 || 11 | 小芳 | 数学 | 50 || 12 | 小芳 | 英语 | 70 |+----+--------+--------+-------+12 rows in set (0.00 sec) 各种不同情景1、找出所有不挂科（不包含60分）的学生的姓名、学科、成绩。 划重点：找出所有___不挂科（不包含60分）_的学生的姓名、学科、成绩__。 需要实现三个功能，两种实现方式： 1） 使用子查询： 12345678910111213mysql&gt; select name,lesson,score from t_stu where name in (select t.name from (select name,count(*) as jg from t_stu where score&gt;60 group by name having jg=3) as t) order by name,lesson;+--------+--------+-------+| name | lesson | score |+--------+--------+-------+| 小刚 | 数学 | 90 || 小刚 | 英语 | 85 || 小刚 | 语文 | 70 || 小强 | 数学 | 80 || 小强 | 英语 | 70 || 小强 | 语文 | 85 |+--------+--------+-------+6 rows in set (0.00 sec) 2）使用连接查询（能避免使用in）： 12345678910111213mysql&gt; select s.name,s.lesson,s.score from t_stu s inner join (select name,count(*) as jg from t_stu where score&gt;60 group by name having jg=3) as t on s.name=t.name order by name,lesson;+--------+--------+-------+| name | lesson | score |+--------+--------+-------+| 小刚 | 数学 | 90 || 小刚 | 英语 | 85 || 小刚 | 语文 | 70 || 小强 | 数学 | 80 || 小强 | 英语 | 70 || 小强 | 语文 | 85 |+--------+--------+-------+6 rows in set (0.00 sec) 3）更准确的方法： （2017年9月28日更新） 增加科目，使得每个人的科目数量不一致。 数据表更新后如下： 123456789101112131415161718192021mysql&gt; select * from t_stu;+----+--------+--------+-------+| id | name | lesson | score |+----+--------+--------+-------+| 1 | 小明 | 语文 | 80 || 2 | 小明 | 数学 | 50 || 3 | 小明 | 英语 | 90 || 4 | 小刚 | 语文 | 70 || 5 | 小刚 | 英语 | 85 || 6 | 小刚 | 数学 | 90 || 7 | 小强 | 语文 | 85 || 8 | 小强 | 数学 | 80 || 9 | 小强 | 英语 | 70 || 10 | 小芳 | 语文 | 60 || 11 | 小芳 | 数学 | 50 || 12 | 小芳 | 英语 | 70 || 13 | 小芳 | 物理 | 80 || 14 | 小刚 | 物理 | 50 |+----+--------+--------+-------+14 rows in set (0.00 sec) 小刚和小芳分别增加了两行新数据，对应新科目“物理”。 首先使用sum和count的两种方法，注意这两种方法的差别。 1234567891011mysql&gt; select s.name,count(*) as xk,sum(s.score&gt;60) as jg from t_stu s group by name;+--------+----+------+| name | xk | jg |+--------+----+------+| 小刚 | 4 | 3 || 小强 | 3 | 3 || 小明 | 3 | 2 || 小芳 | 4 | 2 |+--------+----+------+4 rows in set (0.00 sec) 然后再加上剩余的部分： 12345678mysql&gt; select s.name,count(*) as xk,sum(s.score&gt;60) as jg from t_stu s group by name having xk=jg;+--------+----+------+| name | xk | jg |+--------+----+------+| 小强 | 3 | 3 |+--------+----+------+1 row in set (0.00 sec) 这样就可以再完善结合一下，就有以下结果： 12345678910mysql&gt; select s.name,s.lesson,s.score from t_stu s inner join (select name,count(*) as xk,sum(score&gt;60) as jg from t_stu group by name having xk=jg) as t on s.name=t.name order by name,lesson;+--------+--------+-------+| name | lesson | score |+--------+--------+-------+| 小强 | 数学 | 80 || 小强 | 英语 | 70 || 小强 | 语文 | 85 |+--------+--------+-------+3 rows in set (0.00 sec) 比方法一、二要更完善。 2、找出所有平均分超过80的学生姓名、平均分。 划重点：找出所有___平均分超过80___的学生姓名、平均分。 要先过滤掉有不及格的同学，因为考虑以下情况： 12380*3=240240-60=180180/2=90 如果是平均分超过90的同学，则无需过滤掉有不及格的同学，因为： 12390*3=270270-60=210210/2=105 将第一题的语句结合起来写，有以下两种实现方式： 1）使用子查询： 12345678mysql&gt; select t.name,t.pj pinjun from (select name,count(*) as jg,avg(score) as pj from t_stu where score&gt;60 group by name having jg=3 and pj&gt;80) as t order by t.name;+--------+---------+| name | pinjun |+--------+---------+| 小刚 | 81.6667 |+--------+---------+1 row in set (0.00 sec) 2）使用连接查询： 其实如果不查询具体的信息的话那么连接查询也没什么太大的必要。 3、实现数据表的转置（翻转） 这个确实有难度了，查阅相关资料后总结下两个方法。 1）手动使用连接 先来看几个分开的sql： i) 找出姓名 1select name from t_stu group by name order by name; ii) 找出某一科的成绩 1select name,score from t_stu where lesson='语文'; 然后将上面的结合起来，可以有下面的语句： 1234567891011121314151617181920212223mysql&gt; SELECT s.name AS '姓名', yw.score AS '语文', sx.score AS '数学', yy.score AS '英语'FROM t_stu s LEFT JOIN (SELECT name, score FROM t_stu WHERE lesson = '语文' ) yw ON yw.name = s.name LEFT JOIN (SELECT name, score FROM t_stu WHERE lesson = '数学' ) sx ON sx.name = s.name LEFT JOIN (SELECT name, score FROM t_stu WHERE lesson = '英语' ) yy ON yy.name = s.nameGROUP BY s.nameORDER BY s.name;+--------+--------+--------+--------+| 姓名 | 语文 | 数学 | 英语 |+--------+--------+--------+--------+| 小刚 | 70 | 90 | 85 || 小强 | 85 | 80 | 70 || 小明 | 80 | 50 | 90 || 小芳 | 60 | 50 | 70 |+--------+--------+--------+--------+4 rows in set (0.00 sec) 2) 使用case完成 基于这个博客 使用的sql语句为： 1234567891011mysql&gt; select name '姓名',max(case lesson when '语文' then score end) '语文',max(case lesson when '数学' then score end) '数学',max(case lesson when '英语' then score end) '英语' from t_stu group by name order by name;+--------+--------+--------+--------+| 姓名 | 语文 | 数学 | 英语 |+--------+--------+--------+--------+| 小刚 | 70 | 90 | 85 || 小强 | 85 | 80 | 70 || 小明 | 80 | 50 | 90 || 小芳 | 60 | 50 | 70 |+--------+--------+--------+--------+4 rows in set (0.00 sec) 当然还有其他的实现方式，这里就不介绍了。 总结SQL要多加练习，多加练习，多加练习。重要的事情说三遍！！！ 写这个题目时，也提醒了我应该乘着大四的剩余时光学习下MySQL的常用优化和SQL优化。加油！]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java实现自定义排序二叉树]]></title>
    <url>%2F2017%2F09%2F22-java-sorted-binary-tree%2F</url>
    <content type="text"><![CDATA[Java实现自定义排序二叉树二叉树一直是数据结构中重头，这里我实现了二叉排序树（又叫二叉搜索树，二叉查找树，BST），和二叉树的前序遍历，中序遍历，后序遍历，层次遍历，镜像二叉树。 二叉查找树(Binary Search Tree)，它对于大多数情况下的查找和插入在效率上来说是没有问题的，但是它在最差的情况下效率比较低。平衡查找树(Balanced Search Tree)能够使得一棵具有N个节点的树中，该树的高度能够维持在lgN左右，这样就能保证只需要lgN次比较操作就可以查找到想要的值，比如AVL树、2-3查找树(2-3 Search Tree)、红黑树、B树、B+树、B*树、Trie树（字典树）等。 树的演变很多，应用也很广泛。 集合框架源码。 2017年9月21日，更新：增加查找二叉排序树中最接近k的节点的值。 2017年9月22日，更新：增加二叉树的删除节点。 2017年9月23日，更新：增加镜像二叉树。 2017年9月30日，更新：增加二叉树遍历的循环做法，镜像二叉树的循环做法。 二叉树的抽象类二叉树的抽象类如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.chain.algorithm.test.day01;import java.util.List;public abstract class AbstractBinaryTree&lt;T&gt; implements BinaryTreeInter&lt;T&gt; &#123; /** * 构建排序二叉树 * */ public abstract void add(T node); /** * 删除二叉树的节点 * * @return */ public abstract boolean delete(T value); public abstract int size(); public abstract boolean isEmpty(); public abstract void clear(); /** * 广度优先遍历 * */ public abstract List&lt;T&gt; bfsToList(); /** * 中序遍历 * * @return */ public abstract List&lt;T&gt; inOrderToList(); /** * 前序遍历 * * @return */ public abstract List&lt;T&gt; preOrderToList(); /** * 后序遍历 * * @return */ public abstract List&lt;T&gt; postOrderToList(); /** * 中序遍历(循环) * * @return */ public abstract List&lt;T&gt; inOrderLoopToList(); /** * 前序遍历(循环) * * @return */ public abstract List&lt;T&gt; preOrderLoopToList(); /** * 后序遍历(循环) * * @return */ public abstract List&lt;T&gt; postOrderLoopToList();&#125; 二叉树的接口BinaryTreeInterface：123456789101112131415package com.chain.algorithm.test.day01;public interface BinaryTreeInter&lt;T&gt; &#123; /** * 镜像二叉树 */ public void mirror(); /** * 镜像二叉树(循环) */ public void mirrorLoop();&#125; 排序二叉树的实现内部包含一个树节点的内部类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490package com.chain.algorithm.test.day01;import java.util.ArrayList;import java.util.HashMap;import java.util.LinkedList;import java.util.List;import java.util.Map;/** * 二叉树 * * @author Chain * * @param &lt;T&gt; */public class BinaryTree&lt;T&gt; extends AbstractBinaryTree&lt;T&gt; implements BinaryTreeInter&lt;T&gt; &#123; private BinaryTreeNode&lt;T&gt; rootNode; private int count; /** * 构建排序二叉树 * */ @Override public void add(T value) &#123; if (rootNode == null) &#123; rootNode = new BinaryTreeNode&lt;&gt;(value); count++; return; &#125; BinaryTreeNode&lt;T&gt; node = new BinaryTreeNode&lt;&gt;(value); BinaryTreeNode&lt;T&gt; currentNode = rootNode; BinaryTreeNode&lt;T&gt; lastNode = currentNode; boolean flag = true; while (currentNode != null) &#123; lastNode = currentNode; if (currentNode.compareTo(node) &gt;= 0) &#123; currentNode = currentNode.getLeft(); flag = true; &#125; else &#123; currentNode = currentNode.getRight(); flag = false; &#125; &#125; if (currentNode == null) &#123; if (flag) &#123; lastNode.setLeft(node); &#125; else &#123; lastNode.setRight(node); &#125; &#125; count++; &#125; @Override public int size() &#123; return count; &#125; @Override public boolean isEmpty() &#123; if (rootNode == null) return true; return false; // return count == 0; &#125; @Override public void clear() &#123; rootNode = null; count = 0; &#125; /** * 广度优先遍历 * */ @Override public List&lt;T&gt; bfsToList() &#123; List&lt;T&gt; lst = new ArrayList&lt;&gt;(); if (isEmpty()) return lst; AbstractQueue&lt;BinaryTreeNode&lt;T&gt;&gt; queue = new LinkedQueue&lt;&gt;(); // AbstractQueue&lt;BinaryTreeNode&lt;T&gt;&gt; queue = new ArrayQueue&lt;&gt;(); queue.push(rootNode); getLeftAndRightThenPushToQueue(lst, queue); return lst; &#125; private void getLeftAndRightThenPushToQueue(List&lt;T&gt; lst, AbstractQueue&lt;BinaryTreeNode&lt;T&gt;&gt; queue) &#123; int size = size(); for (int i = 0; i &lt; size; i++) &#123; BinaryTreeNode&lt;T&gt; parentNode = queue.pull(); lst.add(parentNode.getValue()); BinaryTreeNode&lt;T&gt; leftNode = parentNode.getLeft(); BinaryTreeNode&lt;T&gt; rightNode = parentNode.getRight(); if (leftNode != null) queue.push(leftNode); if (rightNode != null) queue.push(rightNode); &#125; if (!queue.isEmpty()) getLeftAndRightThenPushToQueue(lst, queue); &#125; protected static class BinaryTreeNode&lt;T&gt; implements Comparable&lt;BinaryTreeNode&lt;T&gt;&gt; &#123; private T value; private BinaryTreeNode&lt;T&gt; left; private BinaryTreeNode&lt;T&gt; right; public BinaryTreeNode(T value) &#123; super(); this.value = value; &#125; public T getValue() &#123; return value; &#125; public void setValue(T value) &#123; this.value = value; &#125; public BinaryTreeNode&lt;T&gt; getLeft() &#123; return left; &#125; public void setLeft(BinaryTreeNode&lt;T&gt; left) &#123; this.left = left; &#125; public BinaryTreeNode&lt;T&gt; getRight() &#123; return right; &#125; public void setRight(BinaryTreeNode&lt;T&gt; right) &#123; this.right = right; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + ((value == null) ? 0 : value.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (obj == this) return true; if (obj == null) return false; if (obj.getClass() != BinaryTreeNode.class) return false; BinaryTreeNode node = (BinaryTreeNode) obj; return this.compareTo(node) == 0; &#125; @Override public int compareTo(BinaryTreeNode&lt;T&gt; other) &#123; if (other == null) throw new RuntimeException("node is null"); T otherValue = other.getValue(); if (otherValue instanceof Integer &amp;&amp; value instanceof Integer) return ((Integer) value).compareTo((Integer) otherValue); return 0; &#125; @Override public String toString() &#123; return value.toString(); &#125; &#125; @Override public List&lt;T&gt; inOrderToList() &#123; List&lt;T&gt; lst = new ArrayList&lt;&gt;(); inOrder(rootNode, lst); return lst; &#125; private void inOrder(BinaryTreeNode&lt;T&gt; node, List&lt;T&gt; lst) &#123; if (node == null) return; inOrder(node.getLeft(), lst); lst.add(node.getValue()); inOrder(node.getRight(), lst); &#125; @Override public List&lt;T&gt; preOrderToList() &#123; List&lt;T&gt; lst = new ArrayList&lt;&gt;(); preOrder(rootNode, lst); return lst; &#125; private void preOrder(BinaryTreeNode&lt;T&gt; node, List&lt;T&gt; lst) &#123; if (node == null) return; lst.add(node.getValue()); preOrder(node.getLeft(), lst); preOrder(node.getRight(), lst); &#125; @Override public List&lt;T&gt; postOrderToList() &#123; List&lt;T&gt; lst = new ArrayList&lt;&gt;(); postOrder(rootNode, lst); return lst; &#125; private void postOrder(BinaryTreeNode&lt;T&gt; node, List&lt;T&gt; lst) &#123; if (node == null) return; postOrder(node.getLeft(), lst); postOrder(node.getRight(), lst); lst.add(node.getValue()); &#125; @Override public boolean delete(T value) &#123; // 二叉树删除节点总共有四种情况，需要考虑进根节点 BinaryTreeNode&lt;T&gt; currentNode = rootNode; BinaryTreeNode&lt;T&gt; parentNode = rootNode; // 如果为空树 if (currentNode == null || value == null) return false; BinaryTreeNode&lt;T&gt; findNode = new BinaryTreeNode&lt;&gt;(value); // 类似插入节点，从根节点依次往下找，找到这个节点或直到为空 // 往左为true boolean flag = true; while (true) &#123; // 往左走 if (currentNode.compareTo(findNode) &gt; 0) &#123; parentNode = currentNode; currentNode = currentNode.getLeft(); flag = true; &#125; // 往右走 else if (currentNode.compareTo(findNode) &lt; 0) &#123; parentNode = currentNode; currentNode = currentNode.getRight(); flag = false; &#125; // 相等 else &#123; break; &#125; // 没有找到该节点 if (currentNode == null) &#123; return false; &#125; &#125; // System.out.println(currentNode.value); // System.out.println(parentNode.value); // 如果找到的节点为叶子节点，即没有左右孩子 if (currentNode.getLeft() == null &amp;&amp; currentNode.getRight() == null) &#123; if (currentNode == rootNode) &#123; rootNode = null; &#125; // 是父节点的左孩子 else if (flag) &#123; parentNode.setLeft(null); &#125; // 是父节点的右孩子 else if (!flag) &#123; parentNode.setRight(null); &#125; &#125; // 如果找到的节点有右孩子 else if (currentNode.getLeft() == null &amp;&amp; currentNode.getRight() != null) &#123; BinaryTreeNode&lt;T&gt; right = currentNode.getRight(); if (currentNode == rootNode) &#123; rootNode = right; &#125; else if (flag) &#123; parentNode.setLeft(right); &#125; else if (!flag) &#123; parentNode.setRight(right); &#125; &#125; // 如果找到的节点有左孩子 else if (currentNode.getLeft() != null &amp;&amp; currentNode.getRight() == null) &#123; BinaryTreeNode&lt;T&gt; left = currentNode.getLeft(); if (currentNode == rootNode) &#123; rootNode = left; &#125; else if (flag) &#123; parentNode.setLeft(left); &#125; else if (!flag) &#123; parentNode.setRight(left); &#125; &#125; // 如果找到的节点有两个孩子，找到中序后继节点 else &#123; BinaryTreeNode&lt;T&gt; successorNode = getSuccessor(currentNode); // 然后将currentNode替换成successorNode if (currentNode == rootNode) &#123; rootNode = successorNode; &#125; else if (flag) &#123; parentNode.setLeft(successorNode); &#125; else if (!flag) &#123; parentNode.setRight(successorNode); &#125; // 只可能有这种情况 successorNode.setLeft(currentNode.getLeft()); &#125; count--; return true; &#125; // 找到中序后继节点：在剩余子树中找出所有比被删除节点的值 大 的所有数，并在这些数中找出一个 最小 的数来 private BinaryTreeNode&lt;T&gt; getSuccessor(BinaryTreeNode&lt;T&gt; deleteNode) &#123; BinaryTreeNode&lt;T&gt; currentNode = deleteNode; // 右节点不为空，比要删除节点大的都在右子树 BinaryTreeNode&lt;T&gt; successorNode = currentNode.getRight(); BinaryTreeNode&lt;T&gt; successorParentNode = successorNode; while (currentNode != null) &#123; successorParentNode = successorNode; successorNode = currentNode; // 最小的节点又都在左子树 currentNode = currentNode.getLeft(); &#125; // 如果中序后继节点不是要删除的节点的右孩子 if (successorNode != deleteNode.getRight()) &#123; // 中序后继节点只可能有右孩子，将其放到中序后继的位置 successorParentNode.setLeft(successorNode.getRight()); // 中继后继的节点的右孩子（肯定存在）连接到要删除的节点的右孩子上（也肯定存在）防止出现游离状态而被回收 successorNode.setRight(deleteNode.getRight()); &#125; return successorNode; &#125; @Override public void mirror() &#123; BinaryTreeNode&lt;T&gt; currentNode = rootNode; mirrorFun(currentNode); &#125; private void mirrorFun(BinaryTreeNode&lt;T&gt; currentNode) &#123; if (currentNode == null) return; // 交换当前节点的左右孩子节点，无论是否为空 BinaryTreeNode&lt;T&gt; tempNode = currentNode.getLeft(); currentNode.setLeft(currentNode.getRight()); currentNode.setRight(tempNode); // 递归继续交换 mirrorFun(currentNode.getLeft()); mirrorFun(currentNode.getRight()); &#125; @Override public List&lt;T&gt; inOrderLoopToList() &#123; List&lt;T&gt; lst = new ArrayList&lt;&gt;(); inOrderLoop(lst); return lst; &#125; // 递归也是栈操作，那么循环做法其实是手动栈，不会存在栈溢出的问题 private void inOrderLoop(List&lt;T&gt; lst) &#123; LinkedList&lt;BinaryTreeNode&lt;T&gt;&gt; stack = new LinkedList&lt;&gt;(); BinaryTreeNode&lt;T&gt; currentNode = rootNode; while (currentNode != null || !stack.isEmpty()) &#123; if (currentNode != null) &#123; stack.push(currentNode); currentNode = currentNode.getLeft(); &#125; else &#123; currentNode = stack.pop(); lst.add(currentNode.getValue()); currentNode = currentNode.getRight(); &#125; &#125; &#125; @Override public List&lt;T&gt; preOrderLoopToList() &#123; List&lt;T&gt; lst = new ArrayList&lt;&gt;(); preOrderLoop(lst); return lst; &#125; private void preOrderLoop(List&lt;T&gt; lst) &#123; LinkedList&lt;BinaryTreeNode&lt;T&gt;&gt; stack = new LinkedList&lt;&gt;(); BinaryTreeNode&lt;T&gt; currentNode = rootNode; while (currentNode != null || !stack.isEmpty()) &#123; if (currentNode != null) &#123; stack.push(currentNode); lst.add(currentNode.getValue()); currentNode = currentNode.getLeft(); &#125; else &#123; currentNode = stack.pop(); currentNode = currentNode.getRight(); &#125; &#125; &#125; @Override public List&lt;T&gt; postOrderLoopToList() &#123; List&lt;T&gt; lst = new ArrayList&lt;&gt;(); postOrderLoop(lst); return lst; &#125; // 用于后序遍历的循环做法的标志 // 1：访问过左节点 2：访问过右节点 private static final int LEFT_VISITED = 1; // 后序遍历的情况下，如果为2则代表也访问过了左节点 private static final int RIGHT_VISITED = 2; // 后序遍历的循环做法复杂一些，需要对原来的树的节点加上访问标记 private void postOrderLoop(List&lt;T&gt; lst) &#123; LinkedList&lt;BinaryTreeNode&lt;T&gt;&gt; stack = new LinkedList&lt;&gt;(); BinaryTreeNode&lt;T&gt; currentNode = rootNode; Map&lt;BinaryTreeNode&lt;T&gt;, Integer&gt; flags = new HashMap&lt;&gt;(count); // 先访问左节点 ，再访问右节点，最后访问根节点 while (currentNode != null || !stack.isEmpty()) &#123; // 访问左节点 while (currentNode != null) &#123; stack.push(currentNode); flags.put(currentNode, LEFT_VISITED); currentNode = currentNode.getLeft(); &#125; // 左右子树均访问完毕，此时输出子树的根节点 while (!stack.isEmpty() &amp;&amp; (flags.get(stack.peek()) == RIGHT_VISITED)) &#123; BinaryTreeNode&lt;T&gt; node = stack.pop(); lst.add(node.getValue()); &#125; // 访问右节点 if (!stack.isEmpty()) &#123; currentNode = stack.peek(); flags.put(currentNode, RIGHT_VISITED); currentNode = currentNode.getRight(); &#125; &#125; &#125; // 利用自定义栈代替程序栈 @Override public void mirrorLoop() &#123; if (rootNode == null) return; LinkedList&lt;BinaryTreeNode&lt;T&gt;&gt; stack = new LinkedList&lt;&gt;(); stack.push(rootNode); BinaryTreeNode&lt;T&gt; currentNode = null; while (!stack.isEmpty()) &#123; currentNode = stack.pop(); BinaryTreeNode&lt;T&gt; tempNode = currentNode.getLeft(); currentNode.setLeft(currentNode.getRight()); currentNode.setRight(tempNode); BinaryTreeNode&lt;T&gt; leftNode = currentNode.getLeft(); if (leftNode != null) stack.push(leftNode); BinaryTreeNode&lt;T&gt; rightNode = currentNode.getRight(); if (rightNode != null) stack.push(rightNode); &#125; &#125;&#125; 测试代码2017年9月21日，更新：增加查找二叉排序树中最接近k的节点的值。 2017年9月22日，更新：增加二叉树的删除节点。 2017年9月23日，更新：增加镜像二叉树。 2017年9月30日，更新：增加二叉树遍历的循环做法，镜像二叉树的循环做法。 源码传送门 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package com.chain.algorithm.test.day01;import java.util.List;import org.junit.Test;public class TreeTest &#123; @Test public void testBinaryTree() &#123; AbstractBinaryTree&lt;Integer&gt; tree = new BinaryTree&lt;&gt;(); System.out.println(tree.size()); System.out.println(tree.isEmpty()); System.out.println(tree.bfsToList()); System.out.println(tree.preOrderToList()); System.out.println(tree.inOrderToList()); System.out.println(tree.postOrderToList()); System.out.println(tree.preOrderLoopToList()); System.out.println(tree.inOrderLoopToList()); System.out.println(tree.postOrderLoopToList()); tree.add(32); tree.add(28); tree.add(56); tree.add(14); tree.add(25); tree.add(51); tree.add(68); tree.add(78); tree.add(44); tree.add(41); tree.add(40); tree.add(42); tree.add(72); tree.add(79); System.out.println(tree.size()); System.out.println(tree.isEmpty()); System.out.println(tree.bfsToList()); System.out.println(tree.preOrderToList()); System.out.println(tree.inOrderToList()); System.out.println(tree.postOrderToList()); // 二叉树的中序遍历输出的即是已经排序好的数组 // 要求：查找二叉排序树的最接近k的节点 int k = 24; List&lt;Integer&gt; list = tree.inOrderToList(); int value = getClosest(list, k); System.out.println(value); // 测试二叉树的删除 System.out.println(tree.delete(51)); System.out.println(tree.size()); System.out.println(tree.isEmpty()); System.out.println(tree.bfsToList()); System.out.println(tree.preOrderToList()); System.out.println(tree.inOrderToList()); System.out.println(tree.postOrderToList()); // 镜像二叉树 // 由顶而上，有大到小，利用递归实现 tree.mirror(); System.out.println(tree.size()); System.out.println(tree.isEmpty()); System.out.println(tree.bfsToList()); System.out.println(tree.preOrderToList()); System.out.println(tree.inOrderToList()); System.out.println(tree.postOrderToList()); // 镜像二叉树循环做法 tree.mirrorLoop(); System.out.println(tree.size()); System.out.println(tree.isEmpty()); System.out.println(tree.bfsToList()); System.out.println(tree.preOrderToList()); System.out.println(tree.inOrderToList()); System.out.println(tree.postOrderToList()); // 树的递归的循环做法 System.out.println(); System.out.println(tree.preOrderLoopToList()); System.out.println(tree.inOrderLoopToList()); System.out.println(tree.postOrderLoopToList()); &#125; // 查找二叉排序树的最接近k的节点 private int getClosest(List&lt;Integer&gt; list, int k) &#123; int size = list.size(); for (int i = 0; i &lt; size; i++) &#123; int current = list.get(i); if (current == k) &#123; return current; &#125; else if (current &gt; k) &#123; if (i &gt; 0) &#123; int before = list.get(i - 1); int d1 = current - k; int d2 = k - before; // 如果相等的话就返回排在前面的值 return d2 &gt; d1 ? current : before; &#125; else &#123; return current; &#125; &#125; &#125; return list.get(size - 1); &#125;&#125; 测试结果：1234567891011121314151617181920212223242526272829303132333435363738390true[][][][][][][]14false[32, 28, 56, 14, 51, 68, 25, 44, 78, 41, 72, 79, 40, 42][32, 28, 14, 25, 56, 51, 44, 41, 40, 42, 68, 78, 72, 79][14, 25, 28, 32, 40, 41, 42, 44, 51, 56, 68, 72, 78, 79][25, 14, 28, 40, 42, 41, 44, 51, 72, 79, 78, 68, 56, 32]25true13false[32, 28, 56, 14, 44, 68, 25, 41, 78, 40, 42, 72, 79][32, 28, 14, 25, 56, 44, 41, 40, 42, 68, 78, 72, 79][14, 25, 28, 32, 40, 41, 42, 44, 56, 68, 72, 78, 79][25, 14, 28, 40, 42, 41, 44, 72, 79, 78, 68, 56, 32]13false[32, 56, 28, 68, 44, 14, 78, 41, 25, 79, 72, 42, 40][32, 56, 68, 78, 79, 72, 44, 41, 42, 40, 28, 14, 25][79, 78, 72, 68, 56, 44, 42, 41, 40, 32, 28, 25, 14][79, 72, 78, 68, 42, 40, 41, 44, 56, 25, 14, 28, 32]13false[32, 28, 56, 14, 44, 68, 25, 41, 78, 40, 42, 72, 79][32, 28, 14, 25, 56, 44, 41, 40, 42, 68, 78, 72, 79][14, 25, 28, 32, 40, 41, 42, 44, 56, 68, 72, 78, 79][25, 14, 28, 40, 42, 41, 44, 72, 79, 78, 68, 56, 32][32, 28, 14, 25, 56, 44, 41, 40, 42, 68, 78, 72, 79][14, 25, 28, 32, 40, 41, 42, 44, 56, 68, 72, 78, 79][25, 14, 28, 40, 42, 41, 44, 72, 79, 78, 68, 56, 32] 部分内容摘自伯乐在线。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小米校招题-名称转换]]></title>
    <url>%2F2017%2F09%2F19-xiaomi-school-test1%2F</url>
    <content type="text"><![CDATA[小米校招题-名称转换昨天尝试做了小米的在线校招题，发现使用的平台是赛码网，学校一直没有什么宣传，自己也是第一次知道这个网站。网站是很好的平台，很多公司都在上面举行在线笔试，自己也可以用来练习算法和结构，类似leetcode一样。 这次参加的是小米的服务器开发的在线笔试，题目主要是考察算法和数据结构，也是自己的短板啊。跌跌撞撞的写了一道编程题，名称转换。字符串操作其实是比较繁琐的，不像一些图论等有基本的章法，字符串题目而言，读懂题意是最关键的。 考试题目题目比较长，自己记得也比较模糊了，写个大概吧。 给定名称，将名称转为C/C++中的宏定义的格式，比如：1&gt; myHeader =&gt; _MY_HEADER_ 类名中包含“.”作为分隔符，比如1&gt; my.ABCAbc =&gt; _MY_ABC_ABC_ 类名中只会包含大小写字母和数字，且不以数字开头。 转换规则：1、在开头和结尾都添加下划线2、将“.”转换为下划线3、使用下划线将单词分割，具体如下： 1）第一个大写字母和后面的小写字母组成一个单词，如果不以大写字母开头，则连续的小写字母视为一个单词。 2）连续的大写字母视为一个单词。如果最后一个大写字母后面跟着小写字母，则最后一个大写字母不包含在内。 3） 连续的数字视为一个单词。 我的解决我的解决方案比较繁琐，也没有太多考虑性能和简洁性，用C语言直接写过程会更简练。 大致思路就是两个指针，分别指向last，current，使用substring方法一段一段的截取到List中，然后用”_”连接起来。 直接贴上代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169import java.util.ArrayList;import java.util.List;import java.util.Scanner;/** * 第一题：转为下划线且大写格式 * * @author Chain * */public class Main &#123; public static void main(String args[]) &#123; test1(); // test2(); &#125; private static void test2() &#123; Scanner in = new Scanner(System.in); String str = in.nextLine(); in.close(); int len = str.length(); List&lt;String&gt; list = new ArrayList&lt;&gt;(); process(list, str, len); String con = concat(list); List&lt;String&gt; res = new ArrayList&lt;&gt;(); if (con != null) res.add(con); printResList(res); &#125; private static void test1() &#123; Scanner in = new Scanner(System.in); while (in.hasNext()) &#123; String str = in.nextLine(); int len = str.length(); if (len &lt; 1) continue; List&lt;String&gt; list = new ArrayList&lt;&gt;(); process(list, str, len); String con = concat(list); System.out.println(con); &#125; in.close(); &#125; private static void printResList(List&lt;String&gt; res) &#123; if (res == null || res.size() &lt; 1) return; for (String s : res) &#123; System.out.println(s); &#125; &#125; private static final String CONCAT = "_"; private static String concat(List&lt;String&gt; list) &#123; StringBuffer sb = new StringBuffer(); sb.append(CONCAT); if (list != null) &#123; int size = list.size(); for (int i = 0; i &lt; size; i++) &#123; String str = list.get(i); str = str.replaceAll("[^a-zA-Z0-9]", ""); str = str.toUpperCase(); if (str.length() &gt; 0) &#123; sb.append(str); sb.append(CONCAT); &#125; &#125; &#125; return sb.toString(); &#125; private static int current = 0; private static int last = current; private static void process(List&lt;String&gt; list, String str, int len) &#123; if (list == null) return; current = 0; last = current; while (current &lt; len) &#123; char[] chs = str.toCharArray(); findJumpPoint(chs, len); String part = getPart(str); list.add(part); str = str.substring(current); len = str.length(); current = 0; last = current; // System.out.println(str); &#125; &#125; private static String getPart(String str) &#123; String subStr = str.substring(last, current); last = current; return subStr; &#125; private static void findJumpPoint(char[] chs, int len) &#123; while ((++current) &lt; len) &#123; int before = chs[current - 1]; int now = chs[current]; int typeBefore = getType(before); int typeNow = getType(now); if (typeBefore != typeNow) &#123; int res = getCutPoint(chs, typeBefore, typeNow); if (res != -1) &#123; current = res; break; &#125; &#125; &#125; &#125; private static int getCutPoint(char[] chs, int typeBefore, int typeNow) &#123; if (typeNow == LOWER_CASE) &#123; if (typeBefore == LOWER_CASE) &#123; &#125; else if (typeBefore == UPPER_CASE) &#123; if (current - 2 &gt; -1) &#123; int beforeBefore = chs[current - 2]; if (getType(beforeBefore) == UPPER_CASE) return current - 1; &#125; return -1; &#125; else if (typeBefore == SPECIAL) &#123; &#125; &#125; else if (typeNow == UPPER_CASE) &#123; if (typeBefore == LOWER_CASE) &#123; &#125; else if (typeBefore == UPPER_CASE) &#123; &#125; else if (typeBefore == SPECIAL) &#123; &#125; &#125; else if (typeNow == SPECIAL) &#123; if (typeBefore == LOWER_CASE) &#123; &#125; else if (typeBefore == UPPER_CASE) &#123; &#125; else if (typeBefore == SPECIAL) &#123; &#125; &#125; return current; &#125; private static final int LOWER_CASE = 0; private static final int UPPER_CASE = 1; private static final int SPECIAL = 2; private static int getType(int p) &#123; if (p &gt; 64 &amp;&amp; p &lt; 91) return UPPER_CASE; else if (p &gt; 96 &amp;&amp; p &lt; 123) return LOWER_CASE; return SPECIAL; &#125;&#125; 测试结果输入：1234567&gt; amy.ABCmy.AbcMy.ABCAbcMY.ASTParser12My.ABCAbcABCAbcABCfoo.bar12bar13A 输出：1234567&gt; _A__MY_ABC__MY_ABC__MY_ABC_ABC__MY_AST_PARSER_12__MY_ABC_ABC_ABC_ABC_ABC__FOO_BAR_12_BAR_13_A_ 其他答案今天又发现赛码网上大牛们的解答，真的是厉害。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
        <tag>求职</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小米校招题-密码破解]]></title>
    <url>%2F2017%2F09%2F19-xiaomi-school-test2%2F</url>
    <content type="text"><![CDATA[小米校招题-密码破解这个是小米的校招题第三题，题目是密码破解。考试时间不足，没做出来，唉。结束后想了一个解决方法，当然也不是最好的解法，不过问题至少解决了。 考试题目大致如此： 已知一个字符串，包含数字。有如下对应规则：12341 -&gt; a2 -&gt; b...26 -&gt; z 现在需要求出一个字符串的所有破译的可能结果。 我的解决大致思路其实是递归。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.chain.blog.test.day03;import java.util.ArrayList;import java.util.List;import java.util.Scanner;/** * 第三题：密码破译 * * @author Chain * */public class Main &#123; public static void main(String[] args) &#123; test1(); &#125; private static void test1() &#123; Scanner in = null; try &#123; in = new Scanner(System.in); while (in.hasNext()) &#123; String str = in.nextLine(); List&lt;String&gt; list = new ArrayList&lt;&gt;(); process(list, str); printList(list); &#125; &#125; finally &#123; if (in != null) in.close(); &#125; &#125; private static void process(List&lt;String&gt; list, String str) &#123; StringBuffer sb = new StringBuffer(); bfs(list, str, sb); &#125; private static void bfs(List&lt;String&gt; list, String str, StringBuffer sb) &#123; if (str.isEmpty()) &#123; list.add(sb.toString()); sb.delete(0, sb.length()); return; &#125; char[] chs = str.toCharArray(); int first = chs[0]; sb.append(intToChar(first)); String sback = sb.toString(); if (str.length() &gt; 1) &#123; bfs(list, str.substring(1), sb); &#125; else &#123; bfs(list, EMPTY, sb); &#125; if (str.length() &lt; 2) return; sb = new StringBuffer(sback); int second = chs[1]; int len = sb.length(); sb.deleteCharAt(len - 1); char ch = intToChar(first, second); if (ch == NO) return; sb.append(ch); if (str.length() &gt; 2) &#123; bfs(list, str.substring(2), sb); &#125; else &#123; bfs(list, EMPTY, sb); &#125; &#125; private static final String EMPTY = ""; private static final char NO = '#'; private static char intToChar(int i, int j) &#123; i = i - '0'; j = j - '0'; int k = i * 10 + j; if (k &lt; 1 || k &gt; 26) return NO; k = k - 1 + 'a'; return (char) k; &#125; private static char intToChar(int i) &#123; return (char) (i - '0' - 1 + 'a'); &#125; private static void printList(List&lt;String&gt; list) &#123; int size = list.size(); for (int i = 0; i &lt; size; i++) &#123; System.out.print(list.get(i)); if (i &lt; size - 1) &#123; System.out.print(" "); &#125; &#125; System.out.println(); &#125;&#125; 测试结果 输入：112123123412345 输出：aab labc aw lcabcd awd lcdabcde awde lcde 其他答案赛码网上大牛们的解答。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
        <tag>求职</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java实现自定义队列（链表和数组两种方式）]]></title>
    <url>%2F2017%2F09%2F04-java-array-queue%2F</url>
    <content type="text"><![CDATA[Java实现自定义队列（链表和数组两种方式）队列有两种实现方式，一种是基于循环数组，一种是基于链表。在这里主要是模拟自定义的队列，实现这两种方式。 集合框架源码。 队列的抽象类一个队列，无外乎几种常见的方法，比如poll()、remove()、peek()，还有push()、last()操作。如果是双端队列，那么还有对尾元素的删除操作等。 这里实现的是单端队列。 队列抽象类：AbstractQueue：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.chain.algorithm.test.day01;import java.util.List;public abstract class AbstractQueue&lt;T&gt; &#123; /** * 将新节点加到队列末尾 * * @param value */ public abstract void push(T value); /** * 查看队列最后一个节点的值 * * @return */ public abstract T last(); /** * 获得队列的第一个节点的值，并移除第一个节点 * * @return */ public abstract T pull(); /** * 查看队列的第一个节点的值 * */ public abstract T peek(); /** * 队列是否为空 * * @return */ public abstract boolean isEmpty(); /** * 判断数组是否已满 * * @return */ public boolean isFull(); /** * * 清空队列 * */ public abstract void clear(); /** * * 队列的现有节点数 * */ public abstract int size(); /** * * 转换为List * * @return */ public abstract List&lt;T&gt; toList();&#125; 队列的扩展接口ArrayQueueInterface：12345678910111213package com.chain.algorithm.test.day01;public interface ArrayQueueInterface&lt;T&gt; &#123; /** * 扩大数组容量 * * @param old * @return */ public void extend();&#125; 队列节点元素队列中插入的具体元素类。 QueueNode：123456789101112131415161718192021222324252627282930313233343536package com.chain.algorithm.test.day01;/** * 队列的节点 * * @author Chain * * @param &lt;T&gt; */public class QueueNode&lt;T&gt; &#123; private T value; private QueueNode&lt;T&gt; nextNode; public T getValue() &#123; return value; &#125; public void setValue(T value) &#123; this.value = value; &#125; public QueueNode&lt;T&gt; getNextNode() &#123; return nextNode; &#125; public void setNextNode(QueueNode&lt;T&gt; nextNode) &#123; this.nextNode = nextNode; &#125; public QueueNode(T value) &#123; super(); this.value = value; &#125;&#125; 循环数组实现循环数组的实现主要是通过两个指针，一个是head，一个是tail，这两指针分别代表的是队列的头节点和尾节点的下一个空节点。所以总有一个位置是被空出来的。 对于队列是否空和满有两种判断方式，一种是通过head、tail和capacity的数学关系判断，一种是通过count来判断。 当然还实现了数组的扩展机制，是两倍扩展的方法。 下面分别介绍使用数学关系和count来判断的不同实现： 使用数学关系：ArrayQueue：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133package com.chain.algorithm.test.day01;import java.util.ArrayList;import java.util.List;/** * 使用数组实现循环队列 * * 判断的时候可以使用数学公式，也可以使用count来判断 ；使用数学公式有一个会浪费，使用count则可以不浪费空间 * * @author Chain * */public class ArrayQueue&lt;T&gt; extends AbstractQueue&lt;T&gt; implements ArrayQueueInterface&lt;T&gt; &#123; private Object[] data; // 不使用count也是可以的 private int count; // 指向队列的头元素所在的位置的下标 private int head; // 指向队列的尾元素所在的位置的后一个下标 private int tail; private static int capacity = 10; public ArrayQueue() &#123; super(); this.data = new Object[capacity]; &#125; @Override public void push(T value) &#123; if (isFull()) &#123; extend(); &#125; data[tail] = value; tail = (tail + 1) % capacity; count++; &#125; @Override public T last() &#123; if (isEmpty()) return null; int last = (tail + capacity - 1) % capacity; return (T) data[last]; &#125; @Override public T pull() &#123; if (isEmpty()) throw new RuntimeException("queue is empty"); T temp = (T) data[head]; data[head] = null; head = (head + 1) % capacity; count--; return temp; &#125; @Override public T peek() &#123; if (isEmpty()) return null; T temp = (T) data[head]; return temp; &#125; @Override public boolean isEmpty() &#123; // 如果head和tail重叠，则为空 if (head == tail) return true; return false; &#125; @Override public void clear() &#123; head = tail = count = 0; capacity = 10; data = new Object[capacity]; &#125; @Override public int size() &#123; int size = (capacity - (head - tail)) % capacity; return size; &#125; @Override public boolean isFull() &#123; // 假设head和tail是不重叠的，即tail和head之间空一格 if ((tail + 1) % capacity == head) return true; return false; &#125; @Override public List&lt;T&gt; toList() &#123; List&lt;T&gt; lst = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; data.length; i++) &#123; lst.add((T) data[i]); &#125; return lst; &#125; @Override public synchronized void extend() &#123; try &#123; // 方法很多，这里使用pull再push的方法 int newCapacity = capacity &lt;&lt; 1; Object[] newData = new Object[newCapacity]; int size = size(); int index = 0; while (size-- &gt; 0) &#123; newData[index++] = pull(); &#125; head = 0; tail = count = index; capacity = newCapacity; data = newData; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 使用count来判断：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126package com.chain.algorithm.test.day01;import java.util.ArrayList;import java.util.List;/** * 使用数组实现循环队列 * * 判断的时候可以使用数学公式，也可以使用count来判断 ；使用数学公式有一个会浪费，使用count则可以不浪费空间 * * @author Chain * */public class ArrayQueue2&lt;T&gt; extends AbstractQueue&lt;T&gt; implements ArrayQueueInterface&lt;T&gt; &#123; private Object[] data; // 不使用count也是可以的 private int count; // 指向队列的头元素所在的位置的下标 private int head; // 指向队列的尾元素所在的位置的后一个下标 private int tail; private static int capacity = 10; public ArrayQueue2() &#123; super(); this.data = new Object[capacity]; &#125; @Override public void push(T value) &#123; if (isFull()) &#123; extend(); &#125; data[tail] = value; tail = (tail + 1) % capacity; count++; &#125; @Override public T last() &#123; if (isEmpty()) return null; int last = (tail + capacity - 1) % capacity; return (T) data[last]; &#125; @Override public T pull() &#123; if (isEmpty()) throw new RuntimeException("queue is empty"); T temp = (T) data[head]; data[head] = null; head = (head + 1) % capacity; count--; return temp; &#125; @Override public T peek() &#123; if (isEmpty()) return null; T temp = (T) data[head]; return temp; &#125; @Override public boolean isEmpty() &#123; return size() == 0; &#125; @Override public void clear() &#123; head = tail = count = 0; capacity = 10; data = new Object[capacity]; &#125; @Override public int size() &#123; return count; &#125; @Override public boolean isFull() &#123; return size() == capacity; &#125; @Override public List&lt;T&gt; toList() &#123; List&lt;T&gt; lst = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; data.length; i++) &#123; lst.add((T) data[i]); &#125; return lst; &#125; @Override public synchronized void extend() &#123; try &#123; // 方法很多，这里使用pull再push的方法 int newCapacity = capacity &lt;&lt; 1; Object[] newData = new Object[newCapacity]; int size = size(); int index = 0; while (size-- &gt; 0) &#123; newData[index++] = pull(); &#125; head = 0; tail = count = index; capacity = newCapacity; data = newData; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 使用链表实现链表实现就相对数组而言容易多了，不需要数组扩容的方法。 LinkedQueue：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149package com.chain.algorithm.test.day01;import java.util.ArrayList;import java.util.List;/** * 基于链表的队列 * * @author Chain * */public class LinkedQueue&lt;T&gt; extends AbstractQueue&lt;T&gt; &#123; private QueueNode&lt;T&gt; headNode; private int count; public LinkedQueue() &#123; super(); headNode = new QueueNode&lt;&gt;(null); &#125; /** * 将新节点加到队列末尾 * * @param value */ @Override public void push(T value) &#123; QueueNode&lt;T&gt; node = new QueueNode&lt;&gt;(value); QueueNode&lt;T&gt; currentNode = headNode; QueueNode&lt;T&gt; lastNode = currentNode; while (currentNode != null) &#123; lastNode = currentNode; currentNode = currentNode.getNextNode(); &#125; lastNode.setNextNode(node); count++; &#125; /** * 查看队列最后一个节点的值 * * @return */ @Override public T last() &#123; QueueNode&lt;T&gt; currentNode = headNode; QueueNode&lt;T&gt; lastNode = currentNode; while (currentNode != null) &#123; lastNode = currentNode; currentNode = currentNode.getNextNode(); &#125; return lastNode.getValue(); &#125; /** * 获得队列的第一个节点的值，并移除第一个节点 * * @return */ @Override public T pull() &#123; if (isEmpty()) &#123; throw new RuntimeException("queue is empty"); &#125; QueueNode&lt;T&gt; nextNode = headNode.getNextNode(); T val = nextNode.getValue(); QueueNode&lt;T&gt; nextNextNode = nextNode.getNextNode(); if (nextNextNode == null) headNode.setNextNode(null); else headNode.setNextNode(nextNextNode); count--; return val; &#125; /** * 查看队列的第一个节点的值 * */ @Override public T peek() &#123; if (isEmpty()) &#123; return null; &#125; QueueNode&lt;T&gt; nextNode = headNode.getNextNode(); T val = nextNode.getValue(); return val; &#125; /** * 队列是否为空 * * @return */ @Override public boolean isEmpty() &#123; QueueNode&lt;T&gt; nextNode = headNode.getNextNode(); return nextNode == null; // return count == 0; &#125; /** * * 清空队列 * */ @Override public void clear() &#123; headNode.setNextNode(null); count = 0; &#125; /** * 队列的现有节点数 * */ @Override public int size() &#123; return count; &#125; /** * 转变为List * */ @Override public List&lt;T&gt; toList() &#123; List&lt;T&gt; lst = new ArrayList&lt;&gt;(); if (isEmpty()) return lst; QueueNode&lt;T&gt; currrentNode = headNode.getNextNode(); while (currrentNode != null) &#123; lst.add(currrentNode.getValue()); currrentNode = currrentNode.getNextNode(); &#125; return lst; &#125;&#125; 测试结果测试代码就不贴了，源码传送门]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程之生产者和消费者模式]]></title>
    <url>%2F2017%2F08%2F27-java-multithreads-producer-and-consumer-learn%2F</url>
    <content type="text"><![CDATA[Java多线程之生产者和消费者模式这几天学习了下JUC的基础知识，并实现了经典的生产者和消费者模型。生产者和消费者广义上可以指数据的产生和数据的使用者，可以用在很多场景中。这里只是做了简单的实现。 操作系统原理之进程和线程管理Java的多线程和并发知识纲要 公共类和方法本文中的生产和消费的模型，主要是指 生产 =&gt; 商店 =&gt; 消费 这样的模型。 相关文章网上有很多，实现具体细节也不一样。 生产者和消费者的可以使用自定义的粗糙实现，也可以使用JavaAPI提供的JUC相关类。 商店商店的接口（也可以是抽象类）Shop：12345678910111213141516171819202122232425262728293031323334353637package com.chain.blog.test.day02;/** * 商店接口 * * @author Chain * */public interface Shop &#123; /** * 最大的商品库存数 */ public static final int MAX = 10; /** * 最小的商品库存数 */ public static final int MIN = 0; /** * 查找商品的库存 * * @return */ public int now(); /** * 商店进货 */ public boolean in(); /** * 商店卖货 */ public boolean out();&#125; 接下来是生产者和消费者，在这里我使用了CountDownLatch，用于最后的main线程的统计已生产和已消费的数量。 在这里，所有的生产者和消费者均尝试生产和消费20次。 常量存储在Constant接口里：123456package com.chain.blog.test.day02;public interface Constant &#123; public static final int TIMES = 20;&#125; 生产者生产者模型Producer：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.chain.blog.test.day02;import java.util.concurrent.CountDownLatch;/** * 生产者 * * @author Chain * */public class Producer implements Runnable &#123; private Shop shop; private CountDownLatch latch; public Producer(Shop shop, CountDownLatch latch) &#123; this.shop = shop; this.latch = latch; &#125; @Override public void run() &#123; try &#123; for (int i = 0; i &lt; Constant.TIMES; i++) &#123; try &#123; // 随机暂停一段时间，模拟不同的情况 // Thread.sleep((int) (Math.random() * 301 + 100)); Thread.sleep(100); &#125; catch (InterruptedException e) &#123; &#125; put(); &#125; &#125; finally &#123; latch.countDown(); &#125; &#125; private void put() &#123; boolean res = shop.in(); if (res) &#123; System.out.println("producer " + Thread.currentThread().getName() + " has put one"); &#125; else &#123; System.out.println("producer " + Thread.currentThread().getName() + " put one fail"); &#125; &#125;&#125; 消费者消费者模型Consumer:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.chain.blog.test.day02;import java.util.concurrent.CountDownLatch;/** * 消费者 * * @author Chain * */public class Consumer implements Runnable &#123; private Shop shop; private CountDownLatch latch; public Consumer(Shop shop, CountDownLatch latch) &#123; this.shop = shop; this.latch = latch; &#125; @Override public void run() &#123; try &#123; for (int i = 0; i &lt; Constant.TIMES; i++) &#123; try &#123; // 随机暂停一段时间，模拟不同的情况 // Thread.sleep((int) (Math.random() * 301 + 100)); Thread.sleep(300); &#125; catch (InterruptedException e) &#123; &#125; buy(); &#125; &#125; finally &#123; latch.countDown(); &#125; &#125; /** * 消费者购买商品 */ private void buy() &#123; boolean res = shop.out(); if (res) &#123; System.out.println("consumer " + Thread.currentThread().getName() + " has buy one"); &#125; else &#123; System.out.println("consumer " + Thread.currentThread().getName() + " buy one fail"); &#125; &#125;&#125; 非线程安全的做法先来测试一下非线程安全的情况，可能会出现：1、仓库爆满货仓库为负的情况；2、生产者在仓库满时仍然尝试生产，以及消费者在仓库空时仍然尝试消费的情况；3、仓库最后有空余的情况。 商店实现ShopImplA：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.chain.blog.test.day02;/** * 不使用任何多线程机制 * * 存在&lt;br&gt; * 1、内存可见性&lt;br&gt; * 2、库存可能爆仓货、库存可能为负&lt;br&gt; * 3、当库存已满时，生产者继续放货，可能出现商品生产丢失的情况&lt;br&gt; * 4、当库存不足时，消费者会继续尝试不断的买货，造成没有意义的购买尝试&lt;br&gt; * 的情况&lt;br&gt; * * @author Chain * */public class ShopImplA implements Shop &#123; private int product; // private volatile int product; public int inTimes; public int outTimes; @Override public boolean in() &#123; if (now() &gt;= Shop.MAX) &#123; System.out.println("shop is full"); return false; &#125; product++; inTimes++; System.out.println("after in, shop left is " + now()); return true; &#125; @Override public boolean out() &#123; if (now() &lt;= Shop.MIN) &#123; System.out.println("shop is empty"); return false; &#125; product--; outTimes++; System.out.println("after out, shop left is " + now()); return true; &#125; @Override public int now() &#123; return product; &#125;&#125; 测试代码TestA：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.chain.blog.test.day02;import java.util.concurrent.CountDownLatch;public class TestA &#123; public static void main(String[] args) &#123; // test1(); test2(); &#125; // 多个生产者和消费者，每个生产者和消费者也具有多个线程 // 会出现爆仓和负仓的问题，且容易出现生产和消费数据不匹配问题 private static void test2() &#123; CountDownLatch latch = new CountDownLatch(8); Shop shop = new ShopImplA(); Consumer consumer1 = new Consumer(shop, latch); Producer producer1 = new Producer(shop, latch); Consumer consumer2 = new Consumer(shop, latch); Producer producer2 = new Producer(shop, latch); new Thread(consumer1, "consumerA1").start(); new Thread(producer1, "producerA1").start(); new Thread(consumer1, "consumerA2").start(); new Thread(producer1, "producerA2").start(); new Thread(consumer2, "consumerB1").start(); new Thread(producer2, "producerB1").start(); new Thread(consumer2, "consumerB2").start(); new Thread(producer2, "producerB2").start(); while (latch.getCount() != 0) &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; &#125; &#125; System.out.println(); System.out.println("in times: " + ((ShopImplA) shop).inTimes); System.out.println("out times: " + ((ShopImplA) shop).outTimes); System.out.println("shop left: " + shop.now()); &#125; // 只有一个消费者和一个生产者，似乎没有出现爆仓和负仓的问题，但是商品有时有剩余，不能刚好买多少卖多少 private static void test1() &#123; CountDownLatch latch = new CountDownLatch(2); Shop shop = new ShopImplA(); Consumer consumer = new Consumer(shop, latch); Producer producer = new Producer(shop, latch); new Thread(consumer, "consumerA").start(); new Thread(producer, "producerA").start(); while (latch.getCount() != 0) &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; &#125; &#125; System.out.println(); System.out.println("in times: " + ((ShopImplA) shop).inTimes); System.out.println("out times: " + ((ShopImplA) shop).outTimes); System.out.println("shop left: " + shop.now()); &#125;&#125; 测试结果调整Consumer和Producer的Thread.sleep中的值，可以模拟1、生产效率快，消费速度慢2、生产效率慢，消费速度快3、生产和消费速度随机波动的情况。 以下是测试过程中的异常情况： 1、出现爆仓： 2、出现负仓： 3、仍有库存： 由上可见，这样的方式是不安全的。 线程安全的做法信号量与互斥量semaphore + mutex 也是PV模型 监控法while + wait/notify 隐式锁synchronized使用java语法直接支持的synchronized和Object自有的wait/notify方法。 在这里需要注意虚假唤醒的问题。 商店实现ShopImplB：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.chain.blog.test.day02;/** * 使用synchronized、wait/notify实现线程同步 * * 注意虚假唤醒的问题 * * @author Chain * */public class ShopImplB implements Shop &#123; private volatile int product; public int inTimes; public int outTimes; @Override public synchronized int now() &#123; return product; &#125; @Override public synchronized boolean in() &#123; // 注意这里需要是while，不能是if，因为线程除了会唤醒out操作，也会唤醒in的操作 while (now() &gt;= Shop.MAX) &#123; System.out.println("shop is full"); try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; // return false; &#125; product++; inTimes++; System.out.println("after in, shop left is " + now()); notifyAll(); return true; &#125; @Override public synchronized boolean out() &#123; while (now() &lt;= Shop.MIN) &#123; System.out.println("shop is empty"); try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; // return false; &#125; product--; outTimes++; System.out.println("after out, shop left is " + now()); notifyAll(); return true; &#125;&#125; 测试代码和非同步原型类似，只需将ShopImplA替换成ShopImplB即可。 测试结果结果总是正确的，如果不使用while而使用if会出现和非同步一样的现象，这个是虚假唤醒。 比如：生产线程A执行add操作时，再判断完if(new()&gt;=MAX)后就暂停后，线程B执行add操作时也同A一样暂停在判断后，那么在消费线程唤醒所有的线程时，会执行了两个add操作，这样就可能爆仓。 显式锁ReentrantLock显示锁操作比较麻烦，比隐式锁麻烦，不过隐式锁jvm会不断优化，还是建议使用synchronized。 商店实现ShopImplC：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.chain.blog.test.day02;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;/** * 使用显式锁和显示条件 * * @author Chain * */public class ShopImplC implements Shop &#123; private volatile int product; private ReentrantLock lock = new ReentrantLock(); private Condition conditionIn = lock.newCondition(); private Condition conditionOut = lock.newCondition(); public int inTimes; public int outTimes; @Override public int now() &#123; lock.lock(); try &#123; return product; &#125; finally &#123; lock.unlock(); &#125; &#125; @Override public boolean in() &#123; lock.lock(); try &#123; while (now() &gt;= Shop.MAX) &#123; System.out.println("shop is full"); try &#123; conditionIn.await(); &#125; catch (InterruptedException e) &#123; &#125; &#125; product++; inTimes++; System.out.println("after in, shop left is " + now()); conditionOut.signalAll(); return true; &#125; finally &#123; lock.unlock(); &#125; &#125; @Override public boolean out() &#123; lock.lock(); try &#123; while (now() &lt;= Shop.MIN) &#123; System.out.println("shop is empty"); try &#123; conditionOut.await(); &#125; catch (InterruptedException e) &#123; &#125; &#125; product--; outTimes++; System.out.println("after out, shop left is " + now()); conditionIn.signalAll(); return true; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 测试代码和非同步原型类似，只需将ShopImplA替换成ShopImplC即可。 测试结果测试结果和synchronized相比，显式锁比隐式锁感觉上要流畅一些。 使用阻塞队列自定义阻塞队列MyBlockArrayQueue商店实现ShopImplD：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.chain.blog.test.day02;import java.util.ArrayDeque;import java.util.Queue;/** * 使用自定义的阻塞队列，基于synchronized、wait/notify * * @author Chain * */public class ShopImplD implements Shop &#123; private MyBlockArrayQueue product = new MyBlockArrayQueue(Shop.MAX); public int inTimes; public int outTimes; @Override public int now() &#123; return product.size(); &#125; @Override public boolean in() &#123; product.add(); synchronized (this) &#123; inTimes++; return true; &#125; &#125; @Override public boolean out() &#123; product.poll(); synchronized (this) &#123; outTimes++; return true; &#125; &#125;&#125;/** * 自定义的阻塞队列 * * @author Chain * */class MyBlockArrayQueue &#123; private int limit; private int floor; private Queue&lt;Object&gt; queue; public MyBlockArrayQueue(int limit) &#123; this.limit = limit; this.queue = new ArrayDeque&lt;&gt;(limit); &#125; public synchronized void add() &#123; while (size() &gt;= limit) &#123; try &#123; System.out.println("queue is full"); wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; queue.add(new Object()); System.out.println("after add, queue left is " + size()); notifyAll(); &#125; public synchronized void poll() &#123; while (size() &lt;= floor) &#123; System.out.println("queue is empty"); try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; queue.poll(); System.out.println("after poll, queue left is " + size()); notifyAll(); &#125; public synchronized int size() &#123; return queue.size(); &#125;&#125; 测试代码和非同步原型类似，只需将ShopImplA替换成ShopImplD即可。 测试结果测试结果正确。 自定义阻塞队列MyBlockArrayQueue2商店实现ShopImplE：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package com.chain.blog.test.day02;import java.util.ArrayDeque;import java.util.Queue;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;/** * 使用自定义的阻塞队列，基于显式锁和显示条件 * * @author Chain * */public class ShopImplE implements Shop &#123; private MyBlockArrayQueue2 product = new MyBlockArrayQueue2(MAX); public int inTimes; public int outTimes; @Override public int now() &#123; return product.size(); &#125; @Override public boolean in() &#123; product.add(); synchronized (this) &#123; inTimes++; return true; &#125; &#125; @Override public boolean out() &#123; product.poll(); synchronized (this) &#123; outTimes++; return true; &#125; &#125;&#125;class MyBlockArrayQueue2 &#123; private int limit; private int floor; private Queue&lt;Object&gt; queue; public MyBlockArrayQueue2(int limit) &#123; this.limit = limit; this.queue = new ArrayDeque&lt;&gt;(limit); &#125; private ReentrantLock lock = new ReentrantLock(); private Condition notEmpty = lock.newCondition(); private Condition notFull = lock.newCondition(); public void add() &#123; lock.lock(); try &#123; while (size() &gt;= limit) &#123; System.out.println("queue is full"); try &#123; notFull.await(); &#125; catch (InterruptedException e) &#123; &#125; &#125; queue.add(new Object()); System.out.println("after add, queue left is " + size()); notEmpty.signalAll(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void poll() &#123; lock.lock(); try &#123; while (size() &lt;= floor) &#123; System.out.println("queue is empty"); try &#123; notEmpty.await(); &#125; catch (InterruptedException e) &#123; &#125; &#125; queue.poll(); System.out.println("after poll, queue left is " + size()); notFull.signalAll(); &#125; finally &#123; lock.unlock(); &#125; &#125; public int size() &#123; lock.lock(); try &#123; return queue.size(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 测试代码和非同步原型类似，只需将ShopImplA替换成ShopImplE即可。 测试结果测试结果正确，且感觉上优于隐式锁实现方式。 JavaAPI支持的ArrayBlockQueue官方的API基于显式锁和显式条件实现。 商店实现ShopImplF：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.chain.blog.test.day02;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;/** * 使用java的ArrayBlockingQueue，基于显式锁和显示条件 * * @author Chain * */public class ShopImplF implements Shop &#123; private BlockingQueue&lt;Object&gt; product = new ArrayBlockingQueue&lt;&gt;(MAX); public int inTimes; public int outTimes; @Override public synchronized int now() &#123; return product.size(); &#125; @Override public synchronized boolean in() &#123; while (product.size() &gt;= MAX) &#123; System.out.println("shop is full"); try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; product.add(new Object()); inTimes++; System.out.println("after in, shop left is " + now()); notifyAll(); return true; &#125; @Override public synchronized boolean out() &#123; while (product.size() &lt;= MIN) &#123; System.out.println("shop is empty"); try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; product.poll(); outTimes++; System.out.println("after out, shop left is " + now()); notifyAll(); return true; &#125;&#125; 测试代码和非同步原型类似，只需将ShopImplA替换成ShopImplD即可。 测试结果测试结果正确。 另一个案例多线程实现交替打印ABC 直接贴上源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137package com.chain.juc.day03;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;/** * 面试题 * * ABC交替打印 * * @author Chain * */public class Test04ABC &#123; public static void main(String[] args) &#123; test1(); &#125; private static void test1() &#123; MyABC abc = new MyABC(); new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; abc.printA(); &#125; &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; abc.printB(); &#125; &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; abc.printC(); &#125; &#125; &#125;).start(); &#125;&#125;class MyABC &#123; private ReentrantLock lock = new ReentrantLock(); private Condition conditionA = lock.newCondition(); private Condition conditionB = lock.newCondition(); private Condition conditionC = lock.newCondition(); private volatile int current = 1; public void printA() &#123; lock.lock(); try &#123; while (current != 1) &#123; try &#123; conditionA.await(); &#125; catch (InterruptedException e) &#123; &#125; &#125; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125; System.out.println("A"); current = 2; conditionB.signal(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void printB() &#123; lock.lock(); try &#123; while (current != 2) &#123; try &#123; conditionB.await(); &#125; catch (InterruptedException e) &#123; &#125; &#125; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125; System.out.println("B"); current = 3; conditionC.signal(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void printC() &#123; lock.lock(); try &#123; while (current != 3) &#123; try &#123; conditionC.await(); &#125; catch (InterruptedException e) &#123; &#125; &#125; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125; System.out.println("C"); current = 1; conditionA.signal(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 总结生产者消费者模型是多线程中的经典模型了，当然还是有很多东西要学习的。加油! 源码在这里]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统原理之进程和线程管理]]></title>
    <url>%2F2017%2F08%2F25-operation-system-multithreads%2F</url>
    <content type="text"><![CDATA[操作系统原理之进程和线程管理看到一节讲解操作系统进程和线程管理部分的文章，很不错，在此转载整理一下。 操作系统原理之基础知识操作系统原理之死锁操作系统原理之处理机调度操作系统原理之信号量 进程的概念在单道程序下，作业是一个接着一个进行；而在多道程序环境下，允许多个程序并发执行，程序在一个CPU上通过周期性切换达到同步执行的效果。但是，此时它们将失去封闭性，并具有间断性及不可再现性的特征。为此引入了进程(Process)的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。 为了使参与并发执行的程序（含数据）能独立地运行，必须为之配置一个专门的数据结构，称为进程控制块(Process Control Block, PCB)。系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。相应地，由程序段、相关数据段和PCB三部分构成了进程映像（进程实体）。所谓创建进程，实质上是创建进程映像中的PCB；而撤销进程，实质上是撤销进程的PCB。值得注意的是，进程映像是静态的，进程则是动态的。 注意：PCB是进程存在的唯一标志！ 从不同的角度，进程可以有不同的定义，比较典型的定义有：进程是程序的一次执行过程。进程是一个程序及其数据在处理机上顺序执行时所发生的活动。进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。 在引入进程实体的概念后，我们可以把传统操作系统中的进程定义为：“进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。” 进程的特征进程是由多程序的并发执行而引出的，它和程序是两个截然不同的概念。进程的基本特征是对比单个程序的顺序执行提出的，也是对进程管理提出的基本要求。动态性：进程是程序的一次执行，它有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态地产生、变化和消亡的。动态性是进程最基本的特征。并发性：指多个进程实体，同存于内存中，能在一段时间内同时运行，并发性是进程的重要特征，同时也是操作系统的重要特征。引入进程的目的就是为了使程序能与其他进程的程序并发执行，以提高资源利用率。独立性：指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。凡未建立PCB的程序都不能作为一个独立的单位参与运行。异步性：由于进程的相互制约，使进程具有执行的间断性，即进程按各自独立的、 不可预知的速度向前推进。异步性会导致执行结果的不可再现性，为此，在操作系统中必须配置相应的进程同步机制。结构性：每个进程都配置一个PCB对其进行描述。从结构上看，进程实体是由程序段、数据段和进程控制段三部分组成的。 进程的状态和转换进程在其生命周期内，由于系统中各进程之间的相互制约关系及系统的运行环境的变化，使得进程的状态也在不断地发生变化（一个进程会经历若干种不同状态）。 通常进程有以下五种状态，前三种是进程的基本状态。1) 运行状态：进程正在处理机上运行。在单处理机(一个CPU)环境下，每一时刻最多只有一个进程处于运行状态。2) 就绪状态：进程已处于准备运行的状态，即进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。3) 阻塞状态，又称等待状态：进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入/输出完成。即使处理机空闲，该进程也不能运行。4) 创建状态：进程正在被创建，尚未转到就绪状态。创建进程通常需要多个步骤：首先申请一个空白的PCB，并向PCB中填写一些控制和管理进程的信息；然后由系统为该进程分配运行时所必需的资源；最后把该进程转入到就绪状态。5) 结束状态：进程正从系统中消失，这可能是进程正常结束或其他原因中断退出运行。当进程需要结束运行时，系统首先必须置该进程为结束状态，然后再进一步处理资源释放和回收等工作。 注意区别就绪状态和等待状态：就绪状态是指进程仅缺少处理机，只要获得处理机资源就立即执行；而等待状态是指进程需要其他资源（除了处理机）或等待某一事件。 之所以把处理机和其他资源划分开，是因为在分时系统的时间片轮转机制中，每个进程分到的时间片是若干毫秒。也就是说，进程得到处理机的时间很短且非常频繁，进程在运行过程中实际上是频繁地转换到就绪状态的；而其他资源（如外设）的使用和分配或者某一事件的发生（如I/O操作的完成）对应的时间相对来说很长，进程转换到等待状态的次数也相对较少。这样来看，就绪状态和等待状态是进程生命周期中两个完全不同的状态，很显然需要加以区分。 下图说明了五种进程状态的转换，而三种基本状态之间的转换如下： 就绪状态 -&gt; 运行状态：处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片），于是进程由就绪状态转换为运行状态。运行状态 -&gt; 就绪状态：处于运行状态的进程在时间片用完后，不得不让出处理机，从而进程由运行状态转换为就绪状态。此外，在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程度将正执行的进程转换为就绪状态，让更高优先级的进程执行。运行状态 -&gt; 阻塞状态：当进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如I/O操作的完成）时，它就从运行状态转换为阻塞状态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。阻塞状态 -&gt; 就绪状态：当进程等待的事件到来时，如I/O操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态。 进程的控制 进程控制：创建、终止、阻塞、唤醒和切换 进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。在操作系统中，一般把进程控制用的程序段称为原语，原语的特点是执行期间不允许中断，它是一个不可分割的基本单位。 进程的创建允许一个进程创建另一个进程。此时创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。此外，在撤销父进程时，也必须同时撤销其所有的子进程。 在操作系统中，终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建。 操作系统创建一个新进程的过程如下（创建原语)：1、为新进程分配一个唯一的进程标识号，并申请一个空白的PCB(PCB是有限的)。若PCB申请失败则创建失败。2、为进程分配资源，为新进程的程序和数据、以及用户栈分配必要的内存空间（在PCB中体现）。 注意：这里如果资源不足（比如内存空间），并不是创建失败，而是处于”等待状态“，或称为“阻塞状态”，等待的是内存这个资源。3、初始化PCB,主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。4、如果进程就绪队列能够接纳新进程，就将新进程插入到就绪队列，等待被调度运行。 进程的终止引起进程终止的事件主要有：正常结束，异常结束，外界干预。 正常结束表示进程的任务已经完成和准备退出运行。异常结束是指进程在运行时，发生了某种异常事件，使程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、I/O故障等。外界干预是指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止。 操作系统终止进程的过程如下（撤销原语）：1、根据被终止进程的标识符，检索PCB，从中读出该进程的状态。2、若被终止进程处于执行状态，立即终止该进程的执行，将处理机资源分配给其他进程。3、若该进程还有子进程，则应将其所有子进程终止。4、将该进程所拥有的全部资源，或归还给其父进程或归还给操作系统。5、将该PCB从所在队列（链表）中删除。 进程的阻塞和唤醒正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。 阻塞原语的执行过程是：1、找到将要被阻塞进程的标识号对应的PCB。2、若该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行。3、把该PCB插入到相应事件的等待队列中去。 当被阻塞进程所期待的事件出现时，如它所启动的I/O操作已完成或其所期待的数据已到达，则由有关进程（比如，提供数据的进程）调用唤醒原语(Wakeup)，将等待该事件的进程唤醒。 唤醒原语的执行过程是：1、在该事件的等待队列中找到相应进程的PCB。2、将其从等待队列中移出，并置其状态为就绪状态。3、把该PCB插入就绪队列中，等待调度程序调度。 需要注意的是，Block原语和Wakeup原语是一对作用刚好相反的原语，必须成对使用。 Block原语是由被阻塞进程自我调用实现的，而Wakeup原语则是由一个与被唤醒进程相合作或被其他相关的进程调用实现的。 进程切换对于通常的进程，其创建、撤销以及要求由系统设备完成的I/O操作都是利用系统调用而进入内核，再由内核中相应处理程序予以完成的。进程切换同样是在内核的支持下实现的，因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。 进程切换是指处理机从一个进程的运行转到另一个进程上运行，这个过程中，进程的运行环境产生了实质性的变化。 进程切换的过程如下：1、保存处理机上下文，包括程序计数器和其他寄存器。2、更新PCB信息。3、把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。4、选择另一个进程执行，并更新其PCB。5、更新内存管理的数据结构。6、恢复处理机上下文。 注意，进程切换与处理机模式切换是不同的，模式切换时，处理机逻辑上可能还在同一进程中运行。如果进程因中断或异常进入到核心态运行，执行完后又回到用户态刚被中断的程序运行，则操作系统只需恢复进程进入内核时所保存的CPU现场，无需改变当前进程的环境信息。但若要切换进程，当前运行进程改变了，则当前进程的环境信息也需要改变。 进程的组织进程是操作系统的资源分配和独立运行的基本单位。它一般由以下三个部分组成： 进程的组织：控制块、程序段和数据段 进程控制块进程创建时，操作系统就新建一个PCB结构，它之后就常驻内存，任一时刻可以存取, 在进程结束时删除。 PCB是进程实体的一部分，是进程存在的唯一标志。 操作系统通过PCB表来管理和控制进程：当创建一个进程时，系统为该进程建立一个PCB；当进程执行时，系统通过其PCB了解进程的现行状态信息，以便对其进行控制和管理；当进程结束时，系统收回其PCB，该进程随之消亡。 PCB通常包含的内容如下图，该图显示的是一个PCB的实例，PCB主要包括进程描述信息、进程控制和管理信息、资源分配清单和处理机相关信息等。 各部分的主要说明如下： 1) 进程描述信息进程标识符：标志各个进程，每个进程都有一个并且是唯一的标识号。用户标识符：进程归属的用户，用户标识符主要为共享和保护服务。 2) 进程控制和管理信息进程当前状态：描述进程的状态信息，作为处理机分配调度的依据。进程优先级：描述进程抢占处理机的优先级，优先级高的进程可以优先获得处理机。 3) 资源分配清单，用于说明有关内存地址空间或虚拟地址空间的状况；所打开文件的列表和所使用的输入/输出设备信息。 4) 处理机相关信息，主要指处理机中各寄存器值，当进程被切换时，处理机状态信息都必须保存在相应的PCB中，以便在该进程重新执行时，能再从断点继续执行。 在一个系统中，通常存在着许多进程，有的处于就绪状态，有的处于阻塞状态，而且阻塞的原因各不相同。为了方便进程的调度和管理，需要将各进程的PCB用适当的方法组织起来。目前，常用的组织方式有链接方式和索引方式两种。链接方式将同一状态的PCB链接成一个队列，不同状态对应不同的队列，也可以把处于阻塞状态的进程的PCB，根据其阻塞原因的不同，排成多个阻塞队列。索引方式是将同一状态的进程组织在一个索引表中，索引表的表项指向相应的PCB，不同状态对应不同的索引表，如就绪索引表和阻塞索引表等。 程序段程序段就是能被进程调度程序调度到CPU执行的程序代码段。注意，程序可以被多个进程共享，就是说多个进程可以运行同一个程序，由此也出现了常见的并发问题。 数据段一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果，各个进制的内部数据是相对隔离的。 进程的通信进程通信是指进程之间的信息交换。 进程的通信：共享存储、消息传递和管道通信等。 PV操作是低级通信方式，髙级通信方式是指以较高的效率传输大量数据的通信方式。 高级通信方法主要有以下三个类： 共享存储在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换。在对共享空间进行写/读操作时，需要使用同步互斥工具（如 P操作、V操作），对共享空间的写/读进行控制。共享存储又分为两种：低级方式的共享是基于数据结构的共享；高级方式则是基于存储区的共享。操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成。 需要注意的是，用户进程空间一般都是独立的，要想让两个用户进程共享空间必须通过特殊的系统调用实现，但是进程内的线程是自然共享进程空间的。 消息传递在消息传递系统中，进程间的数据交换是以格式化的消息(Message)为单位的。若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法实现进程通信。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。 1) 直接通信方式：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。2) 间接通信方式：发送进程把消息发送到某个中间实体中，接收进程从中间实体中取得消息。这种中间实体一般称为信箱，这种通信方式又称为信箱通信方式。该通信方式广泛应用于计算机网络中，相应的通信系统称为电子邮件系统。 管道通信管道通信是消息传递的一种特殊方式。所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入（写）管道；而接收管道输出的接收进程（即读进程），则从管道中接收（读）数据。 为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在。 进程和线程线程的概念引入进程的目的，是为了使多道程序并发执行，以提高资源利用率和系统吞吐量；引入线程，则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。 线程最直接的理解就是“轻量级进程”，它是一个基本的CPU执行单元，也是程序执行流的最小单元，由线程ID、程序计数器、寄存器集合和堆栈组成。 线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。 一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。 引入线程后，进程的内涵发生了改变，进程只作为除CPU以外系统资源的分配单元，线程则作为处理机的分配单元。 线程与进程的比较1) 调度。在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。在引入线程的操作系统中，线程是独立调度的基本单位，进程是资源拥有的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换,如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。 2) 拥有资源。不论是传统操作系统还是设有线程的操作系统，进程都是拥有资源的基本单位，而线程不拥有系统资源（也有一点必不可少的资源），但线程可以访问其隶属进程的系统资源。 3) 并发性。在引入线程的操作系统中，不仅进程之间可以并发执行，而且多个线程之间也可以并发执行，从而使操作系统具有更好的并发性，提高了系统的吞吐量。 4) 系统开销。由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、 I/O设备等，因此操作系统所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程CPU环境的保存及新调度到进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。此外，由于同一进程内的多个线程共享进程的地址空间，因此，这些线程之间的同步与通信非常容易实现，甚至无需操作系统的干预。 5) 地址空间和其他资源（如打开的文件）：进程的地址空间之间互相独立，同一进程的各线程间共享进程的资源，某进程内的线程对于其他进程不可见。 6) 通信方面：进程间通信(IPC)需要进程同步和互斥手段的辅助，以保证数据的一致性，而线程间可以直接读/写进程数据段（如全局变量）来进行通信。 线程的属性在多线程操作系统中，把线程作为独立运行（或调度）的基本单位，此时的进程，已不再是一个基本的可执行实体。但进程仍具有与执行相关的状态，所谓进程处于“执行”状态，实际上是指该进程中某线程正在执行。 线程的主要属性如下：1、线程是一个轻型实体，它不拥有系统资源，但每个线程都应有一个唯一的标识符和一个线程控制块，线程控制块记录了线程执行的寄存器和栈等现场状态。2、不同的线程可以执行相同的程序，即同一个服务程序被不同的用户调用时，操作系统为它们创建成不同的线程。3、同一进程中的各个线程共享该进程所拥有的资源。 线程是处理机的独立调度单位，多个线程是可以并发执行的。在单CPU的计算机系统中，各线程可交替地占用CPU；在多CPU的计算机系统中，各线程可同时占用不同的CPU，若各个CPU同时为一个进程内的各线程服务则可缩短进程的处理时间。 一个线程被创建后便开始了它的生命周期，直至终止，线程在生命周期内会经历阻塞态、就绪态和运行态等各种状态变化。 线程的实现方式线程的实现可以分为两类：用户级线程(User-LevelThread, ULT)和内核级线程(Kemel-LevelThread, KLT)。内核级线程又称为内核支持的线程。 在用户级线程中，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。应用程序可以通过使用线程库设计成多线程程序。通常，应用程序从单线程起始，在该线程中开始运行，在其运行的任何时刻，可以通过调用线程库中的派生例程创建一个在相同进程中运行的新线程。上图(a)说明了用户级线程的实现方式。 在内核级线程中，线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。内核为进程及其内部的每个线程维护上下文信息，调度也是在内核基于线程架构的基础上完成。上图(b)说明了内核级线程的实现方式。 在一些系统中，使用组合方式的多线程实现。线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行。一个应用程序中的多个用户级线程被映射到一些（小于或等于用户级线程的数目）内核级线程上。上图(c)说明了用户级与内核级的组合实现方式。 多线程模型有些系统同时支持用户线程和内核线程由此产生了不同的多线程模型，即实现用户级线程和内核级线程的连接方式。 1) 多对一模型将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。此模式中，用户级线程对操作系统不可见（即透明）。优点：线程管理是在用户空间进行的，因而效率比较高。缺点：当一个线程在使用内核服务时被阻塞，那么整个进程都会被阻塞；多个线程不能并行地运行在多处理机上。 2) 一对一模型将每个用户级线程映射到一个内核级线程。优点：当一个线程被阻塞后，允许另一个线程继续执行，所以并发能力较强。缺点：每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。 3) 多对多模型将 n 个用户级线程映射到 m 个内核级线程上，要求 m &lt;= n。特点：在多对一模型和一对一模型中取了个折中，克服了多对一模型的并发度不高的缺点，又克服了一对一模型的一个用户进程占用太多内核级线程，开销太大的缺点。又拥有多对一模型和一对一模型各自的优点，可谓集两者之所长。 处理机调度操作系统原理之处理机调度 同步与互斥在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系，引入了进程同步的概念。 临界资源虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所使用，我们把一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机等。此外，还有许多变量、数据等都可以被若干进程共享，也属于临界资源。 对临界资源的访问，必须互斥地进行，在每个进程中，访问临界资源的那段代码称为临界区。 为了保证临界资源的正确使用，可以把临界资源的访问过程分成四个部分：1、进入区。为了进入临界区使用临界资源，在进入区要检查可否进入临界区，如果可以进入临界区，则应设置正在访问临界区的标志，以阻止其他进程同时进入临界区。2、临界区。进程中访问临界资源的那段代码，又称临界段。3、退出区。将正在访问临界区的标志清除。4、剩余区。代码中的其余部分。 123456do &#123; entry section; //进入区 critical section; //临界区 exit section; //退出区 remainder section; //剩余区&#125; while (true) 同步同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。 例如，输入进程A通过单缓冲向进程B提供数据。当该缓冲区空时，进程B不能获得所需数据而阻塞，一旦进程A将数据送入缓冲区，进程B被唤醒。反之，当缓冲区满时，进程A被阻塞，仅当进程B取走缓冲数据时，才唤醒进程A。 互斥互斥亦称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待, 当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。 例如，在仅有一台打印机的系统中，有两个进程A和进程B，如果进程A需要打印时, 系统已将打印机分配给进程B,则进程A必须阻塞。一旦进程B将打印机释放，系统便将进程A唤醒，并将其由阻塞状态变为就绪状态。 为禁止两个进程同时进入临界区，同步机制应遵循以下准则：1、空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。2、忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。3、有限等待。对请求访问的进程，应保证能在有限时间内进入临界区。4、让权等待。当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。 实现临界区互斥的基本方法和信号量操作系统原理之信号量 什么是管程管程的定义系统中的各种硬件资源和软件资源，均可用数据结构抽象地描述其资源特性，即用少量信息和对资源所执行的操作来表征该资源，而忽略了它们的内部结构和实现细节。管程是由一组数据以及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化并改变管程中的数据和同步进程。 管程的组成1) 局部于管程的共享结构数据说明。2) 对该数据结构进行操作的一组过程。3) 对局部于管程的共享数据设置初始值的语句。 管程的基本特性1) 局部于管程的数据只能被局部于管程内的过程所访问。2) 一个进程只有通过调用管程内的过程才能进入管程访问共享数据。3) 每次仅允许一个进程在管程内执行某个内部过程。 由于管程是一个语言成分，所以管程的互斥访问完全由编译程序在编译时自动添加，无需程序员关注，而且保证正确。 进程的死锁操作系统原理之死锁 补充和总结程序与进程1) 进程是程序及其数据在计算机上的一次运行活动，是一个动态的概念。而程序是一组有序的指令集合，是一种静态的概念。2) 进程是程序的一次执行过程，它是动态地创建和消亡的，具有一定的生命周期，是暂时存在的；而程序则是一组代码的集合，它是永久存在的，可长期保存。3) 一个进程可以执行一个或几个程序，一个程序也可以构成多个进程。进程可创建进程，而程序不可能形成新的程序。4) 进程与程序的组成不同。进程的组成包括程序、数据和PCB。进程的运行实体是程序，离开程序的进程没有存在的意义。 作业与进程进程是系统资源的使用者，系统的资源大部分都是以进程为单位分配的。而用户使用计算机是为了实现一串相关的任务，通常把用户要求计算机完成的这一串任务称为作业。 进程是作业的执行（计算机完成任务）的表现。 死锁与饥饿具有等待队列的信号量的实现可能导致这样的情况：两个或多个进程无限地等待一个事件，而该事件只能由这些等待进程之一来产生。这里的事件是V操作的执行（即释放资源）。当出现这样的状态时，这些进程称为死锁(Deadlocked)。 说一组进程处于死锁状态是指：组内的每个进程都等待一个事件，而该事件只可能由组内的另一个进程产生。这里所关心的主要是事件是资源的获取和释放。 与死锁相关的另一个问题是无限期阻塞(Indefinite Blocking)或“饥饿” (Starvation)，即进程在信号量内无穷等待的情况。 产生饥饿的主要原因是：在一个动态系统中，对于每类系统资源，操作系统需要确定一个分配策略，当多个进程同时申请某类资源时，由分配策略确定资源分配给进程的次序。有时资源分配策略可能是不公平的，即不能保证等待时间上界的存在。在这种情况下，即使系统没有发生死锁，某些进程也可能会长时间等待。当等待时间给进程推进和响应带来明显影响时，称发生了进程“饥饿”，当“饥饿”到一定程度的进程所赋予的任务即使完成也不再具有实际意义时称该进程被“饿死”。 “饥饿”并不表示系统一定死锁，但至少有一个进程的执行被无限期推迟。 例如，当有多个进程需要打印文件时，如果系统分配打印机的策略是最短文件优先，那么长文件的打印任务将由于短文件的源源不断到来而被无限期推迟，导致最终的“饥饿”甚至“饿死”。 “饥饿”与“死锁”的主要差别有：1、进入“饥饿”状态的进程可以只有一个，而由于循环等待条件而进入死锁状态的进程却必须大于或等于两个。2、处于“饥饿”状态的进程可以是一个就绪进程，如静态优先权调度算法时的低优先权进程，而处于死锁状态的进程则必定是阻塞进程。 同步与互斥并发进程的执行会产生相互制约的关系：1、一种是进程之间竞争使用临界资源，只能让它们逐个使用，这种现象称为互斥，是一种竞争关系；2、另一种是进程之间协同完成任务，在关键点上等待另一个进程发来的消息，以便协同一致，是一种协作关系。 银行家算法银行家算法的主要思想是避免系统进入不安全状态。在每次进行资源分配时，它首先检查系统是否有足够的资源满足要求，如果有，则先进行分配，并对分配后的新状态进行安全性检查。如果新状态安全，则正式分配上述资源，否则就拒绝分配上述资源。这样，它保证系统始终处于安全状态，从而避免死锁现象的发生。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>学习</tag>
        <tag>多线程</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统原理之死锁]]></title>
    <url>%2F2017%2F08%2F24-operation-system-deadlock%2F</url>
    <content type="text"><![CDATA[操作系统原理之死锁死锁是多线程中经典话题，这里转载一篇文章并做整理。 操作系统原理之进程和线程管理 死锁的定义在多道程序系统中，由于多个进程的并发执行，改善了系统资源的利用率并提高了系统的处理能力。然而，多个进程的并发执行也带来了新的问题——死锁。所谓死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。 下面我们通过一些实例来说明死锁现象。 先看生活中的一个实例，在一条河上有一座桥，桥面很窄，只能容纳一辆汽车通行。如果有两辆汽车分别从桥的左右两端驶上该桥，则会出现下述的冲突情况。此时，左边的汽车 占有了桥面左边的一段，要想过桥还需等待右边的汽车让出桥面右边的一段；右边的汽车占有了桥面右边的一段，要想过桥还需等待左边的汽车让出桥面左边的一段。此时，若左右两边的汽车都只能向前行驶，则两辆汽车都无法过桥。 在计算机系统中也存在类似的情况。例如，某计算机系统中只有一台打印机和一台输入设备，进程P1正占用输入设备，同时又提出使用打印机的请求，但此时打印机正被进程P2所占用，而P2在未释放打印机之前，又提出请求使用正被P1占用着的输入设备。这样两个进程相互无休止地等待下去，均无法继续执行，此时两个进程陷入死锁状态。 死锁产生的原因1) 系统资源的竞争通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在 运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。只有对不可剥夺资源的竞争 才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的。 2) 进程推进顺序非法进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。例如，并发进程 P1、P2分别保持了资源R1、R2，而进程P1申请资源R2，进程P2申请资源R1时，两者都会因为所需资源被占用而阻塞。 信号量使用不当也会造成死锁。进程间彼此相互等待对方发来的消息，结果也会使得这些进程间无法继续向前推进。例如，进程A等待进程B发的消息，进程B又在等待进程A发的消息，可以看出进程A和B不是因为竞争同一资源，而是在等待对方的资源导致死锁。 3) 死锁产生的必要条件产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生：1、互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。2、不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。3、请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。4、循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等待的资源被P(i+1)占有（i=0, 1, …, n-1)，Pn等待的资源被P0占有。 直观上看，循环等待条件似乎和死锁的定义一样，其实不然。按死锁定义构成等待环所要求的条件更严，它要求Pi等待的资源必须由P(i+1)来满足，而循环等待条件则无此限制。 例如，系统中有两台输出设备，P0占有一台，PK占有另一台，且K不属于集合{0, 1, …, n}。Pn等待一台输出设备，它可以从P0获得，也可能从PK获得。因此，虽然Pn、P0和其他一些进程形成了循环等待圈，但PK不在圈内，若PK释放了输出设备，则可打破循环等待, 如上图所示。 因此循环等待只是死锁的必要条件。 资源分配图含圈而系统又不一定有死锁的原因是同类资源数大于1。但若系统中每类资源都只有一个资源，则资源分配图含圈就变成了系统出现死锁的充分必要条件。 死锁的处理策略为使系统不发生死锁，必须设法破坏产生死锁的四个必要条件之一，或者允许死锁产生，但当死锁发生时能检测出死锁，并有能力实现恢复。 预防死锁设置某些限制条件，破坏产生死锁的四个必要条件中的一个或几个，以防止发生死锁。 避免死锁在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁。 死锁的检测及解除无需釆取任何限制性措施，允许进程在运行过程中发生死锁。通过系统的检测机构及时 地检测出死锁的发生，然后釆取某种措施解除死锁。 预防死锁和避免死锁都属于事先预防策略，但预防死锁的限制条件比较严格，实现起来较为简单，但往往导致系统的效率低，资源利用率低；避免死锁的限制条件相对宽松，资源 分配后需要通过算法来判断是否进入不安全状态，实现起来较为复杂。 死锁的几种处理策略的比较见下表。 死锁预防防止死锁的发生只需破坏死锁产生的四个必要条件之一即可。 1) 破坏互斥条件如果允许系统资源都能共享使用，则系统不会进入死锁状态。但有些资源根本不能同时访问，如打印机等临界资源只能互斥使用。所以，破坏互斥条件而预防死锁的方法不太可行，而且在有的场合应该保护这种互斥性。 2) 破坏不剥夺条件当一个已保持了某些不可剥夺资源的进程，请求新的资源而得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着，一个进程已占有的资源会被暂时释放，或者说是被剥夺了，或从而破坏了不可剥夺条件。 该策略实现起来比较复杂，释放已获得的资源可能造成前一阶段工作的失效，反复地申请和释放资源会增加系统开销，降低系统吞吐量。这种方法常用于状态易于保存和恢复的资源，如CPU的寄存器及内存资源，一般不能用于打印机之类的资源。 3) 破坏请求和保持条件釆用预先静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行。一旦投入运行后，这些资源就一直归它所有，也不再提出其他资源请求，这样就可以保证系统不会发生死锁。 这种方式实现简单，但缺点也显而易见，系统资源被严重浪费，其中有些资源可能仅在运行初期或运行快结束时才使用，甚至根本不使用。而且还会导致“饥饿”现象，当由于个别资源长期被其他进程占用时，将致使等待该资源的进程迟迟不能开始运行。 4) 破坏循环等待条件为了破坏循环等待条件，可釆用顺序资源分配法。首先给系统中的资源编号，规定每个进程，必须按编号递增的顺序请求资源，同类资源一次申请完。也就是说，只要进程提出申请分配资源Ri，则该进程在以后的资源申请中，只能申请编号大于Ri的资源。 这种方法存在的问题是，编号必须相对稳定，这就限制了新类型设备的增加；尽管在为资源编号时已考虑到大多数作业实际使用这些资源的顺序，但也经常会发生作业使甩资源的顺序与系统规定顺序不同的情况，造成资源的浪费；此外，这种按规定次序申请资源的方法，也必然会给用户的编程带来麻烦。 死锁避免避免死锁同样是属于事先预防的策略，但并不是事先釆取某种限制措施破坏死锁的必要条件，而是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。这种方法所施加的限制条件较弱，可以获得较好的系统性能。 系统安全状态避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程； 否则，让进程等待。 所谓安全状态，是指系统能按某种进程推进顺序( P1, P2, …, Pn)，为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺序地完成。此时称 P1, P2, …, Pn 为安全序列。如果系统无法找到一个安全序列，则称系统处于不安全状态。 假设系统中有三个进程P1、P2和P3,共有12 台磁带机。进程P1总共需要10台磁带机，P2和P3 分别需要4台和9台。假设在T0时刻，进程P1、P2 和P3已分别获得5合、2台和2台，尚有3台未分配，见下表。 则在T0时刻是安全的，因为存在一个安全序列P2、Pl、P3，即只要系统按此进程序列分配资源，则每个进程都能顺利完成。若在T0时刻后，系统分配1台磁带机给P3，则此时系统便进入不安全状态，因为此时已无法再找到一个安全序列。 并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统便可以避免进入死锁状态。 银行家算法银行家算法是最著名的死锁避免算法。它提出的思想是：把操作系统看做是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配资源，若没有超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。 1) 数据结构描述可利用资源矢量Available：含有m个元素的歎组，其中的每一个元素代表一类可用的资源数目。Available[j]=K，则表示系统中现有Rj类资源K个。最大需求矩阵Max：为nm矩阵，定义了系统中n个进程中的每一个进程对m类资源的最大需求。Max[i, j]=K，则表示进程i需要Rj类资源的最大数目为K。分配矩阵Allocation：为nm矩阵，定义了系统中每一类资源当前已分配给每一进程的资源数。All0Cati0n[i, j]= K，则表示进程i当前已分得Rj类资源的数目为K。需求矩阵Need：为n*m矩阵，表示每个进程尚需的各类资源数。Need[i, j]=K，则表示进程i还需要Rj类资源的数目为K。 上述三个矩阵间存在下述关系：Need[i, j] = Max[i, j] - Allocation[i, j] 2) 银行家算法描述设Requesti是进程Pi的请求矢量，如果Requesti[j]K，表示进程Pi需要Rj类资源K个。当Pi发出资源请求后，系统按下述步骤进行检查：①如果Requesti[j] &lt;= Need[i, j]，便转向步骤②；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。②如果Requesti[j] &lt;= Available[j]，便转向步骤③;否则，表示尚无足够资源，Pi须等待。③系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值：123Available[j] = Available[j] - Requesti[j];Allocation[i, j] = Allocation[i, j] + Requesti[ j];Need[i, j] = Need[i, j] - Requesti[j]; ④系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。 3) 安全性算法①设置两个矢量。工作矢量Work；它表示系统可提供给进程继续运行所需的各类资源数目，它含有所个元素，在执行安全算法开始时，Work=Available; Finish：它表示系统是否有足够的资源分配给进程，使之运行完成。开始时 Finish[i]=false；当有足够资源分配给进程 Pi 时，再令 Finish[i]=true。②从进程集合中找到一个能满足下述条件的进程：Finish[i]=false; Need[i, j]&lt;=Work[j]; 若找到，执行下一步骤，否则，执行步骤4。③当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：123Work[j]=Work[j]+Allocation[i, j];Finish[i]=true;go to step &lt;2&gt;; ④如果所有进程的Finish[i]=tme都满足，则表示系统处于安全状态；否则，系统处于不安全状态。 银行家算法举例 假定系统中有5个进程{P0, P1, P2, P3, P4}和三类资源{A, B, C}，各种资源的数量分别为10、5、7，在T0时刻的资源分配情况见下表。 1) T0时刻的安全性。利用安全性算法对T0时刻的资源分配进行分析，由下表可知，在T0时刻存在着一个安全序列{P1, P3, P4, P2, P0}，故系统是安全的。 2) P1请求资源 P1发出请求矢量Request1(l，, 0, 2)，系统按银行家算法进行检查：Request1(1, 0, 2) &lt;= Need1(l, 2, 2)。Request1(1, 0, 2) &lt;= Available1(3, 3, 2)。系统先假定可为P1分配资源，并修改Available、Allocation1和Need1矢量，由此形成的资源变化情况见下表。再利用安全性算法检查此时系统是否安全。 3) P4请求资源P4发出请求矢量Request4(3, 3, 0)，系统按银行家算法进行检查：Request4(3, 3, 0) &lt;= Need4(4, 3, 1)。Request4(3, 3, 0) &gt; Available(2, 3, 0)，让 P4 等待。 4) P0请求资源P0发出请求矢量Request0(0, 2, 0)，系统按银行家算法进行检查：Request0(0, 2, 0) &lt;= Need0(7, 4, 3)。Request0(0, 2, 0) &lt;= Available(2, 3, 0)。系统暂时先假定可为P0分配资源，并修改有关数据，见下表。 5) 进行安全性检测。可用资源Available(2, 1, 0)已不能满足任何进程的需要，故系统进入不安全状态，此时系统不分配资源。 死锁的检测和解除前面绍的死锁预防和避免算法，都是在为进程分配资源时施加限制条件或进行检测，若系统为进程分配资源时不釆取任何措施，则应该提供死锁检测和解除的手段。 资源分配图系统死锁，可利用资源分配图来描述。如下图所示，用圆圈代表一个进程，用框代表一类资源。由于一种类型的资源可能有多个，用框中的一个点代表一类资源中的一个资源。从进程到资源的有向边叫请求边，表示该进程申请一个单位的该类资源；从资源到进程的边叫分配边，表示该类资源已经有一个资源被分配给了该进程。 在上图所示的资源分配图中，进程P1已经分得了两个R1资源，并又请求一个R2资源；进程P2分得了一个R1和一个R2资源，并又请求一个R1资源。 死锁定理 可以通过将资源分配图简化的方法来检测系统状态S是否为死锁状态。简化方法如下： 1) 在资源分配图中，找出既不阻塞又不是孤点的进程Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配边，使之成为孤立的结点。在上图(a)中，P1是满足这一条件的进程结点，将P1的所有边消去，便得到上图(b)所示的情况。 2) 进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在资源分配图示例图中，进程P2就满足这样的条件。根据第1)条中的方法进行一系列简化后,若能消去图中所有的边，则称该图是可完全简化的，如上图(c)所示。 S为死锁的条件是当且仅当S状态的资源分配图是不可完全简化的,该条件为死锁定理。 死锁的解除一旦检测出死锁，就应立即釆取相应的措施，以解除死锁。死锁解除的主要方法有： 1) 资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。2) 撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。3) 进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>学习</tag>
        <tag>多线程</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统原理之处理机调度]]></title>
    <url>%2F2017%2F08%2F23-operation-system-job-schedule%2F</url>
    <content type="text"><![CDATA[操作系统原理之处理机调度处理机调度也是操作系统的基础知识之一，是多线程的基石，这里转载一篇文章并做整理。 操作系统原理之进程和线程管理 调度的基本概念在多道程序系统中，进程的数量往往多于处理机的个数，进程争用处理机的情况就在所难免。处理机调度是对处理机进行分配，就是从就绪队列中，按照一定的算法（公平、髙效）选择一个进程并将处理机分配给它运行，以实现进程并发地执行。 处理机调度是多道程序操作系统的基础，它是操作系统设计的核心问题。 调度的层次一个作业从提交开始直到完成，往往要经历以下三级调度，如下图所示。 1) 作业调度，又称高级调度。其主要任务是按一定的原则从外存上处于后备状态的作业中挑选一个（或多个）作业，给它（们）分配内存、输入/输出设备等必要的资源，并建立相应的进程，以使它（们）获得竞争处理机的权利。简言之，就是内存与辅存之间的调度。对于每个作业只调入一次、调出一次。 多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。作业调度的执行频率较低，通常为几分钟一次。 2) 中级调度，又称内存调度。引入中级调度是为了提高内存利用率和系统吞吐量。为此，应使那些暂时不能运行的进程，调至外存等待，把此时的进程状态称为挂起状态。当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定，把外存上的那些已具备运行条件的就绪进程，再重新调入内存，并修改其状态为就绪状态，挂在就绪队列上等待。 3) 进程调度，又称为低级调度。其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中最基本的一种调度，在一般操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。 三级调度的联系作业调度从外存的后备队列中选择一批作业进入内存，为它们建立进程，这些进程被送入就绪队列，进程调度从就绪队列中选出一个进程，并把其状态改为运行状态，把CPU分配给它。中级调度是为了提高内存的利用率，系统将那些暂时不能运行的进程挂起来。当内存空间宽松时，通过中级调度选择具备运行条件的进程，将其唤醒。 1) 作业调度为进程活动做准备，进程调度使进程正常活动起来，中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间。2) 作业调度次数少，中级调度次数略多，进程调度频率最高。3) 进程调度是最基本的，不可或缺。 调度的时机、切换与过程进程调度和切换程序是操作系统内核程序。当请求调度的事件发生后，才可能会运行进程调度程序，当调度了新的就绪进程后，才会去进行进程间的切换。理论上这三件事情应该顺序执行，但在实际设计中，在操作系统内核程序运行时，如果某时发生了引起进程调度的因素，并不一定能够马上进行调度与切换。 现代操作系统中，不能进行进程的调度与切换的情况有以下几种情况。1) 在处理中断的过程中：中断处理过程复杂，在实现上很难做到进程切换，而且中断处理是系统工作的一部分，逻辑上不属于某一进程，不应被剥夺处理机资源，属于原子操作。2) 进程在操作系统内核程序临界区中：进入临界区后，需要独占式地访问共享数据，理论上必须加锁，以防止其他并行程序进入，在解锁前不应切换到其他进程运行，以加快该共享数据的释放。3) 其他需要完全屏蔽中断的原子操作过程中：如加锁、解锁、中断现场保护、恢复等原子操作。在原子过程中，连中断都要屏蔽，更不应该进行进程调度与切换。 如果在上述过程中发生了引起调度的条件，并不能马上进行调度和切换，应置系统的请求调度标志，直到上述过程结束后才进行相应的调度与切换。 应该进行进程调度与切换的情况有：1) 当发生引起调度条件，且当前进程无法继续运行下去时，可以马上进行调度与切换。如果操作系统只在这种情况下进行进程调度，就是非剥夺调度。2) 当中断处理结束或自陷处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行进程调度与切换。如果操作系统支持这种情况下的运行调度程序，就实现了剥夺方式的调度。 进程切换往往在调度完成后立刻发生，它要求保存原进程当前切换点的现场信息，恢复被调度进程的现场信息。现场切换时，操作系统内核将原进程的现场信息推入到当前进程的内核堆栈来保存它们，并更新堆栈指针。内核完成从新进程的内核栈中装入新进程的现场信息、更新当前运行进程空间指针、重设PC寄存器等相关工作之后，开始运行新的进程。 进程调度方式所谓进程调度方式是指当某一个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要处理，即有优先权更髙的进程进入就绪队列，此时应如何分配处理机。 通常有以下两种进程调度方式：1) 非剥夺调度方式，又称非抢占方式。是指当一个进程正在处理机上执行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在执行的进程继续执行，直到该进程完成或发生某种事件而进入阻塞状态时，才把处理机分配给更为重要或紧迫的进程。 在非剥夺调度方式下，一旦把CPU分配给一个进程，那么该进程就会保持CPU直到终止或转换到等待状态。这种方式的优点是实现简单、系统开销小，适用于大多数的批处理系统，但它不能用于分时系统和大多数的实时系统。 2) 剥夺调度方式，又称抢占方式。是指当一个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给这个更为重要或紧迫的进程。. 釆用剥夺式的调度，对提高系统吞吐率和响应效率都有明显的好处。但“剥夺”不是一种任意性行为，必须遵循一定的原则，主要有：优先权、短进程优先和时间片原则等。调度的基本准则 不同的调度算法具有不同的特性，在选择调度算法时，必须考虑算法所具有的特性。为了比较处理机调度算法的性能，人们提出很多评价准则，下面介绍主要的几种： 1) CPU利用率。CPU是计算机系统中最重要和昂贵的资源之一，所以应尽可能使CPU保持“忙”状态，使这一资源利用率最髙。 2) 系统吞吐量。表示单位时间内CPU完成作业的数量。长作业需要消耗较长的处理机时间，因此会降低系统的吞吐量。而对于短作业，它们所需要消耗的处理机时间较短，因此能提高系统的吞吐量。调度算法和方式的不同，也会对系统的吞吐量产生较大的影响。 3) 周转时间。是指从作业提交到作业完成所经历的时间，包括作业等待、在就绪队列中排队、在处迤机上运行以及进行输入/输出操作所花费时间的总和。 作业的周转时间可用公式表示如下： 周转时间 = 作业完成时间 - 作业提交时间 平均周转时间是指多个作业周转时间的平均值： 平均周转时间 = (作业1的周转时间 + … + 作业 n 的周转时间) / n 带权周转时间是指作业周转时间与作业实际运行时间的比值： 平均带权周转时间是指多个作业带权周转时间的平均值： 平均带权周转时间 = (作业1的带权周转时间 + … + 作业 n 的带权周转时间) / n 4) 等待时间。是指进程处于等处理机状态时间之和，等待时间越长，用户满意度越低。处理机调度算法实际上并不影响作业执行或输入/输出操作的时间，只影响作业在就绪队列中等待所花的时间。因此，衡量一个调度算法优劣常常只需简单地考察等待时间。 5) 响应时间。是指从用户提交请求到系统首次产生响应所用的时间。在交互式系统中，周转时间不可能是最好的评价准则，一般釆用响应时间作为衡量调度算法的重要准则之一。从用户角度看，调度策略应尽量降低响应时间，使响应时间处在用户能接受的范围之内。 要想得到一个满足所有用户和系统要求的算法几乎是不可能的。 设计调度程序，一方面要满足特定系统用户的要求（如某些实时和交互进程快速响应要求)，另一方面要考虑系统整体效率（如减少整个系统进程平均周转时间），同时还要考虑调度算法的开销。 操作系统典型调度算法在操作系统中存在多种调度算法，其中有的调度算法适用于作业调度，有的调度算法适用于进程调度，有的调度算法两者都适用。下面介绍几种常用的调度算法。 先来先服务(FCFS)调度算法FCFS调度算法是一种最简单的调度算法，该调度算法既可以用于作业调度也可以用于进程调度。在作业调度中，算法每次从后备作业队列中选择最先进入该队列的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。 在进程调度中，FCFS调度算法每次从就绪队列中选择最先进入该队列的进程，将处理机分配给它，使之投入运行，直到完成或因某种原因而阻塞时才释放处理机。 下面通过一个实例来说明FCFS调度算法的性能。假设系统中有4个作业，它们的提交时间分别是8、8.4、8.8、9，运行时间依次是2、1、0.5、0.2。系统釆用FCFS调度算法，这组作业的平均等待时间、平均周转时间和平均带权周转时间见下表。 平均等待时间 t = (0+1.6+2.2+2.5)/4=1.575平均周转时间 T = (2+2.6+2.7+2.7)/4=2.5平均带权周转时间 W = (1+2.6+5.牡13.5)/4=5.625 FCFS调度算法属于不可剥夺算法。从表面上看，它对所有作业都是公平的，但若一个长作业先到达系统，就会使后面许多短作业等待很长时间，因此它不能作为分时系统和实时系统的主要调度策略。但它常被结合在其他调度策略中使用。例如，在使用优先级作为调度策略的系统中，往往对多个具有相同优先级的进程按FCFS原则处理。 FCFS调度算法的特点是算法简单，但效率低；对长作业比较有利，但对短作业不利（相对SJF和高响应比）；有利于CPU繁忙型作业，而不利于I/O繁忙型作业。 短作业优先(SJF)调度算法短作业（进程）优先调度算法是指对短作业（进程）优先调度的算法。短作业优先(SJF)调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法，则是从就绪队列中选择一个估计运行时间最短的进程，将处理机分配给它，使之立即执行，直到完成或发生某事件而阻塞时，才释放处理机。 例如，考虑下表中给出的一组作业，若系统釆用短作业优先调度算法，其平均等待时间、平均周转时间和平均带权周转时间。 平均等待时间 t = (0+2.3+1.4+1)/4=1.175平均周转时间 T = (2+3.3+1.9+1.2)/4=2.1平均带权周转时间 W = (1+3.3+3.8+6)/4=3.525 SJF调度算法也存在不容忽视的缺点：该算法对长作业不利，由上面两个表可知，SJF调度算法中长作业的周转时间会增加。更严重的是，如果有一长作业进入系统的后备队列，由于调度程序总是优先调度那些 (即使是后进来的）短作业，将导致长作业长期不被调度（“饥饿”现象，注意区分“死锁”。后者是系统环形等待，前者是调度策略问题）。 该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业会被及时处理。 由于作业的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。 注意，SJF调度算法的平均等待时间、平均周转时间最少。 优先级调度算法优先级调度算法又称优先权调度算法，该算法既可以用于作业调度，也可以用于进程调度，该算法中的优先级用于描述作业运行的紧迫程度。 在作业调度中，优先级调度算法每次从后备作业队列中选择优先级最髙的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。 根据新的更高优先级进程能否抢占正在执行的进程，可将该调度算法分为：1、非剥夺式优先级调度算法。当某一个进程正在处理机上运行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在运行的进程继续运行，直到由于其自身的原因而主动让出处理机时（任务完成或等待事件），才把处理机分配给更为重要或紧迫的进程。2、剥夺式优先级调度算法。当一个进程正在处理机上运行时，若有某个更为重要或紧迫的进程进入就绪队列，则立即暂停正在运行的进程，将处理机分配给更重要或紧迫的进程。 而根据进程创建后其优先级是否可以改变，可以将进程优先级分为以下两种：1、静态优先级。优先级是在创建进程时确定的，且在进程的整个运行期间保持不变。确定静态优先级的主要依据有进程类型、进程对资源的要求、用户要求。2、动态优先级。在进程运行过程中，根据进程情况的变化动态调整优先级。动态调整优先级的主要依据为进程占有CPU时间的长短、就绪进程等待CPU时间的长短。 高响应比优先调度算法高响应比优先调度算法主要用于作业调度，该算法是对FCFS调度算法和SJF调度算法的一种综合平衡，同时考虑每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。 响应比的变化规律可描述为： 根据公式可知：1、当作业的等待时间相同时，则要求服务时间越短，其响应比越高，有利于短作业。2、当要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，其响应比越高，因而它实现的是先来先服务。对于长作业，作业的响应比可以随等待时间的增加而提高，当其等待时间足够长时，其响应比便可升到很高，从而也可获得处理机。 克服了饥饿状态，兼顾了长作业。 时间片轮转调度算法时间片轮转调度算法主要适用于分时系统。 在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务的原则，但仅能运行一个时间片，如100ms。在使用完一个时间片后，即使进程并未完成其运行，它也必须释放出（被剥夺）处理机给下一个就绪的进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行。 在时间片轮转调度算法中，时间片的大小对系统性能的影响很大。如果时间片足够大，以至于所有进程都能在一个时间片内执行完毕，则时间片轮转调度算法就退化为先来先服务调度算法。如果时间片很小，那么处理机将在进程间过于频繁切换，使处理机的开销增大，而真正用于运行用户进程的时间将减少。因此时间片的大小应选择适当。 时间片的长短通常由以下因素确定：系统的响应时间、就绪队列中的进程数目和系统的处理能力。 多级反馈队列调度算法（前面算法的整合）多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合和发展，如下图所示。 通过动态调整进程优先级和时间片大小，多级反馈队列调度算法可以兼顾多方面的系统目标。例如，为提高系统吞吐量和缩短平均周转时间而照顾短进程；为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程；同时，也不必事先估计进程的执行时间。 多级反馈队列调度算法的实现思想如下：1、应设置多个就绪队列，并为各个队列赋予不同的优先级，第1级队列的优先级最高，第2级队列次之，其余队列的优先级逐次降低。2、赋予各个队列中进程执行时间片的大小也各不相同，在优先级越高的队列中，每个进程的运行时间片就越小。例如，第2级队列的时间片要比第1级队列的时间片长一倍，第i+1级队列的时间片要比第i级队列的时间片长一倍。3、当一个新进程进入内存后，首先将它放入第1级队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第2级队列的末尾，再同样地按FCFS 原则等待调度执行；如果它在第2级队列中运行一个时间片后仍未完成，再以同样的方法放入第3级队列。如此下去，当一个长进程从第1级队列依次降到第 n 级队列后，在第 n 级队列中便釆用时间片轮转的方式运行。4、仅当第1级队列为空时，调度程序才调度第2级队列中的进程运行；仅当第1 ~ (i-1)级队列均为空时，才会调度第i级队列中的进程运行。如果处理机正在执行第i级队列中的某进程时，又有新进程进入优先级较高的队列（第 1 ~ (i-1)中的任何一个队列），则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i级队列的末尾，把处理机分配给新到的更高优先级的进程。 多级反馈队列的优势有：1、终端型作业用户：短作业优先。2、短批处理作业用户：周转时间较短。3、长批处理作业用户：经过前面几个队列得到部分执行，不会长期得不到处理。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>学习</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统原理之信号量]]></title>
    <url>%2F2017%2F08%2F22-operation-system-semaphore%2F</url>
    <content type="text"><![CDATA[操作系统原理之信号量同步和互斥是比较重要的概念，这里转载一篇文章并做整理。 操作系统原理之进程和线程管理 实现临界区互斥的基本方法软件实现方法在进入区设置和检查一些标志来标明是否有进程在临界区中，如果已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。 算法一：单标志法该算法设置一个公用整型变量turn，用于指示被允许进入临界区的进程编号。即若turn=0，则允许P0进程进入临界区；相应的，若turn=1，则允许P1进程进入临界区. 注意：该算法可确保每次只允许一个进程进入临界区，但两个进程必须交替进入临界区。如果某个进程进入了一次后退出，那么另一个进程将无法进入临界区（违背“空闲让进”），这样很容易造成资源利用的不充分。 12345// P0进程while(turn!=0);critical section;turn=1;remainder section; 12345// P1进程while(turn!=1); // 进入区critical section; // 临界区turn = 0; // 退出区remainder section; // 剩余区 算法二：双标志法先检查该算法的基本思想是在每一个进程访问临界区资源之前，先查看一下临界资源是否正被访问，若正被访问，该进程需等待；否则，进程才进入自己的临界区。为此，设置了一个数据flag[i]，如第i个元素值为FALSE，表示Pi进程未进入临界区，值为TRUE，表示Pi进程进入临界区。 123456// Pi 进程while(flag[j]); // ① flag[i]=TRUE; // ③ critical section; flag[i] = FALSE; remainder section; 123456// Pj 进程while(flag[i]); // ② 进入区flag[j] =TRUE; // ④ 进入区critical section; // 临界区flag[j] = FALSE; // 退出区remainder section; // 剩余区 优点：不用交替进入，可连续使用；缺点：Pi和Pj可能同时进入临界区。按序列①②③④ 执行时，会同时进入临界区（违背“忙则等待”)。即在检查对方flag之后和切换自己flag之前有一段时间（可能进程被剥夺了执行权），结果都检查通过。 这里的问题出在检查（while(flag[i])）和修改(flag[j])操作不能一次进行。 算法三：双标志法后检查算法二是先检测对方进程状态标志后，再置自己标志，由于在检测和放置中可插入另一个进程到达时的检测操作，会造成两个进程在分别检测后，同时进入临界区。 为此，算法三釆用先设置自己标志为TRUE后,再检测对方状态标志，若对方标志为TURE，则进程等待；否则进入临界区。 123456// Pi进程flag[i] =TRUE;while(flag[j]);critical section;flag[i] =FLASE;remainder section; 123456// Pj进程flag[j] =TRUE; // 进入区while(flag[i]); // 进入区critical section; // 临界区flag [j] =FLASE; // 退出区remainder section; // 剩余区 缺点：当两个进程几乎同时都想进入临界区时，它们分别将自己的标志值flag设置为TRUE，并且同时检测对方的状态（执行while语句），发现对方也要进入临界区，于是双方互相谦让，结果谁也进不了临界区，从而导致“饥饿”现象。 算法四：Peterson’s Algorithm为了防止两个进程为进入临界区而无限期等待，又设置变量turn，指示不允许进入临界区的进程编号，每个进程在先设置自己标志后再设置turn标志，不允许另一个进程进入。 这时，再同时检测另一个进程状态标志和不允许进入标志，这样可以保证当两个进程同时要求进入临界区，只允许一个进程进入临界区。 123456// Pi进程flag[i]=TURE; turn=j;while(flag[j]&amp;&amp;turn==j); critical section;flag[i]=FLASE;remainder section; 123456// Pj进程flag[j] =TRUE;turn=i; // 进入区while(flag[i]&amp;&amp;turn==i); // 进入区critical section; // 临界区flag[j]=FLASE; // 退出区remainder section; // 剩余区 本算法的基本思想是算法一和算法三的结合。利用flag解决临界资源的互斥访问，而利用turn解决“饥饿”现象。 硬件实现方法硬件实现和信号量相关。 计算机提供了特殊的硬件指令，允许对一个字中的内容进行检测和修正，或者是对两个字的内容进行交换等。通过硬件支持实现临界段问题的低级方法或称为元方法。 中断屏蔽方法当一个进程正在使用处理机执行它的临界区代码时，要防止其他进程再进入其临界区访问的最简单方法是禁止一切中断发生，或称之为屏蔽中断、关中断。因为CPU只在发生中断时引起进程切换，这样屏蔽中断就能保证当前运行进程将临界区代码顺利地执行完，从而保证了互斥的正确实现，然后再执行开中断。 其典型模式为： 123关中断;临界区;开中断; 缺点：这种方法限制了处理机交替执行程序的能力，因此执行的效率将会明显降低。对内核来说，当它执行更新变量或列表的几条指令期间关中断是很方便的，但将关中断的权力交给用户则很不明智，若一个进程关中断之后执行出现错误，而不再开中断，则系统可能会因此终止。 硬件指令方法1、TestAndSet指令：这条指令是原子操作，即执行该代码时不允许被中断。其功能是读出指定标志后把该标志设置为真。 指令的功能描述如下： 123456boolean TestAndSet(boolean *lock)&#123; boolean old; old = *lock; *lock=true; return old;&#125; 可以为每个临界资源设置一个共享布尔变量lock，表示资源的两种状态：true表示正被占用，初值为false。在进程访问临界资源之前，利用TestAndSet检查和修改标志lock；若有进程在临界区，则重复检查，直到进程退出。 利用该指令实现进程互斥的算法描述如下： 1234while TestAndSet(&amp;lock);// 进程的临界区代码段;lock=false;// 进程的其他代码 2、Swap指令：该指令的功能是交换两个字节的内容。其功能描述如下。 123456Swap(boolean *a, boolean *b)&#123; boolean temp; Temp=*a; *a = *b; *b = temp;&#125; 注意：以上对TestAndSet和Swap指令的描述仅仅是功能实现，并非软件实现定义（软件实现也有类似，比如CAS），事实上它们是由硬件逻辑直接实现的，不会被中断。 应为每个临界资源设置了一个共享布尔变量lock，初值为false；在每个进程中再设置一个局部布尔变量key，用于与lock交换信息。在进入临界区之前先利用Swap指令交换lock与key的内容，然后检查key的状态；有进程在临界区时，重复交换和检查过程，直到进程退出。 利用Swap指令实现进程互斥的算法描述如下： 123456key=true;while(key!=false)Swap(&amp;lock, &amp;key); // 进程的临界区代码段；lock=false;// 进程的其他代码； 硬件方法的优点：适用于任意数目的进程，不管是单处理机还是多处理机；简单、容易验证其正确性。可以支持进程内有多个临界区，只需为每个临界区设立一个布尔变量。硬件方法的缺点：进程等待进入临界区时要耗费处理机时间，不能实现让权等待。从等待进程中随机选择一个进入临界区，有的进程可能一直选不上，从而导致“饥饿”现象。 信号量信号量机构是一种功能较强的机制，可用来解决互斥与同步的问题，它只能被两个标准的原语wait(S)和signal(S)来访问，也可以记为“P操作”和“V操作”。 原语是指完成某种功能且不被分割不被中断执行的操作序列，通常可由硬件来实现完成不被分割执行特性的功能。如前述的“Test-and-Set”和“Swap”指令，就是由硬件实现的原子操作。原语功能的不被中断执行特性在单处理机时可由软件通过屏蔽中断方法实现。 原语之所以不能被中断执行，是因为原语对变量的操作过程如果被打断，可能会去运行另一个对同一变量的操作过程，从而出现临界段问题。如果能够找到一种解决临界段问题的元方法，就可以实现对共享变量操作的原子性。 整型信号量整型信号量被定义为一个用于表示资源数目的整型量S，wait和signal操作可描述为： 1234wait(S)&#123; while (S&lt;=0); S=S-1;&#125; 123signal(S)&#123; S=S+1;&#125; wait操作中，只要信号量S&lt;=0，就会不断地测试。因此，该机制并未遵循“让权等待” 的准则，而是使进程处于“忙等”的状态。 记录型信号量记录型信号量是不存在“忙等”现象的进程同步机制。除了需要一个用于代表资源数目的整型变量value外，再增加一个进程链表L，用于链接所有等待该资源的进程，记录型信号量是由于釆用了记录型的数据结构得名。 记录型信号量可描述为： 1234typedef struct&#123; int value; struct process *L;&#125; semaphore; 相应的wait(S)和signal(S)的操作如下： 1234567void wait (semaphore S) &#123; //相当于申请资源 S.value--; if(S.value&lt;0) &#123; add this process to S.L; block(S.L); &#125;&#125; wait操作，S.value–，表示进程请求一个该类资源，当S.value&lt;0 时，表示该类资源已分配完毕，因此进程应调用block原语，进行自我阻塞，放弃处理机，并插入到该类资源的等待队列S.L中，可见该机制遵循了“让权等待”的准则。 1234567void signal (semaphore S) &#123; //相当于释放资源 S.value++; if(S.value&lt;=0)&#123; remove a process P from S.L; wakeup(P); &#125;&#125; signal操作，表示进程释放一个资源，使系统中可供分配的该类资源数增1，故S.value++。若加1后仍是S.value&lt;=0，则表示在S.L中仍有等待该资源的进程被阻塞，故还应调用wakeup 原语，将S.L中的第一个等待进程唤醒。 利用信号量实现进程同步信号量机构能用于解决进程间各种同步问题。 设S为实现进程P1、P2同步的公共信号量，初值为0。进程P2中的语句y要使用进程P1中语句x的运行结果，所以只有当语句x执行完成之后语句y才可以执行。 其实现进程同步的算法如下： 12345678910111213semaphore S = 0; //初始化信号量P1() &#123; // … x; //语句x V(S); //告诉进程P2,语句乂已经完成&#125;P2() &#123; // … P(S) ; //检查语句x是否运行完成 y; // 检查无误，运行y语句 // …&#125; 利用信号量实现进程互斥信号量机构也能很方便地解决进程互斥问题。 设S为实现进程Pl、P2互斥的信号量，由于每次只允许一个进程进入临界区，所以S的初值应为1（即可用资源数为1)。只需把临界区置于P(S)和V(S)之间，即可实现两进程对临界资源的互斥访问。 其算法如下：12345678910111213141516semaphore S = 1; //初化信号量P1 ( ) &#123; // … P(S); // 准备开始访问临界资源，加锁 // 进程P1的临界区 V(S); // 访问结束，解锁 // …&#125;P2() &#123; // … P(S); //准备开始访问临界资源，加锁 // 进程P2的临界区； V(S); // 访问结束，解锁 // …&#125; 互斥的实现是不同进程对同一信号量进行P、V操作，一个进程在成功地对信号量执行了P操作后进入临界区，并在退出临界区后，由该进程本身对该信号量执行V操作，表示当前没有进程进入临界区，可以让其他进程进入。 利用信号量实现前驱关系信号量也可以用来描述程序之间或者语句之间的前驱关系。 下图给出了一个前驱图，其中S1, S2, S3, …, S6是最简单的程序段（只有一条语句）。为使各程序段能正确执行，应设置若干个初始值为“0”的信号量。例如，为保证S1-&gt;S2、 S1-&gt;S3的前驱关系，应分别设置信号量a1、a2。同样，为了保证 S2-&gt;S4、S2-&gt;S5、S3-&gt;S6、S4-&gt;S6、S5-&gt;S6，应设置信号量bl、b2、c、d、e。 实现算法如下：12345678910111213141516171819202122232425262728293031semaphore al=a2=bl=b2=c=d=e=0; //初始化信号量S1() &#123; // … V(al); V(a2) ; //S1已经运行完成&#125;S2() &#123; P(a1); //检查S1是否运行完成 // … V(bl); V(b2); // S2已经运行完成&#125;S3() &#123; P(a2); //检查S1是否已经运行完成 // … V(c); //S3已经运行完成&#125;S4() &#123; P(b1); //检查S2是否已经运行完成 // … V(d); //S4已经运行完成&#125;S5() &#123; P(b2); //检查S2是否已经运行完成 // … V(e); // S5已经运行完成&#125;S6() &#123; P(c); //检查S3是否已经运行完成 P(d); //检查S4是否已经运行完成 P(e); //检查S5是否已经运行完成 // …;&#125; 分析进程同步和互斥问题的方法步骤：1) 关系分析。找出问题中的进程数，并且分析它们之间的同步和互斥关系。同步、互斥、前驱关系直接按照上面例子中的经典范式改写。2) 整理思路。找出解决问题的关键点，并且根据做过的题目找出解决的思路。根据进程的操作流程确定P操作、V操作的大致顺序。3) 设置信号量。根据上面两步，设置需要的信号量，确定初值，完善整理。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>学习</tag>
        <tag>多线程</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的多线程和并发知识纲要]]></title>
    <url>%2F2017%2F08%2F21-java-concurrency-brief%2F</url>
    <content type="text"><![CDATA[Java的多线程和并发知识纲要高并发和多线程在很多业务场景中都会遇到，也是大公司的面试必问。自己对多线程的知识比较匮乏，需要借助大四的空余时光好好学习一下。找到一篇不错的纲要文章，对今后系统学习JUC有很大帮助，在此整理一下。 多线程开发有两个核心问题：一个是竞争，另一个是协作。竞争会出现线程安全问题，所以，本节首先总结线程安全的机制，然后是协作的机制。管理竞争和协作是复杂的，所以Java提供了更高层次的服务，比如并发容器类和异步任务执行服务，我们也会进行总结。 本节纲要如下：线程安全的机制线程的协作机制容器类任务执行服务 线程安全的机制线程表示一条单独的执行流，每个线程有自己的执行计数器，有自己的栈，但可以共享内存，共享内存是实现线程协作的基础，但共享内存有两个问题，竞态条件和内存可见性，之前章节探讨了解决这些问题的多种思路： 使用synchronized使用显式锁使用volatile使用原子变量和CAS写时复制使用ThreadLocal synchronizedsynchronized简单易用，它只是一个关键字，大部分情况下，放到类的方法声明上就可以了，既可以解决竞态条件问题，也可以解决内存可见性问题。 需要理解的是，它保护的是对象，而不是代码，只有对同一个对象的synchronized方法调用，synchronized才能保证它们被顺序调用。对于实例方法，这个对象是this，对于静态方法，这个对象是类对象，对于代码块，需要指定哪个对象。 另外，需要注意，它不能尝试获取锁，也不响应中断，还可能会死锁。不过，相比显式锁，synchronized简单易用，JVM也可以不断优化它的实现，应该被优先使用。 显式锁显式锁是相对于synchronized隐式锁而言的，它可以实现synchronzied同样的功能，但需要程序员自己创建锁，调用锁相关的接口，主要接口是Lock，主要实现类是ReentrantLock。 相比synchronized，显式锁支持以非阻塞方式获取锁、可以响应中断、可以限时、可以指定公平性、可以解决死锁问题，这使得它灵活的多。 在读多写少、读操作可以完全并行的场景中，可以使用读写锁以提高并发度，读写锁的接口是ReadWriteLock，实现类是ReentrantReadWriteLock。 volatilesynchronized和显式锁都是锁，使用锁可以实现安全，但使用锁是有成本的，获取不到锁的线程还需要等待，会有线程的上下文切换开销等。 保证安全不一定需要锁。 如果共享的对象只有一个，操作也只是进行最简单的get/set操作，set也不依赖于之前的值，那就不存在竞态条件问题，而只有内存可见性问题，这时，在变量的声明上加上volatile就可以了。 原子变量和CAS使用volatile，set的新值不能依赖于旧值，但很多时候，set的新值与原来的值有关，这时，也不一定需要锁，如果需要同步的代码比较简单，可以考虑原子变量，它们包含了一些以原子方式实现组合操作的方法，对于并发环境中的计数、产生序列号等需求，考虑使用原子变量而非锁。 原子变量的基础是CAS(compareAndSet)，比较并设置，一般的计算机系统都在硬件层次上直接支持CAS指令。 通过循环CAS的方式实现原子更新是一种重要的思维，相比synchronized，它是乐观的，而synchronized是悲观的，它是非阻塞式的，而synchronized是阻塞式的。 CAS是Java并发包的基础，基于它可以实现高效的、乐观、非阻塞式数据结构和算法，它也是并发包中锁、同步工具和各种容器的基础。 写时复制之所以会有线程安全的问题，是因为多个线程并发读写同一个对象，如果每个线程读写的对象都是不同的，或者，如果共享访问的对象是只读的，不能修改，那也就不存在线程安全问题了。 我们在介绍容器类CopyOnWriteArrayList和CopyOnWriteArraySet时介绍了写时复制技术，写时复制就是将共享访问的对象变为只读的，写的时候，再使用锁，保证只有一个线程写，写的线程不是直接修改原对象，而是新创建一个对象，对该对象修改完毕后，再原子性地修改共享访问的变量，让它指向新的对象。 ThreadLocalThreadLocal就是让每个线程，对同一个变量，都有自己的独有拷贝，每个线程实际访问的对象都是自己的，自然也就不存在线程安全问题了。 线程的协作机制多线程之间的核心问题，除了竞争，就是协作。 我们在67节和68节介绍了多种协作场景，比如生产者/消费者协作模式、主从协作模式、同时开始、集合点等。 之前章节探讨了协作的多种机制： wait/notify显式条件线程的中断协作工具类阻塞队列Future/FutureTask wait/notifywait/notify与synchronized配合一起使用，是线程的基本协作机制，每个对象都有一把锁和两个等待队列，一个是锁等待队列，放的是等待获取锁的线程，另一个是条件等待队列，放的是等待条件的线程，wait将自己加入条件等待队列，notify从条件等待队列上移除一个线程并唤醒，notifyAll移除所有线程并唤醒。 需要注意的是，wait/notify方法只能在synchronized代码块内被调用，调用wait时，线程会释放对象锁，被notify/notifyAll唤醒后，要重新竞争对象锁，获取到锁后才会从wait调用中返回，返回后，不代表其等待的条件就一定成立了，需要重新检查其等待的条件。 wait/notify方法看上去很简单，但往往难以理解wait等的到底是什么，而notify通知的又是什么，只能有一个条件等待队列，这也是wait/notify机制的局限性，这使得对于等待条件的分析变得复杂，67节和68节通过多个例子演示了其用法，这里就不赘述了。 显式条件显式条件与显式锁配合使用，与wait/notify相比，可以支持多个条件队列，代码更为易读，效率更高，使用时注意不要将signal/signalAll误写为notify/notifyAll。 中断Java中取消/关闭一个线程的方式是中断，中断并不是强迫终止一个线程，它是一种协作机制，是给线程传递一个取消信号，但是由线程来决定如何以及何时退出，线程在不同状态和IO操作时对中断有不同的反应，作为线程的实现者，应该提供明确的取消/关闭方法，并用文档清楚描述其行为，作为线程的调用者，应该使用其取消/关闭方法，而不是贸然调用interrupt。 协作工具类除了基本的显式锁和条件，针对常见的协作场景，Java并发包提供了多个用于协作的工具类。 信号量类Semaphore用于限制对资源的并发访问数。 倒计时门栓CountDownLatch主要用于不同角色线程间的同步，比如在”裁判”-“运动员”模式中，”裁判”线程让多个”运动员”线程同时开始，也可以用于协调主从线程，让主线程等待多个从线程的结果。 循环栅栏CyclicBarrier用于同一角色线程间的协调一致，所有线程在到达栅栏后都需要等待其他线程，等所有线程都到达后再一起通过，它是循环的，可以用作重复的同步。 阻塞队列对于最常见的生产者/消费者协作模式，可以使用阻塞队列，阻塞队列封装了锁和条件，生产者线程和消费者线程只需要调用队列的入队/出队方法就可以了，不需要考虑同步和协作问题。 阻塞队列有普通的先进先出队列，包括基于数组的ArrayBlockingQueue和基于链表的LinkedBlockingQueue/LinkedBlockingDeque，也有基于堆的优先级阻塞队列PriorityBlockingQueue，还有可用于定时任务的延时阻塞队列DelayQueue，以及用于特殊场景的阻塞队列SynchronousQueue和LinkedTransferQueue。 Future/FutureTask在常见的主从协作模式中，主线程往往是让子线程异步执行一项任务，获取其结果，手工创建子线程的写法往往比较麻烦，常见的模式是使用异步任务执行服务，不再手工创建线程，而只是提交任务，提交后马上得到一个结果，但这个结果不是最终结果，而是一个Future，Future是一个接口，主要实现类是FutureTask。 Future封装了主线程和执行线程关于执行状态和结果的同步，对于主线程而言，它只需要通过Future就可以查询异步任务的状态、获取最终结果、取消任务等，不需要再考虑同步和协作问题。 容器类线程安全的容器有两类，一类是同步容器，另一类是并发容器。 在理解synchronized一节，我们介绍了同步容器。关于并发容器，我们介绍了： 写时拷贝的List和SetConcurrentHashMap基于SkipList的Map和Set各种队列 同步容器Collections类中有一些静态方法，可以基于普通容器返回线程安全的同步容器，比如：public static Collection synchronizedCollection(Collection c)public static List synchronizedList(List list)public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) 它们是给所有容器方法都加上synchronized来实现安全的。同步容器的性能比较低，另外，还需要注意一些问题，比如复合操作和迭代，需要调用方手工使用synchronized同步，并注意不要同步错对象。 并发容器而并发容器是专为并发而设计的，线程安全、并发度更高、性能更高、迭代不会抛出ConcurrentModificationException、很多容器以原子方式支持一些复合操作。 写时拷贝的List和SetCopyOnWriteArrayList基于数组实现了List接口，CopyOnWriteArraySet基于CopyOnWriteArrayList实现了Set接口，它们采用了写时拷贝，适用于读远多于写，集合不太大的场合。不适用于数组很大，且修改频繁的场景。它们是以优化读操作为目标的，读不需要同步，性能很高，但在优化读的同时就牺牲了写的性能。 ConcurrentHashMapHashMap不是线程安全的，在并发更新的情况下，HashMap的链表结构可能形成环，出现死循环，占满CPU。ConcurrentHashMap是并发版的HashMap，通过分段锁和其他技术实现了高并发，读操作完全并行，写操作支持一定程度的并行，以原子方式支持一些复合操作，迭代不用加锁，不会抛出ConcurrentModificationException。 基于SkipList的Map和SetConcurrentHashMap不能排序，容器类中可以排序的Map和Set是TreeMap和TreeSet，但它们不是线程安全的。Java并发包中与TreeMap/TreeSet对应的并发版本是ConcurrentSkipListMap和ConcurrentSkipListSet。ConcurrentSkipListMap是基于SkipList实现的，SkipList称为跳跃表或跳表，是一种数据结构，主要操作复杂度为O(log(N))，并发版本采用跳表而不是树，是因为跳表更易于实现高效并发算法。 ConcurrentSkipListMap没有使用锁，所有操作都是无阻塞的，所有操作都可以并行，包括写。与ConcurrentHashMap类似，迭代器不会抛出ConcurrentModificationException，是弱一致的，也直接支持一些原子复合操作。 各种队列各种阻塞队列主要用于协作，非阻塞队列适用于多个线程并发使用一个队列的场合，有两个非阻塞队列，ConcurrentLinkedQueue和ConcurrentLinkedDeque，ConcurrentLinkedQueue实现了Queue接口，表示一个先进先出的队列，ConcurrentLinkedDeque实现了Deque接口，表示一个双端队列。它们都是基于链表实现的，都没有限制大小，是无界的，这两个类最基础的实现原理是循环CAS，没有使用锁。 任务执行服务关于任务执行服务，我们介绍了： 任务执行服务的基本概念主要实现方式 - 线程池方便处理结果的CompletionService定时任务 基本概念任务执行服务大大简化了执行异步任务所需的开发，它引入了一个”执行服务”的概念，将”任务的提交”和”任务的执行”相分离，”执行服务”封装了任务执行的细节，对于任务提交者而言，它可以关注于任务本身，如提交任务、获取结果、取消任务，而不需要关注任务执行的细节，如线程创建、任务调度、线程关闭等。 任务执行服务主要涉及以下接口： Runnable和Callable：表示要执行的异步任务Executor和ExecutorService：表示执行服务Future：表示异步任务的结果 使用者只需要通过ExecutorService提交任务，通过Future操作任务和结果即可，不需要关注线程创建和协调的细节。 线程池任务执行服务的主要实现机制是线程池，实现类是ThreadPoolExecutor，线程池主要由两个概念组成，一个是任务队列，另一个是工作者线程。任务队列是一个阻塞队列，保存待执行的任务。工作者线程主体就是一个循环，循环从队列中接受任务并执行。ThreadPoolExecutor有一些重要的参数，理解这些参数对于合理使用线程池非常重要，78节对这些参数进行了详细介绍，这里就不赘述了。 ThreadPoolExecutor实现了生产者/消费者模式，工作者线程就是消费者，任务提交者就是生产者，线程池自己维护任务队列。当我们碰到类似生产者/消费者问题时，应该优先考虑直接使用线程池，而非重新发明轮子，自己管理和维护消费者线程及任务队列。 CompletionService在异步任务程序中，一种场景是，主线程提交多个异步任务，然后希望有任务完成就处理结果，并且按任务完成顺序逐个处理，对于这种场景，Java并发包提供了一个方便的方法，使用CompletionService，这是一个接口，它的实现类是ExecutorCompletionService，它通过一个额外的结果队列，方便了对于多个异步任务结果的处理。 定时任务异步任务中，常见的任务是定时任务。在Java中，有两种方式实现定时任务：使用java.util包中的Timer和TimerTask使用Java并发包中的ScheduledExecutorService Timer有一些需要特别注意的事项：一个Timer对象背后只有一个Timer线程，这意味着，定时任务不能耗时太长，更不能是无限循环在执行任何一个任务的run方法时，一旦run抛出异常，Timer线程就会退出，从而所有定时任务都会被取消 ScheduledExecutorService的主要实现类是ScheduledThreadPoolExecutor，它没有Timer的问题：它的背后是线程池，可以有多个线程执行任务任务执行线程会捕获任务执行过程中的所有异常，一个定时任务的异常不会影响其他定时任务 所以，实践中建议使用ScheduledExecutorService。 小结针对多线程开发的两个核心问题，竞争和协作，本节总结了线程安全和协作的多种机制，针对高层服务，本节总结了并发容器和任务执行服务，它们让我们在更高的层次上访问共享的数据结构，执行任务，而避免陷入线程管理的细节。到此为止，关于并发我们就告一段落了。 与之前章节一样，我们的探讨都是基于Java 7的，不过Java 7引入了一个Fork/Join框架，我们没有讨论。Java 8在并发方面也有一些更新，比如：引入了CompletableFuture，增强了原来的Future，以便于实现组合式异步编程ConcurrentHashMap增加了一些新的方法，内部实现也进行了优化引入了流的概念，基于Fork/Join框架，可以非常方便的对大量数据进行并行操作 关于这些内容，我们在探讨Java 8的时候再继续讨论。 从下一节开始，我们来探讨Java中的一些动态特性，比如反射、注解、动态代理等。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>转载</tag>
        <tag>学习</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap的高并发下的死循环问题]]></title>
    <url>%2F2017%2F08%2F16-hashmap-infinite-loop%2F</url>
    <content type="text"><![CDATA[HashMap的高并发下的死循环问题在公司实习中，师傅陆陆续续的给我介绍了很多知识，有常用的框架使用，有新的技术，也有多线程和高并发的一些知识。多线程和高并发一直是大公司的必问知识点，不过自己的目前的知识水平还未达到那个层次，学习的路永无止境。前天介绍了一个HashMap在高并发状态下存在的问题，回去也学习了一下，找到一篇很不错的文章，在此整理一下。 死循环复现下面模拟实现在多线程（多用户）下的HashMap的死循环复现：12345678910111213141516public static void main(String[] args) &#123; final Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; 100; i++) &#123; Thread t = new Thread() &#123; Random rnd = new Random(); @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; map.put(rnd.nextInt(), 1); &#125; &#125; &#125;; t.start(); &#125;&#125; 程序运行没多久，可以在任务管理器中发现CPU的占用率达到100%，而且正是我们在跑的这个Java程序。 使用jstack可以定位到那个耗时最长的进程的具体代码，具体操作文章可以参考。 定位的结果显示，耗时最多的是HashMap的get(i)方法，为什么get方法会耗时最长呢？ Hash表数据结构回顾一下HashMap这个Java中的经典数据结构。 HashMap通常会用一个指针数组（假设为table[]）来做分散所有的key，当一个key被加入时，会通过Hash算法通过key算出这个数组的下标i，然后就把这个&lt;key, value&gt;插到table[i]中，如果有两个不同的key被算在了同一个i，那么就叫冲突，又叫碰撞，这样会在table[i]上形成一个链表(在Java8中已经优化为红黑树)。 我们知道，如果table[]的尺寸很小，比如只有2个，如果要放进10个keys的话，那么碰撞非常频繁，于是一个O(1)的查找算法，就变成了链表遍历，性能变成了O(n)，这是Hash表的缺陷（可参看《Hash Collision DoS 问题》）。 所以，Hash表的尺寸和容量非常的重要。一般来说，Hash表这个容器当有数据要插入时，都会检查容量有没有超过设定的thredhold，如果超过，需要增大Hash表的尺寸，但是这样一来，整个Hash表里的无素都需要被重算一遍。这叫rehash，这个成本相当的大。 相信大家对这个基础知识已经很熟悉了。 HashMap的rehash源代码下面，我们来看一下Java的HashMap的源代码。 Put一个Key,Value对到Hash表中：1234567891011121314151617181920public V put(K key, V value) &#123; ...... //算Hash值 int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); //如果该key已被插入，则替换掉旧的value （链接操作） for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; //该key不存在，需要增加一个结点 addEntry(hash, key, value, i);/****/ return null;&#125; 检查容量是否超标1234567void addEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); //查看当前的size是否超过了我们设定的阈值threshold，如果超过，需要resize if (size++ &gt;= threshold) resize(2 * table.length);/****/&#125; 新建一个更大尺寸的hash表，然后把数据从老的Hash表中迁移到新的Hash表中。1234567891011void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; ...... //创建一个新的Hash Table Entry[] newTable = new Entry[newCapacity]; //将Old Hash Table上的数据迁移到New Hash Table上 transfer(newTable);/****/ table = newTable; threshold = (int)(newCapacity * loadFactor);&#125; 迁移的源代码，注意高亮处：1234567891011121314151617181920void transfer(Entry[] newTable) &#123; Entry[] src = table; int newCapacity = newTable.length; //下面这段代码的意思是： // 从OldTable里摘一个元素出来，然后放到NewTable中 for (int j = 0; j &lt; src.length; j++) &#123; Entry&lt;K,V&gt; e = src[j]; if (e != null) &#123; src[j] = null; do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //注意这一段 e.next = newTable[i];/****/ newTable[i] = e;/****/ e = next;/****/ &#125; while (e != null); &#125; &#125;&#125; 好了，上面的代码一般使用的话，没有什么问题。 正常ReHash的过程画了个图做了个演示。 我假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。最上面的是old hash 表，其中的Hash表的size=2, 所以key = 3, 7, 5，在mod 2以后都冲突在table[1]这里了。接下来的三个步骤是Hash表 resize成4，然后所有的&lt;key,value&gt; 重新rehash的过程 并发下的ReHash1）假设我们有两个线程。我用红色和浅蓝色标注了一下。 我们再回头看一下我们的 transfer代码中的这个细节： 1234567do &#123; Entry&lt;K,V&gt; next = e.next; // &lt;--假设线程一执行到这里就被调度挂起了 int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next;&#125; while (e != null); 而我们的线程二执行完成了。于是我们有下面的这个样子。 注意，因为Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。我们可以看到链表的顺序被反转后。 2）线程一被调度回来执行。 先是执行 newTalbe[i] = e;然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3) 3）一切安好。 线程一接着工作。把key(7)摘下来，放到newTable[i]的第一个，然后把e和next往下移。 4）环形链接出现。 e.next = newTable[i] 导致 key(3).next 指向了 key(7) 注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。 于是，当我们的线程一调用到，HashTable.get(11)时，悲剧就出现了——Infinite Loop。 解决HashMap不支持并发，并发情况下可以使用1、ConcurrentHashMap，其通过分段锁和其他技术实现了高并发，支持原子条件更新操作，不会抛出ConcurrentModificationException，实现了弱一致性。2、final Map&lt;Integer, Integer&gt; map = Collections.synchronizedMap(new HashMap&lt;Integer, Integer&gt;());]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>转载</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统原理之IO管理]]></title>
    <url>%2F2017%2F07%2F29-operation-system-io%2F</url>
    <content type="text"><![CDATA[操作系统原理之IO管理转载整理自这篇博客。 操作系统原理之基础知识操作系统原理之死锁操作系统原理之处理机调度操作系统原理之信号量操作系统原理之进程和线程管理操作系统原理之内存管理操作系统原理之文件管理 I/O设备分类I/O设备管理是操作系统设计中最凌乱也最具挑战性的部分。由于它包含了很多领域的不同设备以及与设备相关的应用程序，因此很难有一个通用且一致的设计方案。 所以在理解设备管理之前，应该先了解具体的I/O设备类型。计算机系统中的I/O设备按使用特性可分为以下类型： 1) 人机交互类外部设备：用于同计算机用户之间交互的设备，如打印机、显示器、鼠标、键盘等。这类设备数据交换速度相对较慢，通常是以字节为单位进行数据交换。2) 存储设备：用于存储程序和数据的设备，如磁盘、磁带、光盘等。这类设备用于数据交换，速度较快，通常以多字节组成的块为单位进行数据交换。3) 网络通信设备：用于与远程设备通信的设备，如各种网络接口、调制解调器等。其速度介于前两类设备之间。网络通信设备在使用和管理上与前两类设备也有很大不同。 除了上面最常见的分类方法，I/O设备还可以按以下方法分类： 1) 按传输速率分类：低速设备：传输速率仅为每秒几个到数百个字节的一类设备，如键盘、鼠标等。中速设备：传输速率在每秒数千个字节至数万个字节的一类设备，如行式打印机、 激光打印机等。高速设备：传输速率在数百个千字节至千兆字节的一类设备，如磁带机、磁盘机、 光盘机等。 2) 按信息交换的单位分类：a. 块设备：由于信息的存取总是以数据块为单位，所以存储信息的设备称为块设备。它属于有结构设备，如磁盘等。磁盘设备的基本特征是传输速率较高，以及可寻址，即对它可随机地读/写任一块。b. 字符设备：因为其传输的基本单位是字符，所以该类设备被称为字符设备。它属于无结构类型，如交互式终端机、打印机等。它们的基本特征是传输速率低、不可寻址，并且在输入/输出时常釆用中断驱动方式。 I/O设备控制方式 设备管理的主要任务之一是控制设备和内存或处理机之间的数据传送。 外围设备和内存之间的输入/输出控制方式有四种，下面分别介绍： 在Java中，NIO下就支持了DMA和通道方式传输数据。 程序直接控制方式（主动询问）如下图所示，计算机从外部设备读取数据到存储器，每次读一个字的数据。对读入的每个字，CPU需要对外设状态进行循环检查，直到确定该字已经在I/O控制器的数据寄存器中。在程序直接控制方式中，由于CPU的高速性和I/O设备的低速性，致使CPU的绝大部分时间都处于等待I/O设备完成数据I/O的阻塞状态中，无法再做其他的事情，造成了CPU资源的极大浪费。 在该方式中，CPU之所以要不断地测试I/O设备的状态，就是因为在CPU中没有釆用中断机构，使I/O设备无法向CPU报告它已完成了一个字符的输入操作。 程序直接控制方式虽然简单易于实现，但是其缺点也是显而易见的，由于CPU和I/O设备只能串行工作，导致CPU的利用率可能会相当低。 中断驱动方式中断驱动方式的思想是，允许I/O设备主动打断CPU的运行并请求服务，从而能部分“解放”CPU，使得CPU在向I/O控制器发送读命令之后可以继续做其他有用的工作。 我们从I/O控制器和CPU两个角度分别来看中断驱动方式的工作过程： 1）从I/O控制器的角度来看：I/O控制器从CPU接收一个读命令，然后从外围设备读数据。一旦数据读入到该I/O控制器的数据寄存器，便通过控制线给CPU发出一个中断信号，表示数据已准备好，然后等待CPU请求该数据。I/O控制器收到CPU发出的取数据请求后，将数据放到数据总线上，传到CPU的寄存器中。至此，本次I/O操作完成，I/O控制器又可幵始下一次I/O操作。 2）从CPU的角度来看：CPU发出读命令后，保存当前运行作业的上下文（现场，如程序计数器及处理机寄存器），接着转去执行其他作业。在每个指令周期的末尾，CPU检查中断。当有来自I/O控制器的中断时，CPU保存当前正在运行作业的上下文，转去执行中断处理程序处理该中断。这时，CPU从I/O控制器读一个字的数据传送到寄存器，并存入主存，同时，CPU恢复出当时发出I/O命令对应的的上下文，将这个作业继续运行下去。 中断驱动方式比程序直接控制方式有效，但由于数据中的每个字在存储器与I/O控制器之间的传输都必须经过CPU，这就导致了中断驱动方式仍然需要CPU来处理IO请求。 DMA方式在中断驱动方式中，I/O设备与内存之间的数据交换必须要经过CPU中的寄存器，所以速度还是受限的，而DMA（直接存储器存取）方式的基本思想是在I/O设备和内存之间开辟直接的数据交换通路，基本上“解放”了CPU（还是有一点占有的）。 DMA方式的特点是：1、基本单位是数据块。2、所传送的数据，是从设备直接送入内存的，或者相反。 仅在传送一个或多个数据块的开始和结束时，才需CPU干预，接下来整块数据的传送是在DMA控制器的控制下完成的。 为了实现在主机与控制器之间成块数据的直接交换，必须在DMA控制器中设置如下四类寄存器：1、命令/状态寄存器(CR)：用于接收从CPU发来的I/O命令或有关控制信息，或设备的状态。2、内存地址寄存器(MAR)：在输入时，它存放把数据从设备传送到内存的起始目标地址；在输出时，它存放由内存到设备的内存源地址。3、数据寄存器(DR)：用于暂存从设备到内存，或从内存到设备的数据。4、数据计数器(DC)：存放本次CPU要读或写的字（节）数。 DMA控制器的组成： 如上图所示，DMA方式的工作过程是：1、CPU读写数据时，它给I/O控制器发出一条命令，启动DMA控制器，然后继续其他工作。2、之后CPU就把控制操作委托给DMA控制器，由该控制器负责处理。DMA控制器直接与存储器交互，传送整个数据块，每次传送一个字，这个过程不需要CPU参与。3、当传送完成后，DMA控制器发送一个中断信号给CPU，告知工作完成。 DMA模式下只有在传送开始和结束时才需要CPU的参与。 DMA控制方式与中断驱动方式的主要区别：1、中断驱动方式在每个数据需要传输时中断CPU，而DMA控制方式则是在所要求传送的一批数据全部传送结束时才中断CPU。2、中断驱动方式数据传送是在中断处理时由CPU控制完成的，而DMA控制方式则是在DMA控制器的控制下完成的。 通道控制方式I/O通道是指专门负责输入/输出的处理机。I/O通道方式是对DMA方式的发展，它可以进一步减少CPU的干预，即把对一个数据块的读（或写）为单位的干预，减少为对一组数据块的读（或写）及有关的控制和管理为单位的干预。同时，又可以实现CPU、通道和I/O设备三者的并行操作，从而更有效地提高整个系统的资源利用率。 例如，当CPU要完成一组相关的读（或写）操作及有关控制时，只需向I/O通道发送一条I/O指令，以给出其所要执行的通道程序的首地址和要访问的I/O设备，通道接到该指令后，通过执行通道程序便可完成CPU指定的I/O任务，数据传送结束时向CPU发中断请求。 I/O通道与一般处理机的区别是：通道指令的类型单一，没有自己的内存，通道所执行的通道程序是放在主机的内存中的，也就是说通道与CPU共享内存。 I/O通道与DMA方式的区别是：DMA方式需要CPU来控制传输的数据块大小、传输的内存位置，而通道方式中这些信息是由通道控制的，更能解放CPU。另外，每个DMA控制器对应一台设备与内存传递数据，而一个通道可以控制多台设备与内存的数据交换。 I/O子系统层次结构I/O软件涉及的面非常广，往下与硬件有着密切的联系，往上又与用户直接交互，它与进程管理、存储器管理、文件管理等都存在着一定的联系，因为后三者都需要I/O来实现一些操作。 为了使复杂的I/O软件具有清晰的结构，良好的可移植性和适应性，在I/O软件中普遍釆用了层次式结构，将系统输入/输出功能组织成一系列的层次，每一层都利用其下层提供的服务，完成输入/输出功能中的某些子功能，并屏蔽这些功能实现的细节，向高层提供服务。在层次式结构的I/O软件中，只要层次间的接口不变，对某一层次中的软件的修改都不会引起其下层或高层代码的变更，仅最底层才涉及硬件的具体特性。 一个比较合理的层次划分如下图所示： 整个I/O系统可以看成具有五个层次的系统结构，各层次及其功能如下： 用户层I/O软件1) 用户层I/O软件：实现与用户交互的接口，用户可直接调用在用户层提供的、与I/O操作有关的库函数，对设备进行操作。一般而言，大部分的I/O软件都在操作系统内部，但仍有一小部分在用户层，包括与用户程序链接在一起的库函数，以及完全运行于内核之外的一些程序。用户层软件必须通过一组系统调用来获取操作系统服务。 设备独立性软件2) 设备独立性软件：用于实现用户程序与设备驱动器的统一接口、设备命令、设备保护、以友设备分配与释放等，同时为设备管理和数据传送提供必要的存储空间。设备独立性也称设备无关性，使得应用程序独立于具体使用的物理设备。为了实现设备独立性而引入了逻辑设备和物理设备这两个概念。在应用程序中，使用逻辑设备名来请求使用某类设备；在系统实际的执行过程中，将逻辑设备名映射成物理设备名使用。 这种使用逻辑设备名的好处是：1、增加设备分配的灵活性；2、易于实现I/O重定向，所谓I/O重定向，是指用于I/O操作的设备可以更换（即重定向），而不必改变应用程序，比如原本输入到屏幕上的文字输入到硬盘文件中去。 为了实现设备独立性，必须在驱动程序之上设置一层设备独立性软件。 总的来说，设备独立性软件的主要功能可分以为以下两个方面：1、执行所有设备的公共操作。包括：对设备的分配与回收；将逻辑设备名映射为物理设备名；对设备进行保护，禁止用户直接访问设备；缓冲管理；差错控制；提供独立于设备的大小统一的逻辑块，屏蔽设备之间信息交换单位大小和传输速率的差异。2、向用户层（或文件层）提供统一接口。无论何种设备，它们向用户所提供的接口应该是相同的。例如，对各种设备的读/写操作，在应用程序中都统一使用read/write命令等。 设备驱动程序3) 设备驱动程序：与硬件直接相关，负责具体实现系统对设备发出的操作指令，驱动I/O设备工作的驱动程序。 通常，每一类设备配置一个设备驱动程序，它是I/O进程与设备控制器之间的通信程序，常以进程形式存在。一方面设备驱动程序向上层用户程序提供一组标准接口，设备具体的差别被设备驱动程序所封装，用于接收上层软件发来的抽象I/O要求，如read和write命令，转换为具体要求后，发送给设备控制器，控制I/O设备工作。另一方面它也将由设备控制器发来的信号传送给上层软件。从而为I/O内核子系统隐藏设备控制器之间的差异。 中断处理程序4)中断处理程序：用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完后恢复被中断进程的现场后，返回到被中断进程。 中断处理层的主要任务有：进行进程上下文的切换，对处理中断信号源进行测试，读取设备状态和修改进程状态等。由于中断处理与硬件紧密相关，对用户而言，应尽量加以屏蔽，故应放在操作系统的底层，系统的其余部分尽可能少地与之发生联系。 硬件设备5) 硬件设备：I/O设备通常包括一个机械部件和一个电子部件。为了达到设计的模块性和通用性，一般将其分开：电子部件称为设备控制器（或适配器），在个人计算机中，通常是一块插入主板扩充槽的印刷电路板（被称为主板），机械部件则是设备本身（使用PCI插槽、USB接口等接入）。 设备控制器通过寄存器与CPU通信，在某些计算机上，这些寄存器占用内存地址的一部分，称为内存映像I/O；另一些计算机则釆用I/O专用地址，寄存器独立编址。操作系统通过向控制器寄存器写命令字来执行I/O功能。控制器收到一条命令后，CPU可以转向进行其他工作，而让设备控制器自行完成具体的I/O操作。当命令执行完毕后，控制器发出一个中断信号，操作系统重新获得CPU的控制权并检查执行结果，此时，CPU仍旧是从控制器寄存器中读取信息来获得执行结果和设备的状态信息。 设备控制器的主要功能为：1、接收和识别CPU或通道发来的命令，如磁盘控制器能接收读、写、查找等命令。2、实现数据交换，包括设备和控制器之间的数据传输；通过数据总线或通道，控制器和主存之间的数据传输。3、发现和记录设备及自身的状态信息，供CPU处理使用。4、设备地址识别。 为实现上述功能，设备控制器必须包含以下组成部分：1、设备控制器与CPU的接口。该接口有三类信号线：数据线、地址线和控制线。数据线通常与两类寄存器相连接：数据寄存器（存放从设备送来的输入数据或从CPU送来的输出数据）和控制/状态寄存器（存放从CPU送来的控制信息或设备的状态信息)。2、设备控制器与设备的接口。设备控制器连接设备需要相应数量的接口，一个接口连接一台设备。每个接口中都存在数据、控制和状态三种类型的信号。3、I/O控制逻辑。用于实现对设备的控制。它通过一组控制线与CPU交互，对从CPU收到的I/O命令进行译码。CPU启动设备时，将启动命令发送给控制器，同时通过地址线把地址发送给控制器，由控制器的I/O逻辑对地址进行译码，并相应地对所选设备进行控制。 I/O子系统概述由于I/O设备种类繁多，功能和传输速率差异巨大，需要多种方法来进行设备控制。这些方法共同组成了操作系统内核的I/O子系统，它将内核的其他方面从繁重的I/O设备管理中解放出来。I/O核心子系统提供的服务主要有I/O调度、缓冲与高速缓存、设备分配与回收、假脱机、设备保护和差错处理等。 I/O调度概念I/O调度就是按照确定好的顺序来执行这些I/O请求。应用程序所发布的系统调用的顺序不一定总是最佳选择，所以需要I/O调度来改善系统整体性能，使进程之间公平地共享设备访问，减少I/O完成所需要的平均等待时间。 操作系统开发人员通过为每个设备维护一个请求队列来实现调度。当一个应用程序执行阻塞I/O系统调用时，该请求就加到相应设备的队列上，I/O调度会重新安排队列顺序以改善系统总体效率和应用程序的平均响应时间。 I/O子系统还可以使用主存或磁盘上的存储空间的技术，如缓冲、高速缓冲、假脱机等，来改善计算机效率。 高速缓存与缓冲区利用缓存技术来提高I/O速度。 磁盘高速缓存(Disk Cache)操作系统中使用磁盘高速缓存技术来提高磁盘的I/O速度，对高速缓存复制的访问要比原始数据访问更为高效。例如，正在运行的进程的指令既存储在磁盘上，也存储在物理内存上，也被复制到CPU的二级和一级高速缓存中。 不过，磁盘高速缓存技术不同于通常意义下的介于CPU与内存之间的小容量高速存储器，而是指利用内存中的存储空间来暂存从磁盘中读出的一系列盘块中的信息。 磁盘高速缓存在逻辑上是属于磁盘的，但是在物理上却是驻留在内存中的数据。 高速缓存在内存中分为两种形式：1、一种是在内存中开辟一个单独的存储空间作为磁速缓存，大小固定；2、另一种是把未利用的内存空间作为一个缓沖池，供请求分页系统和磁盘I/O时共享。 CPU缓冲区(Buffer)在设备管理子系统中，引入缓冲区的目的主要有：1、缓和CPU与I/O设备间速度不匹配的矛盾。2、减少对CPU的中断频率，放宽对CPU中断响应时间的限制。3、解决基本数据单元大小（即数据粒度）不匹配的问题。4、提高CPU和I/O设备之间的并行性。 其实现方法有：1、釆用硬件缓冲器，但由于成本高所以除一些关键部位外，一般不釆用硬件缓冲器。2、釆用缓冲区（位于内存区域）。 根据系统设置缓冲器的个数，缓冲技术可以分为： 单缓冲在设备和处理机之间设置一个缓冲区。设备和处理机交换数据时，先把被交换数据写入缓冲区，然后需要数据的设备或处理机从缓冲区取走数据。 如下图所示，在块设备输入时，假定从磁盘把一块数据输入到缓冲区的时间为T，操作系统将该缓冲区中的数据传送到用户区的时间为M，而CPU对这一块数据处理的时间为C。由于T和C是可以并行的，当T&gt;C时，系统对每一块数据的处理时间为M+T，反之则为M+C，故可把系统对每一块数据的处理时间表示为Max{C,T}+M。 双缓冲根据单缓冲的特点，CPU在传送时间M内处于空闲状态，由此引入双缓冲。I/O设备输入数据时先装填到缓冲区1，在缓冲区1填满后才开始装填缓冲区2，与此同时处理机可以从缓冲区1中取出数据放入用户进程处理，当缓冲区1中的数据处理完后，若缓冲区2已填满，则处理机又从缓冲区2中取出数据放入用户进程处理，而I/O设备又可以装填缓冲区1。 双缓冲机制提高了处理机和输入设备的并行操作的程度。 如下图所示，系统处理一块数据的时间可以粗略地认为是Max{C,T}。如果C&lt;T，可使块设备连续输入（上图中所示情况)；如果C&gt;T，则可使CPU不必等待设备输入。 对于字符设备，若釆用行输入方式，则釆用双缓冲可使用户在输入完第一行之后，在CPU执行第一行中的命令的同时，用户可继续向第二缓冲区输入下一行数据。而单缓冲情况下则必须等待一行数据被提取完毕才可输入下一行的数据。 如果两台机器之间通信仅配置了单缓冲，如下图(a)所示。那么，它们在任一时刻都只能实现单方向的数据传输。例如，只允许把数据从A机传送到B机，或者从B机传送到A机，而绝不允许双方同时向对方发送数据。为了实现双向数据传输，必须在两台机器中都设置两个缓冲区，一个用做发送缓冲区，另一个用做接收缓冲区，如下图(b)所示。 循环缓冲包含多个大小相等的缓冲区，每个缓冲区中有一个链接指针指向下一个缓冲区，最后一个缓冲区指针指向第一个缓冲区，多个缓冲区构成一个环形。 循环缓冲用于输入/输出时，还需要有两个指针in和out。对输入而言，首先要从设备接收数据到缓冲区中，in指针指向可以输入数据的第一个空缓冲区；当运行进程需要数据时，从循环缓冲区中取一个装满数据的缓冲区，并从此缓冲区中提取数据，out指针指向可以提取数据的第一个满缓冲区。输出则正好相反。 缓冲池由多个系统公用的缓冲区组成，缓冲区按其使用状况可以形成三个队列：空缓冲队列、装满输入数据的缓冲队列（输入队列）和装满输出数据的缓沖队列（输出队列）。还应具有四种缓冲区：用于收容输入数据的工作缓冲区、用于提取输入数据的工作缓冲区、用于收容输出数据的工作缓冲区及用于提取输出数据的工作缓冲区，如下图所示。 当输入进程需要输入数据时，便从空缓冲队列的队首摘下一个空缓冲区，把它作为收容输入工作缓冲区，然后把输入数据输入其中，装满后再将它挂到输入队列队尾。当计算进程需要输入数据时，便从输入队列取得一个缓冲区作为提取输入工作缓冲区，计算进程从中提取数据，数据用完后再将它挂到空缓冲队列尾。当计算进程需要输出数据时，便从空缓冲队列的队首取得一个空缓冲区，作为收容输出工作缓冲区，当其中装满输出数据后，再将它挂到输出队列队尾。当要输出时，由输出进程从输出队列中取得一个装满输出数据的缓冲区，作为提取输出工作缓冲区，当数据提取完后，再将它挂到空缓冲队列的队尾。 高速缓存与缓冲区的比较高速缓存是可以保存数据拷贝的高速存储器，访问高速缓存比访问原始数据更高效速度更快。其对比见下表。 设备分配与回收设备分配概述设备分配是指根据用户的I/O请求分配所需的设备。分配的总原则是充分发挥设备的使用效率，尽可能地让设备忙碌，又要避免由于不合理的分配方法造成进程死锁。 从设备的特性来看，釆用下述三种使用方式的设备分别称为独占设备、共享设备和虚拟设备三类。 1) 独占式使用设备。指在申请设备时，如果设备空闲，就将其独占，不再允许其他进程申请使用，一直等到该设备被释放才允许其他进程申请使用。例如，打印机，在使用它打印时，只能独占式使用，否则在同一张纸上交替打印不同任务的内容，无法正常阅读。 2) 分时式共享使用设备。独占式使用设备时，设备利用率很低，当设备没有独占使用的要求时，可以通过分时共享使用，提高利用率。例如，对磁盘设备的I/O操作，各进程的每次I/O操作请求可以通过分时来交替进行。 3) 以SPOOLing方式使用外部设备。SPOOLing技术是在批处理操作系统时代引入的，即假脱机I/O技术。这种技术用于对设备的操作，实质上就是对I/O操作进行批处理。 设备分配的数据结构设备分配依据的主要数据结构有设备控制表(DCT)、控制器控制表(COCT)、通道控制表(CHCT)和系统设备表(SDT)。 各数据结构功能如下：设备控制表DCT：系统为每一个设备配置一张DCT，如下图所示。它用于记录设备的特性以及与I/O控制器连接的情况。DCT包括设备标识符、设备类型、设备状态、指向控制器控制表COCT的指针等。其中，设备状态指示设备是忙还是空闲，设备队列指针指向等待使用该设备的进程组成的等待队列，控制表指针指向与该设备相连接的设备控制器。 设备控制表： 控制器控制表COCT：每个控制器都配有一张COCT，如图5-10a所示。它反映设备控制器的使用状态以及和通道的连接情况等。通道控制表CHCT：每个通道配有一张CHCT，如图5-10b所示。系统设备表SDT：整个系统只有一张SDT，如图5-10c所示。它记录已连接到系统中的所有物理设备的情况，每个物理设备占一个表目。 COCT、CHCT和SDT： 由于在多道程序系统中，进程数一般多于资源数，会引起资源的竞争。因此，要有一套合理的分配原则，主要考虑的因素有：I/O设备的固有属性，I/O设备的分配算法，设备分配的安全性以及设备独立性。 设备分配的策略1) 设备分配原则：设备分配应根据设备特性、用户要求和系统配置情况。分配的总原则既要充分发挥设备的使用效率，又要避免造成进程死锁，还要将用户程序和具体设备隔离开。 2) 设备分配方式：设备分配方式有静态分配和动态分配两种。 静态分配主要用于对独占设备的分配，它在用户作业开始执行前，由系统一次性分配该作业所要求的全部设备、控制器（和通道)。一旦分配后，这些设备、控制器（和通道）就一直为该作业所占用，直到该作业被撤销。静态分配方式不会出现死锁，但设备的使用效率低。因此，静态分配方式弁不符合分配的总原则。 动态分配是在进程执行过程中根据执行需要进行。当进程需要设备时，通过系统调用命令向系统提出设备请求，由系统按照事先规定的策略给进程分配所需要的设备、I/O控制器，一旦用完之后，便立即释放。动态分配方式有利于提高设备的利用率，但如果分配算法使用不当，则有可能造成进程死锁。 3) 设备分配算法：常用的动态设备分配算法有先请求先分配、优先级高者优先等。 对于独占设备，既可以釆用动态分配方式也可以静态分配方式，往往釆用静态分配方式，即在作业执行前，将作业所要用的这一类设备分配给它。共享设备可被多个进程所共享，一般釆用动态分配方式，但在每个I/O传输的单位时间内只被一个进程所占有，通常釆用先请求先分配和优先级高者先分的分配算法。 设备分配的安全性设备分配的安全性是指设备分配中应防止发生进程死锁。 1) 安全分配方式：每当进程发出I/O请求后便进入阻塞状态，直到其I/O操作完成时才被唤醒。这样，一旦进程已经获得某种设备后便阻塞，不能再请求任何资源，而且在它阻塞时也不保持任何资源。i点是设备分配安全；缺点是CPU和I/O设备是串行工作的（对同一进程而言)。 2) 不安全分配方式：进程在发出I/O请求后继续运行，需要时又发出第二个、第三个I/O请求等。仅当进程所请求的设备已被另一进程占用时，才进入阻塞状态。优点是一个进程可同时操作多个设备，从而使进程推进迅速；缺点是这种设备分配有可能产生死锁。 逻辑设备名到物理设备名的映射为了提高设备分配的灵活性和设备的利用率、方便实现I/O重定向，因此引入了设备独立性。 设备独立性是指应用程序独立于具体使用的物理设备。 为了实现设备独立性，在应用程序中使用逻辑设备名来请求使用某类设备，在系统中设置一张逻辑设备表(Logical Unit Table, LUT)，用于将逻辑设备名映射为物理设备名。LUT 表项包括逻辑设备名、物理设备名和设备驱动程序入口地址；当进程用逻辑设备名来请求分配设备时，系统为它分配相应的物理设备，并在LUT中建立一个表项，以后进程再利用逻辑设备名请求I/0操作时，系统通过查找LUT来寻找相应的物理设备和驱动程序。 在系统中可釆取两种方式建立逻辑设备表：在整个系统中只设置一张LUT。这样，所有进程的设备分配情况都记录在这张表中，故不允许有相同的逻辑设备名，主要适用于单用户系统中。为每个用户设置一张LUT。当用户登录时，系统便为该用户建立一个进程，同时也为之建立一张LUT，并将该表放入进程的PCB中。 SPOOLing技术(假脱机技术) 为了缓和CPU的高速性与I/O设备低速性之间的矛盾而引入了脱机输入/输出技术。 该技术是利用专门的外围控制机，将低速I/O设备上的数据传送到高速磁盘上；或者相反。 SPOOLing的意思是外部设备同时联机操作，又称为假脱机输入/输出操作，是操作系统中釆用的一项将独占设备改造成共享设备的技术。 SPOOLing系统组成如下图所示： 输入井和输出井输入井和输出井是在磁盘上开辟出的两个存储区域。 输入井模拟脱机输入时的磁盘，用于收容I/O设备输入的数据。输出井模拟脱机输出时的磁盘，用于收容用户程序的输出数据。 输入缓冲区和输出缓冲区输入缓冲区和输出缓冲区是在内存中开辟的两个缓冲区。 输入缓冲区用于暂存由输入设备送来的数据，以后再传送到输入井。输出缓冲区用于暂存从输出井送来的数据，以后再传送到输出设备。 输入进程和输出进程输入进程模拟脱机输入时的外围控制机，将用户要求的数据从输入机通过输入缓冲区再送到输入井。当CPU需要输入数据时，直接将数据从输入井读入内存。输出进程模拟脱机输出时的外围控制机，把用户要求输出的数据先从内存送到输出并，待输出设备空闲时，再将输出井中的数据经过输出缓冲区送到输出设备。 共享打印机是使用SPOOLing技术的一个实例，这项技术已被广泛地用于多用户系统和局域网络中。当用户进程请求打印输出时，SPOOLing系统同意为它打印输出，但并不真正立即把打印机分配给该用户进程，而只为它做两件事：1、由输出进程在输出井中为之申请一个空闲磁盘块区，并将要打印的数据送入其中。2、输出进程再为用户进程申请一张空白的用户请求打印表，并将用户的打印要求填入其中，再将该表挂到请求打印队列上。 SPOOLing系统的主要特点有：提高了I/O的速度；将独占设备改造为共享设备；实现了虚拟设备功能。 总结思考1) 分配设备。首先根据I/O请求中的物理设备名查找系统设备表（SDT)，从中找出该设备的DCT，再根据DCT中的设备状态字段，可知该设备是否正忙。若忙，便将请求I/O进程的PCB挂在设备队列上；空闲则按照一定算法计算设备分配的安全性，安全则将设备分配给请求进程，否则仍将其PCB挂到设备队列。 2) 分配控制器。系统把设备分配给请求I/O的进程后，再到其DCT中找出与该设备连接的控制器的COCT，从COCT中的状态字段中可知该控制器是否忙碌。若忙，便将请求I/O进程的PCB挂在该控制器的等待队列上；空闲便将控制器分配给进程。 3) 分配通道。在该COCT中又可找到与该控制器连接的通道的CHCT，再根据CHCT内的状态信息，可知该通道是否忙碌。若忙，便将请求I/O的进程挂在该通道的等待队列上；空闲便将该通道分配给进程。 只有在上述三者（设备、控制器、通道）都分配成功时，这次设备的分配才算成功，然后便可启动该I/O设备进行数据传送。 为使独占设备的分配具有更强的灵活性，提高分配的成功率，还可以从以下两方面对基本的设备分配程序加以改进： 1、增加设备的独立性。进程使用逻辑设备名请求I/O。这样，系统首先从SDT中找出第一个该类设备的DCT。若该设备忙，又查找第二个该类设备的DCT。仅当所有该类设备都忙时，才把进程挂在该类设备的等待队列上；只要有一个该类设备可用，系统便进一步计算分配该设备的安全性。 2、考虑多通路情况。为防止I/O系统的“瓶颈”现象，通常釆用多通路的I/O系统结构。此时对控制器和通道的分配同样要经过几次反复，即若设备（控制器）所连接的第一个控制器（通道）忙时，应查看其所连接的第二个控制器（通道)，仅当所有的控制器（通道）都忙时，此次的控制器（通道）分配才算失败，才把进程挂在控制器（通道）的等待队列上。而只要有一个控制器（通道）可用，系统便可将它分配给进程。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>学习</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统原理之内存管理]]></title>
    <url>%2F2017%2F07%2F25-operation-system-memory%2F</url>
    <content type="text"><![CDATA[操作系统原理之内存管理整理自这篇博客。 操作系统原理之基础知识操作系统原理之死锁操作系统原理之处理机调度操作系统原理之信号量操作系统原理之进程和线程管理 内存管理的概念内存管理(Memory Management)是操作系统设计中最重要和最复杂的内容之一。虽然计算机硬件一直在飞速发展，内存容量也在不断增长，但是仍然不可能将所有用户进程和系统所需要的全部程序和数据放入主存中，所以操作系统必须将内存空间进行合理地划分和有效地动态分配。操作系统对内存划分和动态分配，就是内存管理的概念。 有效的内存管理在多道程序设计中非常重要，不仅方便用户使用存储器、提高内存利用率，还可以通过虚拟技术从逻辑上扩充存储器。 内存管理的功能有：1、内存空间的分配与回收：由操作系统完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程效率。2、地址转换：在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址。3、内存空间的扩充：利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存。4、存储保护：保证各道作业在各自的存储空间内运行，互不干扰。 在进行具体的内存管理之前，需要了解进程运行的基本原理和要求。 程序装入和链接创建进程首先要将程序和数据装入内存。将用户源程序变为可在内存中执行的程序，通常需要以下几个步骤：1、编译：由编译程序将用户源代码编译成若干个目标模块。2、链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块。3、装入：由装入程序将装入模块装入内存运行。 用户程序的处理三步步骤如下图所示。 程序的链接有以下三种方式：1、静态链接：在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行程序，以后不再拆开。2、装入时动态链接：将用户源程序编译后所得到的一组目标模块，在装入内存时，釆用边装入边链接的链接方式。3、运行时动态链接：对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行的链接。其优点是便于修改和更新，便于实现对目标模块的共享。 内存的装入模块在装入内存时，同样有以下三种方式： 1) 绝对装入。在编译时，如果知道程序将驻留在内存的某个位置，编译程序将产生绝对地址的目标代码。绝对装入程序按照装入模块中的地址，将程序和数据装入内存。由于程序中的逻辑地址与实际内存地址完全相同，故不需对程序和数据的地址进行修改。 绝对装入方式只适用于单道程序环境（比如51类单片机编程）。另外程序中所使用的绝对地址,可在编译或汇编时给出，也可由程序员直接赋予。而通常情况下在程序中釆用的是符号地址，编译或汇编时再转换为绝对地址。 2) 可重定位装入。在多道程序环境下，多个目标模块的起始地址通常都是从0开始，程序中的其他地址都是相对于起始地址的,此时应釆用可重定位装入方式。根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对目标程序中指令和数据的修改过程称为重定位，地址变换通常是在装入时一次完成的，所以又称为静态重定位，如下图(a)所示。 静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。此外，作业一旦进入内存后，在整个运行期间不能在内存中移动，也不能再申请内存空间。 3) 动态运行时装入，也称为动态重定位，程序在内存中如果发生移动，就需要釆用动态的装入方式。装入程序在把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行，起始地址也是程序执行时才确定的。因此，装入内存后的所有地址均为相对地址。这种方式需要一个重定位寄存器的支持，如上图(b)所示。 动态重定位的特点是可以将程序分配到不连续的存储区中；在程序运行之前可以只装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。 逻辑地址空间与物理地址空间编译后，每个目标模块都是从0号单元开始编址，称为该目标模块的相对地址（或逻辑地址)。当链接程序将各个模块链接成一个完整的可执行目标程序时，链接程序顺序依次按各个模块的相对地址构成统一的从0号单元开始编址的逻辑地址空间。用户程序和程序员只需知道逻辑地址，而内存管理的具体机制则是完全透明的，它们只有系统编程人员才会涉及。不同进程可以有相同的逻辑地址，因为这些相同的逻辑地址可以映射到主存的不同位置。 物理地址空间是指内存中物理单元的集合，它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取。当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，这个过程称为地址重定位。 内存保护内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。通过釆用重定位寄存器和界地址寄存器来实现这种保护。重定位寄存器含最小的物理地址值，界地址寄存器含逻辑地址值。每个逻辑地址值必须小于界地址寄存器；内存管理机构动态地将逻辑地址与界地址寄存器进行比较，如果未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再送交内存单元，如下图所示。 当CPU调度程序选择进程执行时，派遣程序会初始化重定位寄存器和界地址寄存器。每一个逻辑地址都需要与这两个寄存器进行核对，以保证操作系统和其他用户程序及数据不被该进程的运行所影响。 内存覆盖与内存交换覆盖与交换技术是在多道程序环境下用来扩充内存的两种方法。 内存覆盖早期的计算机系统中，主存容量很小，虽然主存中仅存放一道用户程序，但是存储空间放不下用户进程的现象也经常发生，这一矛盾可以用覆盖技术来解决。 覆盖的基本思想是：由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可以把用户空间分成一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分按调用关系分段。首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。 覆盖技术的特点是打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行。 内存交换交换（对换）的基本思想是，把处于等待状态（或在CPU调度原则下被剥夺运行权利） 的程序从内存移到辅存，把内存空间腾出来，这一过程又叫换出；把准备好竞争CPU运行的程序从辅存移到内存，这一过程又称为换入。在线程和进程管理一文中介绍的中级调度就是釆用交换技术。 例如，有一个CPU釆用时间片轮转调度算法的多道程序环境。时间片到，内存管理器将刚刚执行过的进程换出，将另一进程换入到刚刚释放的内存空间中。同时，CPU调度器可以将时间片分配给其他已在内存中的进程。每个进程用完时间片都与另一进程交换。理想情况下，内存管理器的交换过程速度足够快，总有进程在内存中可以执行。 有关交换需要注意以下几个问题：1、交换需要备份存储，通常是快速磁盘。它必须足够大，并且提供对这些内存映像的直接访问。2、为了有效使用CPU，需要每个进程的执行时间比交换时间长，而影响交换时间的主要是转移时间。转移时间与所交换的内存空间成正比。3、如果换出进程，必须确保该进程是完全处于空闲状态。4、交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用就可能很快。5、交换通常在有许多进程运行且内存空间吃紧时开始启动，而系统负荷降低就暂停。6、普通的交换使用不多，但交换策略的某些变种在许多系统中（如UNIX系统，SWAP区）仍发挥作用。 交换技术主要是在不同进程（或作业）之间进行，而覆盖则用于同一个程序或进程中。由于覆盖技术要求给出程序段之间的覆盖结构，使得其对用户和程序员不透明，所以对于主存无法存放用户程序的矛盾，现代操作系统是通过虚拟内存技术来解决的，覆盖技术则已成为历史，而交换技术在现代操作系统中仍具有较强的生命力。 内存连续分配管理方式连续分配方式，是指为一个用户程序分配一个连续的内存空间。它主要包括单一连续分配、固定分区分配和动态分区分配。 单一连续分配内存在此方式下分为系统区和用户区，系统区仅提供给操作系统使用，通常在低地址部分；用户区是为用户提供的、除系统区之外的内存空间。这种方式无需进行内存保护。 这种方式的优点是简单、无外部碎片，可以釆用覆盖技术，不需要额外的技术支持。缺点是只能用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低。 固定分区分配固定分区分配是最简单的一种多道程序存储管理方式，它将用户内存空间划分为若干个固定大小的区域，每个分区只装入一道作业。当有空闲分区时，便可以再从外存的后备作业队列中,选择适当大小的作业装入该分区，如此循环。 固定分区分配的两种方法： 固定分区分配在划分分区时，有两种不同的方法，如上图所示。(a) 分区大小相等：用于利用一台计算机去控制多个相同对象的场合，缺乏灵活性。(b) 分区大小不等：划分为含有多个较小的分区、适量的中等分区及少量的大分区。 为便于内存分配，通常将分区按大小排队，并为之建立一张分区说明表，其中各表项包括每个分区的起始地址、大小及状态（是否已分配），如下图(a)所示。当有用户程序要装入时，便检索该表，以找到合适的分区给予分配并将其状态置为”已分配”；未找到合适分区则拒绝为该用户程序分配内存。存储空间的分配情况下图(b)所示。 这种分区方式存在两个问题：一是程序可能太大而放不进任何一个分区中，这时用户不得不使用覆盖技术来使用内存空间；二是主存利用率低，当程序小于固定分区大小时，也占用了一个完整的内存分区空间，这样分区内部有空间浪费，这种现象称为内部碎片。 固定分区是可用于多道程序设计最简单的存储分配，无外部碎片，但不能实现多进程共享一个主存区，所以存储空间利用率低。固定分区分配很少用于现在通用的操作系统中，但在某些用于控制多个相同对象的控制系统中仍发挥着一定的作用。 动态分区分配动态分区分配又称为可变分区分配，是一种动态划分内存的分区方法。这种分区方法不预先将内存划分，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统中分区的大小和数目是可变的。 如上图所示，系统有64MB内存空间，其中低8MB固定分配给操作系统，其余为用户可用内存。开始时装入前三个进程，在它们分别分配到所需空间后，内存只剩下4MB，进程4无法装入。在某个时刻，内存中没有一个就绪进程，CPU出现空闲，操作系统就换出进程2，换入进程4。由于进程4比进程2小，这样在主存中就产生了一个6MB的内存块。之后CPU又出现空闲，而主存无法容纳进程2,操作系统就换出进程1，换入进程2。 动态分区在开始分配时是很好的，但是之后会导致内存中出现许多小的内存块。随着时间的推移，内存中会产生越来越多的碎片（上图中最后的4MB和中间的6MB，且随着进程的换入/换出，很可能会出现更多更小的内存块)，内存的利用率随之下降。这些小的内存块称为外部碎片，指在所有分区外的存储空间会变成越来越多的碎片，这与固定分区中的内部碎片正好相对。克服外部碎片可以通过紧凑（Compaction)技术来解决，就是操作系统不时地对进程进行移动和整理。但是这需要动态重定位寄存器的支持，且相对费时。紧凑的过程实际上类似于Windows系统中的磁盘整理程序，只不过后者是对外存空间的紧凑。 在进程装入或换入主存时，如果内存中有多个足够大的空闲块，操作系统必须确定分配哪个内存块给进程使用，这就是动态分区的分配策略，考虑以下几种算法：1、首次适应(First Fit)算法：空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。2、最佳适应(Best Fit)算法：空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区。3、最坏适应(Worst Fit)算法：又称最大适应(Largest Fit)算法，空闲分区以容量递减的次序链接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区。4、邻近适应(Next Fit)算法：又称循环首次适应算法，由首次适应算法演变而成。不同之处是分配内存时从上次查找结束的位置开始继续查找。 在这几种方法中，首次适应算法不仅是最简单的，而且通常也是最好和最快的。在UNIX系统的最初版本中，就是使用首次适应算法为进程分配内存空间，其中使用数组的数据结构 (而非链表）来实现。不过首次适应算法会使得内存的低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。 邻近适应算法试图解决这个问题，但实际上，它常常会导致在内存的末尾分配空间（因为在一遍扫描中，内存前面部分使用后再释放时，不会参与分配)，分裂成小碎片。它通常比首次适应算法的结果要差。 最佳适应算法虽然称为“最佳”，但是性能通常很差，因为每次最佳的分配会留下很小的难以利用的内存块，它会产生最多的外部碎片。 最坏适应算法与最佳适应算法相反，选择最大的可用块，这看起来最不容易产生碎片，但是却把最大的连续内存划分开，会很快导致没有可用的大的内存块，因此性能也非常差。 Kunth和Shore分别就前三种方法对内存空间的利用情况做了模拟实验，结果表明： 首次适应算法可能比最佳适应法效果好，而它们两者一定比最大适应法效果好。 另外注意，在算法实现时，分配操作中最佳适应法和最大适应法需要对可用块进行排序或遍历查找，而首次适应法和邻近适应法只需要简单查找；回收操作中，当回收的块与原来的空闲块相邻时（有三种相邻的情况，比较复杂)，需要将这些块合并。在算法实现时，使用数组或链表进行管理。除了内存的利用率，这里的算法开销也是操作系统设计需要考虑的一个因素。 以上三种内存分区管理方法有一共同特点，即用户进程（或作业）在主存中都是连续存放的。这里对它们进行比较和总结，见下表。 内存非连续分配管理方式非连续分配允许一个程序分散地装入到不相邻的内存分区中，根据分区的大小是否固定分为分页存储管理方式和分段存储管理方式。 基本分页存储管理方式分页存储管理方式中，又根据运行作业时是否要把作业的所有页面都装入内存才能运行分为基本分页存储管理方式和请求分页存储管理方式。请求分页存储管理方式一般用于虚拟内存实现。 固定分区会产生内部碎片，动态分区会产生外部碎片，这两种技术对内存的利用率都比较低。 我们希望内存的使用能尽量避免碎片的产生，这就引入了分页的思想： 把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。 分页的方法从形式上看，像分区相等的固定分区技术，不过分页管理不会产生外部碎片。 分页管理和固定分区技术又有本质上的不同点：块的大小相对分区要小很多，而且进程也按照块进行划分，进程运行时按块申请主存可用空间并执行。这样，进程只会在为最后一个不完整的块申请一个主存块空间时，才产生主存内部碎片，所以尽管会产生内部碎片，但是这种碎片相对于进程来说也是很小的，每个进程平均只产生半个块大小的内部碎片（也称页内碎片）。 1) 分页存储的几个基本概念 a.页面和页面大小。进程中的块称为页(Page)，内存中的块称为页框（Page Frame，或页帧）。外存也以同样的单位进行划分，直接称为块(Block)。进程在执行时需要申请主存空间，就是要为每个页面分配主存中的可用页框，这就产生了页和页框的一一对应。 为方便地址转换，页面大小应是2的整数幂。同时页面大小应该适中，如果页面太小，会使进程的页面数过多，这样页表就过长，占用大量内存，而且也会增加硬件地址转换的开销，降低页面换入/换出的效率；页面过大又会使页内碎片增大，降低内存的利用率。所以页面的大小应该适中，考虑到空间效率和时间效率的权衡。 b.地址结构。分页存储管理的逻辑地址结构如下图所示。 地址结构包含两部分：前一部分为页号P，后一部分为页内偏移量W。地址长度为32位，其中0~11位为页内地址，即每页大小为4KB；12~31位为页号，地址空间最多允许有220页。 c.页表。为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，页表一般存放在内存中。 在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，页表的作用是实现从页号到物理块号的地址映射，如下图所示。 2) 基本地址变换机构 地址变换机构的任务是将逻辑地址转换为内存中物理地址，地址变换是借助于页表实现的。下图给出了分页存储管理系统中的地址变换机构。 在系统中通常设置一个页表寄存器(PTR)，存放页表在内存的始址F和页表长度M。进程未执行时，页表的始址和长度存放在进程控制块中，当进程执行时，才将页表始址和长度存入页表寄存器。 设页面大小为L，逻辑地址A到物理地址E的变换过程如下：1、计算页号P(P=A/L)和页内偏移量W (W=A%L)。2、比较页号P和页表长度M，若P &gt;= M，则产生越界中断，否则继续执行。3、页表中页号P对应的页表项地址 = 页表起始地址F + 页号P 页表项长度，取出该页表项内容b，即为物理块号。4、计算E=bL+W，用得到的物理地址E去访问内存。 以上整个地址变换过程均是由硬件自动完成的。 例如，若页面大小L为1K字节，页号2对应的物理块为b=8，计算逻辑地址A=2500的物理地址E的过程如下：P=2500/1K=2，W=2500%1K=452，查找得到页号2对应的物理块的块号为 8，E=8*1024+452=8644。 总结以上内容可以看出分页管理方式存在的两个主要问题：1、每次访存操作都需要进行逻辑地址到物理地址的转换，地址转换过程必须足够快，否则访存速度会降低；2、每个进程引入了页表，用于存储映射机制，页表不能太大，否则内存利用率会降低，存在页内碎片。 3) 具有快表的地址变换机构 由上面介绍的地址变换过程可知，若页表全部放在内存中，则存取一个数据或一条指令至少要访问两次内存：第一次是先访问页表，以便确定所存取的数据或指令的物理地址，第二次是根据第一次取出的地址到对应的物理地址存取数据或指令。 显然，这种方法是需要改进的。为此，在地址变换机构中增设了一个具有并行查找能力的高速缓冲存储器——快表，又称联想寄存器(TLB)，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，原来主存中的页表就常被称为慢表，配有快表的地址变换机构如下图所示。 在具有快表的分页机制中，地址的变换过程（注意比较上文没有块表的分页管理方式的过程）：1、CPU给出逻辑地址后，由硬件进行地址转换并将页号送入高速缓存寄存器，并将此页号与快表中的所有页号进行比较。2、如果找到匹配的页号，说明所要访问的页表项在快表中，则直接从中取出该页对应的页框号，与页内偏移量拼接形成物理地址。这样，存取数据仅一次访存便可实现。3、如果没有找到，则需要访问主存中的页表（慢表），在读出页表项后，需要同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换。 注意：有些处理机设计为快表和慢表同时查找，如果在快表中查找成功则终止慢表的查找。 一般快表的命中率可以达到90%以上，这样原本分页带来的速度损失就降低到10%以下。快表的有效性是基于著名的局部性原理，这在后面的虚拟内存中将会具体讨论。 4) 两级页表 由于引入了分页管理，因此进程在执行时不需要将所有页调入内存页框中，而只要将保存有映射关系的页表调入内存中即可，但是我们仍然需要考虑页表的大小。为什么？ 以32位逻辑地址空间、页面大小4KB、页表项大小4B为例。若要实现进程对全部逻辑地址空间的映射，则每个进程需要2^20，约100万个页表项。换算成存储所需的大小，每个进程仅页表这一项就需要4MB主存空间，这显然是不合理的。即便不考虑进程对全部逻辑地址空间进行映射的情况，一个逻辑地址空间稍大的进程，其页表大小也可能是过大的。以一个40MB的进程为例，页表项共40KB，如果将所有页表项内容保存在内存中，那么需要10个内存页框来保存整个页表。整个进程大小约为1万个页面，而实际执行时只需要几十个页面进入内存页框就可以运行，但如果要求10个页面大小的页表必须全部进入内存，这相对实际执行时的几十个进程页面的大小来说，肯定是降低了内存利用率的。从另一方面来说，这10页的页表项也并不需要同时保存在内存中，因为大多数情况下，映射所需要的页表项都在页表的同一个页面中。 为此可以将页表映射的思想做进一步延伸，可以得到二级分页：将页表的10页空间也进行地址映射，建立上一级页表，用于存储页表的映射关系。这里对页表的10个页面进行映射只需要10个页表项，所以上一级页表只需要1页就足够（可以存储2^10=1024个页表项）。在进程执行时，只需要将这1页的上一级页表调入内存即可，进程的页表和进程本身的页面，可以在后面的执行中再调入内存。 如下图所示，这是intel处理器80x86系列的硬件分页的地址转换过程。在32位系统中，全部32位逻辑地址空间可以分为2^20(4GB/4KB)个页面。这些页面可以再进一步建立顶级页表，需要210个顶级页表项进行索引，这正好是一页的大小，所以建立二级页表即可。 举例，32位系统中进程分页的工作过程：假定内核已经给一个正在运行的进程分配的逻辑地址空间是0x20000000到0x2003FFFF，这个空间由64个页面组成。在进程运行时，我们不需要知道全部这些页的页框的物理地址，很可能其中很多页还不在主存中。这里我们只注意在进程运行到某一页时，硬件是如何计算得到这一页的页框的物理地址的即可。现在进程需要读逻辑地址0x20021406中的字节内容，这个逻辑地址按如下进行处理：逻辑地址： 0x20021406 (0010 0000 0000 0010 0001 0100 0000 0110 B)顶级页表字段：0x80 (00 1000 0000 B)二级页表字段：0x21 (00 0010 0001B)页内偏移量字段：0x406 (0100 0000 0110 B) 顶级页表字段的0x80用于选择顶级页表的第0x80表项，此表项指向和该进程的页相关的二级页表；二级页表字段0x21用于选择二级页表的第0x21表项，此表项指向包含所需页的页框；最后的页内偏移量字段0x406用于在目标页框中读取偏移量为0x406中的字节，这是32位系统下比较实际的一个例子。 建立多级页表的目的在于建立索引，这样不用浪费主存空间去存储无用的页表项，也不用盲目地顺序式查找页表项，而建立索引的要求是最高一级页表项不超过一页的大小。 但是在64位操作系统中，页表的划分和32位操作系统是不一样的，整个过程需要重新考虑。我们假设仍然釆用4KB页面大小。偏移量字段12位，假设页表项大小为8B。这样，其上一级分页时，每个页框只能存储29(4KB/8B)个页表项，而不再是210个，所以上一级页表字段为9位。后面同理继续分页。64=12+9+9+9+9+9+7，所以需6级分页才能实现索引。很多书中仍然按32位操作系统的页表项进行分析，虽然同样能得出6级分页的结果，但显然是错误的。这里给出两个实际的64位操作系统的分页级别（注意：里面没有使用全部64位寻址，不过由于地址字节对齐的设计考虑，仍然使用8B大小的页表项），理解了下表中的分级方式，相信对多级分页就非常清楚了。 两种系统的分级方式： 基本分段存储管理方式分页管理方式是从计算机的角度考虑设计的，以提高内存的利用率，提升计算机的性能。分页通过硬件机制实现，对用户完全透明。而分段管理方式的提出则是考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要。 分页是物理上的，分段是逻辑上的。分页是自动计算的，分段是由程序员（或编译器）指定的。 1) 分段段式管理方式按照用户进程中的自然段划分逻辑空间。例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为5个段，每段从0开始编址，并分配一段连续的地址空间（段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的）。其逻辑地址由段号S与段内偏移量W两部分组成。 在下图中，段号为16位，段内偏移量为16位，则一个作业最多可有216=65536个段，最大段长为64KB。 分段系统中的逻辑地址结构： 在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但在段式系统中，段号和段内偏移量必须由用户显示提供，在髙级程序设计语言中，这个工作由编译程序完成。 2) 段表。每个进程都有一张逻辑空间与内存空间映射的段表，其中每一个段表项对应进程的一个段，段表项记录该段在内存中的起始地址和段的长度。段表的内容如下图所示。 段表项： 在配置了段表后，执行中的进程可通过查找段表，找到每个段所对应的内存区。可见，段表用于实现从逻辑段到物理内存区的映射，如下图所示。 利用段表实现地址映射： 3) 地址变换机构。 分段系统的地址变换过程： 为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器，用于存放段表始址F和段表长度M。其从逻辑地址A到物理地址E之间的地址变换过程如下：1、从逻辑地址A中取出前几位为段号S，后几位为段内偏移量W。2、比较段号S和段表长度M，若S多M，则产生越界中断，否则继续执行。3、段表中段号S对应的段表项地址 = 段表起始地址F + 段号S * 段表项长度，取出该段表项的前几位得到段长C。若段内偏移量&gt;=C，则产生越界中断，否则继续执行。4、取出段表项中该段的起始地址b，计算 E = b + W，用得到的物理地址E去访问内存。 4) 段的共享与保护。 在分段系统中，段的共享是通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的。当一个作业正从共享段中读取数据时，必须防止另一个作业修改此共享段中的数据。不能修改的代码称为纯代码或可重入代码（但是它不属于临界资源，这样的代码和不能修改的数据是可以共享的（共享读），而可修改的代码和数据则不能共享）。 与分页管理类似，分段管理的保护方法主要有两种：一种是存取控制保护，另一种是地址越界保护。 地址越界保护是利用段表寄存器中的段表长度与逻辑地址中的段号比较，若段号大于段表长度则产生越界中断；再利用段表项中的段长和逻辑地址中的段内位移进行比较，若段内位移大于段长，也会产生越界中断。 段页式管理方式 页式存储管理能有效地提高内存利用率，分段存储管理能反映程序的逻辑结构以及段的共享。如果将这两种存储管理方法结合起来，就形成了段页式存储管理方式。 在段页式系统中，作业的地址空间首先被分成若干个逻辑段，每段都有自己的段号，然后再将每一段分成若干个大小固定的页。对内存空间的管理仍然和分页存储管理一样，将其分成若干个和页面大小相同的存储块，对内存的分配以存储块为单位，如下图所示。 段页式管理方式： 在段页式系统中，作业的逻辑地址分为三部分：段号、页号和页内偏移量，如下图所示。 段页式系统的逻辑地址结构： 为了实现地址变换，系统为每个进程建立一张段表，而每个分段有一张页表。段表表项中至少包括段号、页表长度和页表起始地址，页表表项中至少包括页号和块号。此外，系统中还应有一个段表寄存器，指出作业的段表起始地址和段表长度。 注意：在一个进程中，段表有且只有一个，而页表则可能有多个。 在进行地址变换时，首先通过段表查到页表起始地址，然后通过页表找到页帧号，最后形成物理地址。如下图所示，进行一次访问需要三次访问主存，不过同样可以使用快表以加快查找速度，其关键字由段号、页号组成，值是对应的页帧号和保护码。 段页式系统的地址变换机构： 传统存储管理方式的特征和不足前面介绍的各种内存管理策略都是为了同时将多个进程保存在内存中以便允许多道程序设计。 它们都具有以下两个共同的特征： 1) 一次性作业必须一次性全部装入内存后，方能开始运行。这会导致两种情况发生：1、当作业很大，不能全部被装入内存时，将使该作业无法运行；2、当大量作业要求运行时，由于内存不足以容纳所有作业，只能使少数作业先运行，导致多道程序度的下降。 2) 驻留性作业被装入内存后，就一直驻留在内存中，其任何部分都不会被换出，直至作业运行结束。运行中的进程，会因等待I/O而被阻塞，可能处于长期等待状态，不过因为作业没有结束，所以不会被清除掉。 由以上分析可知，许多在程序运行中不用或暂时不用的程序（数据）占据了大量的内存空间，而一些需要运行的作业却又无法装入运行，这显然浪费了宝贵的内存资源。 局部性原理要真正理解虚拟内存技术的思想，首先先补充了解一下计算机中著名的局部性原理。 SUN公司的CEO Bill Joy说过，“在研究所的时候，我经常开玩笑地说高速缓存是计算机科学中唯一重要的思想。事实上，髙速缓存技术确实极大地影响了计算机系统的设计。” 快表、页高速缓存以及虚拟内存技术从广义上概括的话都属于高速缓存技术。 高速缓存技术所依赖的原理就是局部性原理。 局部性原理既适用于程序结构，也适用于数据结构（比如Dijkstra著名的关于“goto语句有害”的论文也是对程序局部性原理的深刻认识和理解）。 局部性原理表现在以下两个方面： 1、时间局部性：如果程序中的某条指令一旦执行，不久以后该指令可能会再次被执行；如果某数据被访问过，不久以后该数据可能会再次被访问。产生时间局部性的原因在于程序中一般会存在着很多循环。 2、空间局部性：如果程序访问了某个存储单元，不久之后其附近的存储单元也将会被访问，即程序在一段时间内所访问的地址，可能会集中在一定的范围之内。这是因为指令通常是顺序存放、顺序执行的，对应读取的数据一般也是以向量、数组、表等形式“簇聚”存储的。 对于时间局部性，是通过将近来频繁被使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现的。对于空间局部性，通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现的。 虚拟内存技术实际上就是建立了“内存——外存”的两级存储器的结构，利用局部性原理实现髙速缓存。 虚拟内存的概念、特征、实现虚拟存储器的概念和特征基于局部性原理，在程序装入时可以只将程序的一部分装入内存，而将其余部分仍留在外存，然后就可以启动程序执行。接着在程序执行过程中，当所访问的信息不在内存时，此时再由操作系统将所需要的部分调入内存，然后继续执行程序。相应的操作系统会将内存中暂时不使用的内容换出到外存上，腾出空间存放将要调入内存的信息。这样的机制，就好像系统为用户提供了一个比实际内存大得多的存储器，也称为虚拟存储器。 之所以将其称为虚拟存储器，是因为这种存储器实际上并不存在，只是由于系统提供了部分装入、请求调入和置换功能后（对用户完全透明），给用户的感觉是好像存在一个比实际物理内存大得多的存储器。 不过虚拟存储器的具体大小是由计算机的地址结构决定的，并非是内存和外存的简单相加。 虚拟存储器有以下三个主要特征：1、多次性，是指无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行。2、对换性，是指无需在作业运行时一直常驻内存，而是允许在作业的运行过程中，进行换进和换出。3、虚拟性，是指从逻辑上扩充内存的容量，使用户所看到的内存容量，远大于实际的内存容量。 虚拟内存技术的实现釆用连续分配方式时，会使相当一部分内存空间都处于暂时或“永久”的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量。在虚拟内存中，允许将一个作业分多次调入内存。因此，虚拟内存需要建立在离散分配的内存管理方式的基础上。 虚拟内存的实现有以下三种方式：1、请求分页存储管理。2、请求分段存储管理。3、请求段页式存储管理。 不管哪种方式，都需要有一定的硬件支持。一般需要的支持有以下几个方面：1、一定容量的内存和外存。2、页表机制（或段表机制），作为主要的数据结构。3、中断机构，当用户程序要访问的部分尚未调入内存，则产生中断。4、地址变换机构，逻辑地址到物理地址的变换。 请求分页管理方式实现虚拟内存请求分页系统建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。 在请求分页系统中，只要求将当前需要的一部分页面装入内存，便可以启动作业运行。在作业执行过程中，当所要访问的页面不在内存时，再通过调页功能将其调入，同时还可以通过置换功能将暂时不用的页面换出到外存上，以便腾出内存空间。 为了实现请求分页，系统必须提供一定的硬件支持。除了需要一定容量的内存及外存的计算机系统，还需要有页表机制、缺页中断机构和地址变换机构。 页表机制请求分页系统的页表机制不同于基本分页系统，请求分页系统在一个作业运行之前不要求全部一次性调入内存，因此在作业的运行过程中，必然会出现要访问的页面不在内存的情况，那么如何发现和以及如何处理这种情况呢？为此，在请求页表项中增加了四个字段，如下图所示。 请求分页系统中的页表项： 增加的四个字段说明如下：1、状态位P：用于指示该页是否已调入内存，供程序访问时参考。2、访问字段A：用于记录本页在一段时间内被访问的次数，或记录本页最近己有多长时间未被访问，供置换算法换出页面时参考。3、修改位M：标识该页在调入内存后是否被修改过。4、外存地址：用于指出该页在外存上的地址，通常是物理块号，供调入该页时参考。 缺页中断机构在请求分页系统中，每当所要访问的页面不在内存时，便产生一个缺页中断，请求操作系统将所缺的页调入内存。此时应将缺页的进程阻塞（调页完成唤醒)，如果内存中有空闲块，则分配一个块，将要调入的页装入该块，并修改页表中相应页表项，若此时内存中没有空闲块，则要淘汰某页（若被淘汰页在内存期间被修改过，则要将其写回外存)。 缺页中断作为中断同样要经历，诸如保护CPU环境、分析中断原因、转入缺页中断处理程序、恢复CPU环境等几个步骤。但与一般的中断相比，它有以下两个明显的区别：1、在指令执行期间产生和处理中断信号，而非一条指令执行完后，属于内部中断。2、一条指令在执行期间，可能产生多次缺页中断。 地址变换机构请求分页系统中的地址变换机构，是在分页系统地址变换机构的基础上，为实现虚拟内存，又增加了某些功能而形成的。 请求分页中的地址变换过程： 如上图所示，在进行地址变换时，先检索快表：1、若找到要访问的页，便修改页表项中的访问位（写指令则还须重置修改位)，然后利用页表项中给出的物理块号和页内地址形成物理地址。2、若未找到该页的页表项，应到内存中去查找页表，再对比页表项中的状态位P，看该页是否已调入内存，未调入则产生缺页中断，请求从外存把该页调入内存。 页面置换算法进程运行时，若其访问的页面不在内存而需将其调入，但内存已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘的对换区。选择调出页面的算法就称为页面置换算法。 好的页面置换算法应有较低的页面更换频率，也就是说，应将以后不会再访问或者以后较长时间内不会再访问的页面先调出。 常见的置换算法有以下四种：最佳置换算法(OPT)、先进先出(FIFO)页面置换算法、最近最久未使用(LRU)置换算法、时钟(CLOCK)置换算法。 最佳置换算法(OPT)最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但由于目前还无法预知进程在内存下的若干页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。 最佳置换算法可以用来评价其他算法。假定系统为某进程分配了三个物理块，并考虑有以下页面号引用串：7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1 进程运行时，先将7, 0, 1三个页面依次装入内存。进程要访问页面2时，产生缺页中断，根据最佳置换算法，选择第18次访问才需调入的页面7予以淘汰。然后，访问页面0时，因为已在内存中所以不必产生缺页中断。访问页面3时又会根据最佳置换算法将页面1淘汰……依此类推，如图3-26所示。从图中可以看出釆用最佳置换算法时的情况。 可以看到，发生缺页中断的次数为9，页面置换的次数为6。 先进先出(FIFO)页面置换算法优先淘汰最早进入内存的页面，亦即在内存中驻留时间最久的页面。该算法实现简单，只需把调入内存的页面根据先后次序链接成队列，设置一个指针总指向最早的页面。但该算法与进程实际运行时的规律不适应，因为在进程中，有的页面经常被访问。 这里仍用上面的实例，釆用FIFO算法进行页面置换。进程访问页面2时，把最早进入内存的页面7换出。然后访问页面3时，再把2, 0, 1中最先进入内存的页换出。由图 3-27可以看出，利用FIFO算法时进行了12次页面置换，比最佳置换算法正好多一倍。 FIFO算法还会产生当所分配的物理块数增大而页故障数（错误处）不减反增的异常现象，这是由Belady于1969年发现，故称为Belady异常，如下图所示。 只有FIFO算法可能出现Belady异常，而LRU和OPT算法不会出现Belady异常。 最近最久未使用(LRU)置换算法选择最近最长时间未访问过的页面予以淘汰，它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。该算法为每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。 再对上面的实例釆用LRU算法进行页面置换，如图3-29所示。进程第一次对页面2访问时，将最近最久未被访问的页面7置换出去。然后访问页面3时，将最近最久未使用的页面1换出。 在上图中，前5次置换的情况与最佳置换算法相同，但两种算法并无必然联系。实际上，LRU算法根据各页以前的情况，是“向前看”的，而最佳置换算法则根据各页以后的使用情况，是“向后看”的。 LRU性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类的算法。理论上可以证明，堆栈类算法不可能出现Belady异常。FIFO算法基于队列实现，不是堆栈类算法，会出现Belady异常。 时钟(CLOCK)置换算法LRU算法的性能接近于OPT，但是实现起来比较困难，且开销大；FIFO算法实现简单，但性能差。所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体。 简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1；当该页随后再被访问到时，它的使用位也被置为1。对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。由于该算法循环地检查各页面的情况，故称为CLOCK算法，又称为最近未用(Not Recently Used, NRU)算法。 CLOCK算法的性能比较接近LRU，而通过增加使用的位数目，可以使得CLOCK算法更加高效。在使用位的基础上再增加一个修改位，则得到改进型的CLOCK置换算法。这样，每一帧都处于以下四种情况之一：1、最近未被访问，也未被修改(u=0, m=0)。2、最近被访问，但未被修改(u=1, m=0)。3、最近未被访问，但被修改(u=0, m=1)。4、最近被访问，被修改(u=1, m=1)。 算法执行如下操作步骤：1、从指针的当前位置开始，扫描帧缓冲区。在这次扫描过程中，对使用位不做任何修改。选择遇到的第一个帧(u=0, m=0)用于替换。2、如果第1)步失败，则重新扫描，查找(u=0, m=1)的帧。选择遇到的第一个这样的帧用于替换。在这个扫描过程中，对每个跳过的帧，把它的使用位设置成0。3、如果第2)步失败，指针将回到它的最初位置，并且集合中所有帧的使用位均为0。重复第1步，并且如果有必要，重复第2步。这样将可以找到供替换的帧。 改进型的CLOCK算法优于简单CLOCK算法之处在于替换时首选没有变化的页。由于修改过的页在被替换之前必须写回，因而这样做会节省时间。 页面分配策略驻留集大小对于分页式的虚拟内存，在准备执行时，不需要也不可能把一个进程的所有页都读取到主存，因此，操作系统必须决定读取多少页放置在内存中，也称为驻留集。也就是说，给特定的进程分配多大的主存空间，需要考虑以下几点：1、分配给一个进程的存储量越小，在任何时候驻留在主存中的进程数就越多，从而可以提高处理机的时间利用效率。2、如果一个进程在主存中的页数过少，尽管有局部性原理，页错误率仍然会相对较高。3、如桌页数过多，由于局部性原理，给特定的进程分配更多的主存空间对该进程的错误率没有明显的影响。 基于这些因素，现代操作系统通常釆用三种策略：1、固定分配局部置换。它为每个进程分配一定数目的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。实现这种策略难以确定为每个进程应分配的物理块数目：太少会频繁出现缺页中断，太多又会使CPU和其他资源利用率下降。2、可变分配全局置换。这是最易于实现的物理块分配和置换策略，为系统中的每个进程分配一定数目的物理块,操作系统自身也保持一个空闲物理块队列。当某进程发生缺页时，系统从空闲物理块队列中取出一个物理块分配给该进程，并将欲调入的页装入其中。3、可变分配局部置换。它为每个进程分配一定数目的物理块，当某进程发生缺页时，只允许从该进程在内存的页面中选出一页换出，这样就不会影响其他进程的运行。如果进程在运行中频繁地缺页，系统再为该进程分配若干物理块，直至该进程缺页率趋于适当程度；反之，若进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。 调入页面的时机为确定系统将进程运行时所缺的页面调入内存的时机，可釆取以下两种调页策略：1、预调页策略。根据局部性原理，一次调入若干个相邻的页可能会比一次调入一页更高效。但如果调入的一批页面中大多数都未被访问，则又是低效的。所以就需要釆用以预测为基础的预调页策略，将预计在不久之后便会被访问的页面预先调入内存。但目前预调页的成功率仅约50%。故这种策略主要用于进程的首次调入时，由程序员指出应该先调入哪些页。2、请求调页策略。进程在运行中需要访问的页面不在内存而提出请求，由系统将所需页面调入内存。由这种策略调入的页一定会被访问，且这种策略比较易于实现，故在目前的虚拟存储器中大多釆用此策略。它的缺点在于每次只调入一页，调入调出页面数多时会花费过多的I/O开销。 从何处调入页面请求分页系统中的外存分为两部分：用于存放文件的文件区和用于存放对换页面的对换区。对换区通常是釆用连续分配方式，而文件区釆用离散分配方式，故对换区的磁盘I/O速度比文件区的更快。这样从何处调入页面有三种情况：1、系统拥有足够的对换区空间：可以全部从对换区调入所需页面，以提髙调页速度。为此，在进程运行前，需将与该进程有关的文件从文件区复制到对换区。2、系统缺少足够的对换区空间：凡不会被修改的文件都直接从文件区调入；而当换出这些页面时，由于它们未被修改而不必再将它们换出。但对于那些可能被修改的部分，在将它们换出时须调到对换区，以后需要时再从对换区调入。3、UNIX方式：与进程有关的文件都放在文件区，故未运行过的页面，都应从文件区调入。曾经运行过但又被换出的页面，由于是被放在对换区，因此下次调入时应从对换区调入。进程请求的共享页面若被其他进程调入内存，则无需再从对换区调入。 页面抖动(颠簸)在页面置换过程中的一种最糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，这种频繁的页面调度行为称为页面抖动，或颠簸。 如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。 频繁的发生缺页中断（抖动），其主要原因是某个进程频繁访问的页面数目高于可用的物理页帧数目。虚拟内存技术可以在内存中保留更多的进程以提髙系统效率。在稳定状态，几乎主存的所有空间都被进程块占据，处理机和操作系统可以直接访问到尽可能多的进程。但如果管理不当，处理机的大部分时间都将用于交换块，即请求调入页面的操作，而不是执行进程的指令，这就会大大降低系统效率。 工作集（驻留集）工作集（或驻留集）是指在某段时间间隔内，进程要访问的页面集合。经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃。为了防止系统出现抖动现象，需要选择合适的工作集大小。 工作集模型的原理是：让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块。如果还有空闲物理块，则可以再调一个进程到内存以增加多道程序数。如果所有工作集之和增加以至于超过了可用物理块的总数，那么操作系统会暂停一个进程，将其页面调出并且将其物理块分配给其他进程，防止出现抖动现象。 正确选择工作集的大小，对存储器的利用率和系统吞吐量的提嵩，都将产生重要影响。 总结思考分页管理和分段管理两者很多地方相似，比如内存中都是不连续的、都有地址变换机构来进行地址映射等。 但两者也存在着许多区别，下表列出了分页管理方式和分段管理方式在各个方面的对比：]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>学习</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统原理之文件管理]]></title>
    <url>%2F2017%2F07%2F21-operation-system-file%2F</url>
    <content type="text"><![CDATA[操作系统原理之文件管理转载整理自这篇博客 操作系统原理之基础知识操作系统原理之死锁操作系统原理之处理机调度操作系统原理之信号量操作系统原理之进程和线程管理操作系统原理之内存管理 文件的概念和定义文件(File)是操作系统中的一个重要概念。 在系统运行时，计算机以进程为基本单位进行资源的调度和分配；在用户进行的输入、输出中，则以文件为基本单位。 大多数应用程序的输入都是通过文件来实现的，其输出也都保存在文件中，以便信息的长期存及将来的访问。当用户将文件用于应用程序的输入、输出时，还希望可以访问文件、修改文件和保存文件等，实现对文件的维护管理，这就需要系统提供一个文件管理系统，操作系统中的文件系统(File System)就是用于实现用户的这些管理要求。 从用户的角度看，文件系统是操作系统的重要部分之一。用户关心的是如何命名、分类和查找文件，如何保证文件数据的安全性以及对文件可以进行哪些操作等。而对其中的细节，如文件如何存储在辅存上、如何管理文件辅存区域等关心甚少。 文件系统提供了与二级存储相关的资源的抽象，让用户能在不了解文件的各种属性、文件存储介质的特征以及文件在存储介质上的具体位置等情况下，方便快捷地使用文件。用户通过文件系统建立文件，提供应用程序的输入、输出，对资源进行管理。 首先了解文件的结构，我们通过自底向上的方式来定义： 数据项数据项是文件系统中最低级的数据组织形式，可分为以下两种类型：1、基本数据项：用于描述一个对象的某种属性的一个值，如姓名、日期或证件号等，是数据中可命名的最小逻辑数据单位，即原子数据。2、组合数据项：由多个基本数据项组成。 记录记录是一组相关的数据项的集合，用于描述一个对象在某方面的属性，如一个考生报名记录包括考生姓名、出生日期、报考学校代号、身份证号等一系列域。 文件文件是指由创建者所定义的一组相关信息的集合，逻辑上可分为有结构文件和无结构文件两种：1、在有结构文件中，文件由一组相似记录组成，如报考某学校的所有考生的报考信息记录，又称记录式文件；2、无结构文件则被看成是一个字符流，比如一个二进制文件或字符文件，又称流式文件。 虽然上面给出了结构化的表述，但实际上关于文件并无严格的定义。通常在操作系统中将程序和数据组织成文件。文件可以是数字、字母或二进制代码，基本访问单元可以是字节、 行或记录。文件可以长期存储于硬盘或其他二级存储器中，允许可控制的进程间共享访问，能够被组织成复杂的结构。Linux中一切皆文件。 文件的属性文件有一定的属性，这根据系统的不同而有所不同，但是通常都包括如下属性： ①名称：文件名称唯一，以容易读取的形式保存。②标识符：标识文件系统内文件的唯一标签,通常为数字，它是对人不可读的一种内部名称。③类型：被支持不同类型的文件系统所使用。④位置：指向设备和设备上文件的指针。⑤大小：文件当前大小（用字节、字或块表示），也可包含文件允许的最大值。⑥保护：对文件进行保护的访问控制信息，比如读写执行权限等。⑦时间、日期和用户标识：文件创建、上次修改和上次访问的相关信息，用于保护、 安全和跟踪文件的使用。 所有文件的信息都保存在目录结构中，而目录结构也保存在外存上。文件信息当需要时再调入内存。 通常，目录条目包括文件名称和文件的唯一标识符，唯一标识符则定位该文件其他属性信息。 文件的基本橾作文件属于抽象数据类型。为了恰当地定义文件，就需要考虑有关文件的操作。操作系统提供系统调用，它对文件进行创建、写、读、定位和截断。 ①创建文件：创建文件有两个必要步骤，一是在文件系统中为文件找到空间；二是在目录中为新文件创建条目，该条目记录文件名称、在文件系统中的位置及其他可能信息。②写文件：为了写文件，执行一个系统调用，指明文件名称和要写入文件的内容。对于给定文件名称，系统搜索目录以查找文件位置。系统必须为该文件维护一个写位置的指针。每当发生写操作，便更新写指针。③读文件：为了读文件，执行一个系统调用，指明文件名称和要读入文件块的内存位置。同样，需要搜索目录以找到相关目录项，系统维护一个读位置的指针。每当发生读操作时，更新读指针。一个进程通常只对一个文件读或写，所以当前操作位置可作为每个进程当前文件位置指针。由于读和写操作都使用同一指针，节省了空间也降低了系统复杂度。④文件重定位（文件寻址）：按某条件搜索目录，将当前文件位置设为给定值，并且不会读、写文件。⑤删除文件：先从目录中找到要删除文件的目录项，使之成为空项，然后回收该文件所占用的存储空间（一般只是删除目录项，不会再覆写文件内容）。⑥截断文件：允许文件所有属性不变，并删除文件内容，即将其长度设为0并释放其空间。 这6个基本操作可以组合执行其他文件操作。 例如，一个文件的复制：先创建新文件，再从旧文件读出内容并写入到新文件。 文件的打开与关闭因为许多文件操作都涉及为给定文件搜索相关目录条目，许多系统要求在首次使用文件时，使用系统调用open，将指明文件的属性（包括该文件在外存上的物理位置）从外存拷贝到内存打开文件目录表的一个表目中，并将该表目的编号（或称为索引）返回给用户。操作系统维护一个包含所有打开的文件信息表（打开文件表，open-file table）。当用户需要一个文件操作时，可通过该表的一个索引指定文件，就省略了搜索环节。当文件不再使用时，进程可以关闭它，操作系统从打开文件表中删除这一条目。 大部分操作系统要求在文件使用之前就被显式地打开。操作open会根据文件名搜索目录，并将目录条目复制到打开文件表。如果调用open的请求（创建、只读、读写、添加等）得到允许，进程就可以打开文件，而open通常返回一个指向打开文件表中的一个条目的指针。通过使用该指计（而非文件名）进行所有I/O操作，以简化步骤并节省资源。 整个系统表包含进程相关信息，如文件在磁盘的位置、访问日期和大小。一个进程打开一个文件，系统打开文件表就会为打开的文件增加相应的条目。当另一个进程执行open时，只不过是在其进程打开表中增加一个条目，并指向整个系统表的相应条目。通常，系统打开文件表的每个文件时，还用一个文件打开计数器(Open Count)，以记录多少进程打开了该文件。每个关闭操作close则使count递减，当打开计数器为0时，表示该文件不再被使用，系统将回收分配给该文件的内存空间等资源。若文件被修改过，则将文件写回外存，并将系统打开文件表中相应条目删除，最后释放文件的文件控制块(File Control Block, FCB)。 每个打开的文件都有如下关联信息：1、文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的，因此必须与磁盘文件属性分开保存。2、文件打开计数：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间会不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件。该计数器跟踪打开和关闭的数量，当该计数为0 时，系统关闭文件，删除该条目。3、文件磁盘位置：绝大多数文件操作都要求系统修改文件数据。该信息保存在内存中以免为每个操作都从磁盘中读取。4、访问权限：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等)。该信息保存在进程的打开文件表中以便操作系统能允许或拒绝之后的I/O请求。 文件的逻辑结构文件的逻辑结构是从用户观点出发看到的文件的组织形式。文件的物理结构是从实现观点出发，又称为文件的存储结构，是指文件在外存上的存储形式。文件的逻辑结构与存储介质特性无关，但文件的物理结构与存储介质的特性有很大关系。 按逻辑结构，文件有无结构文件和有结构文件两种类型：无结构文件和有结构文件。 无结构文件（流式文件）无结构文件是最简单的文件组织形式。无结构文件将数据按顺序组织成记录并积累保存，它是有序相关信息项的集合，以字节(Byte)为单位。由于无结构文件没有结构，因而对记录的访问只能通过穷举搜索的方式，故这种文件形式对大多数应用不适用。 但字符流的无结构文件管理简单，用户可以方便地对其进行操作。所以，那些对基本信息单位操作不多的文件较适于釆用字符流的无结构方式，如源程序文件、目标代码文件等。 有结构文件（记录式文件） 有结构文件按记录的组织形式可以分为：顺序文件、索引文件、索引顺序文件、直接文件（散列文件）。 顺序文件文件中的记录一个接一个地顺序排列，记录可以是定长的或变长的，可以顺序存储或以链表形式存储，在访问时需要顺序搜索文件。 顺序文件有以下两种结构：第一种是串结构，记录之间的顺序与关键字无关。通常的办法是由时间决定，即按存入时间的先后排列，最先存入的记录作为第1个记录，其次存入的为第2个记录，依此类推。第二种是顺序结构，指文件中的所有记录按关键字顺序排列。 在对记录进行批量操作时，即每次要读或写一大批记录，对顺序文件的效率是所有逻辑文件中最高的；此外，也只有顺序文件才能存储在磁带上，并能有效地工作。但顺序文件对查找、修改、增加或删除单个记录的操作比较困难。 索引文件。对于定长记录文件，如果要查找第i个记录，可直接根据公式计算来迅速获得第i个记录相对于第一个记录的地址： 对于可变长记录的文件，要查找第i个记录时，必须顺序地查找前i-1个记录，从而获得相应记录的长度L，然后才能按下面的公式计算出第i个记录的首址： 注意：假定每个记录前用一个字节指明该记录的长度。 变长记录文件只能顺序查找，系统开销较大。为此可以建立一张索引表以加快检索速度，索引表本身是定长记录的顺序文件。在记录很多或是访问要求高的文件中，需要引入索引以提供有效的访问。实际中，通过索引可以成百上千倍地提高访问速度。 索引文件示意图： 索引顺序文件。索引顺序文件是顺序和索引两种组织形式的结合。索引顺序文件将顺序文件中的所有记录分为若干个组，为顺序文件建立一张索引表，在索引表中为每组中的第一个记录建立一个索引项，其中含有该记录的关键字值和指向该记录的指针。 索引顺序文件示意图： 如上图所示，主文件名包含姓名和其他数据项。姓名为关键字，索引表中为每组的第一个记录（不是每个记录）的关键字值，用指计指向主文件中该记录的起始位置。索引表只包含关键字和指计两个数据项，所有姓名关键字递增排列。主文件中记录分组排列，同一个组中关键字可以无序，但组与组之间关键字必须有序。查找一个记录时，通过索引表找到其所在的组，然后在该组中使用顺序查找就能很快地找到记录。 对于含有N个记录的顺序文件，查找某关键字值的记录时平均需要查找N/2次。在索引顺序文件中，假设N个记录分为N1/2组，索引表中有N1/2个表项，每组有N1/2个记录，在查找某关键字值的记录时，先顺序查找索引表，需要查找N1/2/2次，然后再在主文件中对应的组中顺序查找，也需要查找N1/2/2次，这样总共查找N1/2/2+N1/2/2=N1/2次。显然，索引顺序文件提高了查找效率，如果记录数很多，可以釆用两级或多级索引。 索引文件和索引顺序文件都提高了存取的速度，但因为配置索引表而增加了存储空间。 直接文件或散列文件(Hash File)给定记录的键值或通过Hash函数转换的键值直接决定记录的物理地址。这种映射结构不同于顺序文件或索引文件，没有顺序的特性。 散列文件有很高的存取速度，但是会引起冲突，即不同关键字的散列函数值相同情况。 文件的目录结构与文件管理系统和文件集合相关联的是文件目录，它包含有关文件的信息，包括属性、 位置和所有权等，这些信息主要是由操作系统进行管理。 首先我们来看目录管理的基本要求:从用户的角度看，目录在用户（应用程序）所需要的文件名和文件之间提供一种映射，所以目录管理要实现“按名存取”；目录存取的效率直接影响到系统的性能，所以要提高对目录的检索速度；在共享系统中，目录还需要提供用于控制访问文件的信息。此外，文件允许重名也是用户的合理和必然要求，目录管理通过树形结构来解决和实现。 文件控制块和索引结点同进程管理一样，为实现目录管理，操作系统中引入了文件控制块的数据结构。 1) 文件控制块。 文件控制块(FCB)是用来存放控制文件需要的各种信息的数据结构，以实现“按名存取”。FCB的有序集合称为文件目录，一个FCB就是一个文件目录项。为了创建一个新文件，系统将分配一个FCB并存放在文件目录中，成为目录项。 FCB主要包含以下信息：1、基本信息，如文件名、文件的物理位置、文件的逻辑结构、文件的物理结构等。2、存取控制信息，如文件存取权限等。3、使用信息，如文件建立时间、修改时间等。 2) 索引结点。 在检索目录文件的过程中，只用到了文件名，仅当找到一个目录项（查找文件名与目录项中文件名匹配）时，才需要从该目录项中读出该文件的物理地址。也就是说，在检索目录时，文件的其他描述信息不会用到，也不需调入内存。因此，有的系统（如UNIX，见下表）釆用了文件名和文件描述信息分开的方法，文件描述信息单独形成一个称为索引结点的数据结构，简称为i-Node。在文件目录中的每个目录项仅由文件名和指向该文件所对应的i结点的指针构成。 UNIX的文件目录结构： 一个FCB的大小是64字节，盘块大小是1KB，则在每个盘块中可以存放16个FCB（注意，FCB必须连续存放）。而在UNIX系统中一个目录项仅占16字节，其中14字节是文件名，2字节是i结点指针。在1KB的盘块中可存放64个目录项。这样，可使查找文件时平均启动磁盘次数减少到原来的1/4，大大节省了系统开销。 存放在磁盘上的索引结点称为磁盘索引结点，UNIX中的每个文件都有一个唯一的磁盘索引结点，主要包括以下几个方面：1、文件主标识符，拥有该文件的个人或小组的标识符。2、文件类型，包括普通文件、目录文件或特别文件。3、文件存取权限，各类用户对该文件的存取权限。4、文件物理地址，每个索引结点中含有13个地址项，即 iaddr(0) ~ iaddr(12)，它们以直接或间接方式给出数据文件所在盘块的编号。5、文件长度，以字节为单位。6、文件链接计数，在本文件系统中所有指向该文件的文件名的指针计数。7、文件存取时间，本文件最近被进程存取的时间、最近被修改的时间以及索引结点最近被修改的时间。8、文件被打开时，磁盘索引结点复制到内存的索引结点中，以便于使用。在内存索引结点中又增加了以下内容：9、索引结点编号，用于标识内存索引结点。10、状态，指示i结点是否上锁或被修改。11、访问计数，每当有一进程要访问此i结点时，计数加1，访问结束减1。12、逻辑设备号，文件所属文件系统的逻辑设备号。13、链接指针，设置分别指向空闲链表和散列队列的指针。 目录结构在理解一个文件系统的需求前，我们首先来考虑在目录这个层次上所需要执行的操作，这有助于后面文件系统的整体理解。1、搜索：当用户使用一个文件时，需要搜索目录，以找到该文件的对应目录项。2、创建文件：当创建一个新文件时，需要在目录中增加一个目录项。3、删除文件：当删除一个文件时，需要在目录中删除相应的目录项。4、显示目录：用户可以请求显示目录的内容，如显示该用户目录中的所有文件及属性。5、修改目录：某些文件属性保存在目录中，因而这些属性的变化需要改变相应的目录项。 操作时，考虑以下几种目录结构： 单级目录结构在整个文件系统中只建立一张目录表，每个文件占一个目录项，如下图所示。 单级目录结构： 当访问一个文件时，先按文件名在该目录中查找到相应的FCB，经合法性检查后执行相应的操作。当建立一个新文件时，必须先检索所有目录项以确保没有“重名”的情况，然后在该目录中增设一项，把FCB的全部信息保存在该项中。当删除一个文件时，先从该目录中找到该文件的目录项，回收该文件所占用的存储空间，然后再清除该目录项。 单级目录结构实现了 “按名存取”，但是存在查找速度慢、文件不允许重名、不便于文件共享等缺点，而且对于多用户的操作系统显然是不适用的。 两级目录结构单级目录很容易造成文件名称的混淆，可以考虑釆用两级方案，将文件目录分成主文件目录(Master File Directory, MFD)和用户文件目录（User File Directory, UFD)两级，如下图所示。 两级目录结构： 主文件目录项记录用户名及相应用户文件目录所在的存储位置。用户文件目录项记录该用户文件的FCB信息。当某用户欲对其文件进行访问时，只需搜索该用户对应的UFD，这既解决了不同用户文件的“重名”问题，也在一定程度上保证了文件的安全。 两级目录结构可以解决多用户之间的文件重名问题，文件系统可以在目录上实现访问限制。但是两级目录结构缺乏灵活性，不能对文件分类。 多级目录结构（树形目录结构)。将两级目录结构的层次关系加以推广，就形成了多级目录结构，即树形目录结构，如下图所示。 树形目录结枸： 用户要访问某个文件时用文件的路径名标识文件，文件路径名是个字符串，由从根目录出发到所找文件的通路上的所有目录名与数据文件名用分隔符链接起来而成。从根目录出发的路径称绝对路径。当层次较多时，每次从根目录查询浪费时间，于是加入了当前目录，进程对各文件的访问都是相对于当前目录进行的，叫相对路径。当用户要访问某个文件时，使用相对路径标识文件，相对路径由从当前目录出发到所找文件通路上所有目录名与数据文件名用分隔符“/”链接而成。 上图是Linux操作系统的目录结构，“/dev/hda”就是一个绝对路径。若当前目录为 “/bin”，则“./ls”就是一个相对路径，其中符号“.”表示当前工作目录。 通常，每个用户都有各自的“当前目录”，登录后自动进入该用户的“当前目录”。操作系统提供一条专门的系统调用，供用户随时改变“当前目录”。例如，UNIX系统中， “/etc/passwd”文件就包含有用户登录时默认的“当前目录”，可用cd命令改变“当前目录”。 树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，在树形目录中查找一个文件，需要按路径名逐级访问中间结点，这就增加了磁盘访问次数，无疑将影响查询速度。 无环图目录结构。树形目录结构可便于实现文件分类，但不便于实现文件共享，为此在树形目录结构的基础上增加了一些指向同一结点的有向边，使整个目录成为一个有向无环图。 引入无环图目录结构是为了实现文件共享，如下图所示。 图形目录结构： 当某用户要求删除一个共享结点时，若系统只是简单地将它删除，当另一共享用户需要访问时，却无法找到这个文件而发生错误。为此可以为每个共享结点设置一个共享计数器，每当图中增加对该结点的共享链时，计数器加1；每当某用户提出删除该结点时，计数器减1。仅当共享计数器为0时，才真正删除该结点，否则仅删除请求用户的共享链。 在linux中存在类似的实现：ln创建链接，下面会详细介绍。 共享文件（或目录）不同于文件拷贝（副本）。如果有两个文件拷贝，每个程序员看到的是拷贝而不是原件；但如果一个文件被修改，那么另一个程序员的拷贝不会有改变。对于共享文件，只存在一个真正文件，任何改变都会为其他用户所见。 无环图目录结构方便实现了文件的共享，但使得系统的管理变得更加复杂。 共享文件文件共享使多个用户（进程）共享同一份文件，系统中只需保留该文件的一份副本。如果系统不能提供共享功能，那么每个需要该文件的用户都要有各自的副本，会造成对存储空间的极大浪费。随着计算机技术的发展，文件共享的范围已由单机系统发展到多机系统，进而通过网络扩展到全球。这些文件的分享是通过分布式文件系统、远程文件系统、分布式信息系统实现的。这些系统允许多个客户通过C/S模型共享网络中的服务器文件。 现代常用的两种文件共享方法有： 基于索引结点的共享方式（硬链接）在树形结构的目录中，当有两个或多个用户要共享一个子目录或文件时，必须将共享文件或子目录链接到两个或多个用户的目录中，才能方便地找到该文件，如下图所示。 基于索引结点的共享方式： 在这种共享方式中引用索引结点，即诸如文件的物理地址及其他的文件属性等信息，不再是放在目录项中，而是放在索引结点中。在文件目录中只设置文件名及指向相应索引结点的指针。在索引结点中还应有一个链接计数count，用于表示链接到本索引结点（亦即文件）上的用户目录项的数目。当count=2时，表示有两个用户目录项链接到本文件上，或者说是有两个用户共享此文件。 当用户A创建一个新文件时，它便是该文件的所有者，此时将count置为1。当有用户B要共享此文件时，在用户B的目录中增加一个目录项，并设置一指针指向该文件的索引结点。此时，文件主仍然是用户A，count=2。如果用户A不再需要此文件，不能将文件直接删除。因为，若删除了该文件，也必然删除了该文件的索引结点，这样便会便用户B的指针悬空，而用户B则可能正在此文件上执行写操作，此时用户B会无法访问到文件。因此用户A不能删除此文件，只是将该文件的count减1，然后删除自己目录中的相应目录项。用户B仍可以使用该文件。当count=0时，表示没有用户使用该文件，系统将负责删除该文件。 如下图给出了用户B链接到文件上的前、后情况。 文件共享中的链接计数 利用符号链实现文件共享（软链接）为使用户B能共享用户A的一个文件F,可以由系统创建一个LINK类型的新文件，也取名为F，并将文件F写入用户B的目录中，以实现用户B的目录与文件F的链接。在新文件中只存储被链接文件F的路径名。这样的链接方法被称为符号链接。 新文件中的路径名则只被看做是符号链，当用户B要访问被链接的文件F且正要读LINK类新文件时，操作系统根据新文件中的路径名去读该文件，从而实现了用户B对文件F的共享。 在利用符号链方式实现文件共享时，只有文件的拥有者才拥有指向其索引结点的指针。而共享该文件的其他用户则只有该文件的路径名，并不拥有指向其索引结点的指针。这样，也就不会发生在文件主删除一共享文件后留下一悬空指针的情况。当文件的拥有者把一个共享文件删除后，其他用户通过符号链去访问它时，会出现访问失败，于是将符号链删除，此时不会产生任何影响。当然，利用符号链实现文件共享仍然存在问题，例如：一个文件釆用符号链方式共享，当文件拥有者将其删除，而在共享的其他用户使用其符号链接访问该文件之前，又有人在同一路径下创建了另一个具有同样名称的文件，则该符号链将仍然有效，但访问的文件已经改变，从而导致问题。 在符号链的共享方式中，当其他用户读共享文件时，需要根据文件路径名逐个地查找目录，直至找到该文件的索引结点。因此，每次访问时，都可能要多次地读盘，使得访问文件的开销变大并增加了启动磁盘的频率。此外，符号链的索引结点也要耗费一定的磁盘空间。符号链方式有一个很大的优点，即网络共享只需提供该文件所在机器的网络地址以及该机器中的文件路径即可。 软链接：创建一个新的文件LINK，文件内存储目标文件的路径，访问这个LINK文件，读取存储的路径后再去访问目标文件。删除软链接并不会删除目标文件，反过来删除目标文件，会导致LINK文件无法读取到目标文件，但LINK文件并不会消失。硬链接：增加原来的目标文件的一个索引，读取文件就是对原文件的操作。硬链接有一个计数器，删除文件只是将计数器-1，直到计数器为0时，文件才会被真正删除。 上述两种链接方式都存在一个共同的问题，即每个共享文件都有几个文件名。换言之，每增加一条链接，就增加一个文件名。这实质上就是每个用户都使用自己的路径名去访问共享文件。当我们试图去遍历整个文件系统时，将会多次遍历到该共享文件。 硬链接和软链接都是文件系统中的静态共享方法，是属于存储的物理共享。在文件系统中还存在着另外的共享需求，即两个进程同时对同一个文件进行操作，这样的共享可以称为动态共享。 文件保护为了防止文件共享可能会导致文件被破坏或未经核准的用户修改文件，文件系统必须控制用户对文件的存取，即解决对文件的读、写、执行的许可问题。为此，必须在文件系统中建立相应的文件保护机制。 文件保护通过口令保护、加密保护和访问控制等方式实现。其中，口令保护和加密保护是为了防止用户文件被他人存取或窃取，而访问控制则用于控制用户对文件的访问方式。 访问类型对文件的保护可以从限制对文件的访问类型中出发。可加以控制的访问类型主要有以下几种：1、读：从文件中读。2、写：向文件中写。3、执行：将文件装入内存并执行。4、添加：将新信息添加到文件结尾部分。5、删除：删除文件，释放空间。6、列表清单：列出文件名和文件属性。 此外还可以对文件的重命名、复制、编辑等加以控制。这些高层的功能可以通过系统程序调用低层系统调用来实现。保护可以只在低层提供。例如，复制文件可利用一系列的读请求来完成。这样，具有读访问用户同时也具有复制和打印的权限了。 访问控制解决访问控制最常用的方法是根据用户身份进行控制。而实现基于身份访问的最为普通的方法是为每个文件和目录增加一个访问控制列表(Access-Control List, ACL)，以规定每个用户名及其所允许的访问类型。 这种方法的优点是可以使用复杂的访同方法。其缺点是长度无法预期并且可能导致复杂的空间管理，使用精简的访问列表可以解决这个问题。 精简的访问列表釆用拥有者、组和其他三种用户类型。1、拥有者：创建文件的用户。2、组：一组需要共享文件且具有类似访问的用户。3、其他：系统内的所有其他用户。 这样只需用三个域列出访问表中这三类用户的访问权限即可。文件拥有者在创建文件时，说明创建者用户名及所在的组名，系统在创建文件时也将文件主的名字、所属组名列在该文件的FCB中。用户访问该文件时，按照拥有者所拥有的权限访问文件，如果用户和拥有者在同一个用户组则按照同组权限访问，否则只能按其他用户权限访问。UNIX操作系统即釆用此种方法。 口令和密码是另外两种访问控制方法。 口令指用户在建立一个文件时提供一个口令，系统为其建立FCB时附上相应口令，同时告诉允许共享该文件的其他用户。用户请求访问时必须提供相应口令。这种方法时间和空间的开销不多，缺点是口令直接存在系统内部，不够安全。 密码指用户对文件进行加密，文件被访问时需要使用密钥。这种方法保密性强，节省了存储空间，不过编码和译码要花费一定时间。 口令和密码都是防止用户文件被他人存取或窃取，并没有控制用户对文件的访问类型。不过单纯的口令和密码是不够的，加密文件的内容才是更安全的做法。 注意两个问题：1、现代操作系统常用的文件保护方法，是将访问控制列表与用户、组和其他成员访问控制方案一起组合使用。2、对于多级目录结构而言，不仅需要保护单个文件，而且还需要保护子目录内的文件, 即需要提供目录保护机制。目录操作与文件操作并不相同，因此需要不同的保护机制。 文件系统层次结构现代操作系统有多种文件系统类型（如FAT32、NTFS、 ext2、ext3、ext4等），因此文件系统的层次结构也不尽相同。 文件系统层次结构： 1) 用户调用接口文件系统为用户提供与文件及目录有关的调用，如新建、打开、读写、关闭、删除文件，建立、删除目录等。此层由若干程序模块组成，每一模块对应一条系统调用，用户发出系统调用时，控制即转入相应的模块。 2) 文件目录系统文件目录系统的主要功能是管理文件目录，其任务有管理活跃文件目录表、管理读写状态信息表、管理用户进程的打开文件表、管理与组织在存储设备上的文件目录结构、调用下一级存取控制模块。 3) 存取控制验证实现文件保护主要由该级软件完成，它把用户的访问要求与FCB中指示的访问控制权限进行比较，以确认访问的合法性。 4) 逻辑文件系统与文件信息缓冲区逻辑文件系统与文件信息缓冲区的主要功能是根据文件的逻辑结构将用户要读写的逻辑记录转换成文件逻辑结构内的相应块号。 5) 物理文件系统物理文件系统的主要功能是把逻辑记录所在的相对块号转换成实际的物理地址。 6) 分配模块分配模块的主要功能是管理辅存空间，即负责分配辅存空闲空间和回收辅存空间。 7) 设备管理程序模块设备管理程序模块的主要功能是分配设备、分配设备读写用缓冲区、磁盘调度、启动设备、处理设备中断、释放设备读写缓冲区、释放设备等。 文件系统的实现目录实现在读文件前，必须先打开文件。 打开文件时，操作系统利用路径名找到相应目录项，目录项中提供了查找文件磁盘块所需要的信息。目录实现的基本方法有线性列表和哈希表两种。 线性列表最简单的目录实现方法是使用存储文件名和数据块指针的线性表。创建新文件时，必须首先搜索目录表以确定没有同名的文件存在，然后在目录表后增加一个目录项。删除文件则 根据给定的文件名搜索目录表，接着释放分配给它的空间。若要重用目录项，有许多方法：可以将目录项标记为不再使用，或者将它加到空闲目录项表上，还可以将目录表中最后一个目录项复制到空闲位置，并降低目录表长度。釆用链表结构可以减少删除文件的时间。其优点在于实现简单，不过由于线性表的特殊性，比较费时。 哈希表哈希表根据文件名得到一个值，并返回一个指向线性列表中元素的指针。这种方法的优点是查找非常迅速，插入和删除也较简单，不过需要一些预备措施来避免冲突。最大的困难是哈希表长度固定以及哈希函数对表长的依赖性。 目录查询是通过在磁盘上反复搜索完成，需要不断地进行I/O操作，开销较大。所以如前面所述，为了减少I/O操作，把当前使用的文件目录复制到内存，以后要使用该文件时只要在内存中操作，从而降低了磁盘操作次数，提高了系统速度。 文件实现文件分配方式文件分配对应于文件的物理结构，是指如何为文件分配磁盘块。常用的磁盘空间分配方法有三种：连续分配、链接分配和索引分配。有的系统（如RDOS操作系统）对三种方法都支持，但是更普遍的是一个系统只提供一种方法的支持。 1) 连续分配 连续分配方法要求每个文件在磁盘上占有一组连续的块，如下图所示。磁盘地址定义了磁盘上的一个线性排序。这种排序使作业访问磁盘时需要的寻道数和寻道时间最小。 连续分配： 文件的连续分配可以用第一块的磁盘地址和连续块的数量来定义。如果文件有n块长并从位置b开始，那么该文件将占有块b, b+1, b+2, …, b+n-1。一个文件的目录条目包括开始块的地址和该文件所分配区域的长度。 连续分配支持顺序访问和直接访问。其优点是实现简单、存取速度快。缺点在于，文件长度不宜动态增加，因为一个文件末尾后的盘块可能已经分配给其他文件，一旦需要增加，就需要大量移动盘块。此外，反复增删文件后会产生外部碎片（与内存管理分配方式中的碎片相似)，并且很难确定一个文件需要的空间大小，因而只适用于长度固定的文件。 2) 链接分配 链接分配是釆取离散分配的方式，消除了外部碎片，故而显著地提高了磁盘空间的利用率；又因为是根据文件的当前需求，为它分配必需的盘块，当文件动态增长时，可以动态地再为它分配盘块，故而无需事先知道文件的大小。此外，对文件的增、删、改也非常方便。链接分配又可以分为隐式链接和显式链接两种形式。 隐式连接如下图所示。每个文件对应一个磁盘块的链表；磁盘块分布在磁盘的任何地方，除最后一个盘块外，每一个盘块都有指向下一个盘块的指针，这些指针对用户是透明的。目录包括文件第一块的指针和最后一块的指针。 隐式链接分配： 创建新文件时，目录中增加一个新条目。每个目录项都有一个指向文件首块的指针。该指针初始化为NULL以表示空文件，大小字段为0。写文件会通过空闲空间管理系统找到空闲块，将该块链接到文件的尾部，以便写入。读文件则通过块到块的指针顺序读块。 隐式链接分配的缺点在于无法直接访问盘块，只能通过指针顺序访问文件，以及盘块指针消耗了一定的存储空间。隐式链接分配的稳定性也是一个问题，系统在运行过程中由于软 件或者硬件错误导致链表中的指针丢失或损坏，会导致文件数据的丢失。 显式链接是指把用于链接文件各物理块的指针，显式地存放在内存的一张链接表中。 该表在整个磁盘仅设置一张，每个表项中存放链接指针，即下一个盘块号。在该表中，凡是属于某一文件的第一个盘块号，或者说是每一条链的链首指针所对应的盘块号，均作为文件地址被填入相应文件的FCB的“物理地址”字段中。由于查找记录的过程是在内存中进行的，因而不仅显著地提高了检索速度，而且大大减少了访问磁盘的次数。由于分配给文件的所有盘块号都放在该表中，故称该表为文件分配表（File Allocation Table, FAT)。 3) 索引分配。 链接分配解决了连续分配的外部碎片和文件大小管理的问题。但是，链接分配不能有效支持直接访问（FAT除外）。索引分配解决了这个问题，它把每个文件的所有的盘块号都集中放在一起构成索引块（表），如下图所示。 索引分配： 每个文件都有其索引块，这是一个磁盘块地址的数组。索引块的第i个条目指向文件的第i个块。目录条目包括索引块的地址。要读第i块，通过索引块的第i个条目的指针来查找和读入所需的块。 创建文件时，索引块的所有指针都设为空。当首次写入第i块时，先从空闲空间中取得一个块，再将其地址写到索引块的第i个条目。索引分配支持直接访问，且没有外部碎片问 题。其缺点是由于索引块的分配，增加了系统存储空间的开销。索引块的大小是一个重要的问题，每个文件必须有一个索引块，因此索引块应尽可能小，但索引块太小就无法支持大文件。 可以釆用以下机制来处理这个问题。 链接方案：一个索引块通常为一个磁盘块，因此，它本身能直接读写。为了处理大文件，可以将多个索引块链接起来。多层索引：多层索引使第一层索引块指向第二层的索引块，第二层索引块再指向文件块。这种方法根据最大文件大小的要求，可以继续到第三层或第四层。例如，4096B的块，能在 索引块中存入1024个4B的指针。两层索引允许1048576个数据块，即允许最大文件为4GB。混合索引：将多种索引分配方式相结合的分配方式。例如，系统既釆用直接地址，又采用单级索引分配方式或两级索引分配方式。 三种分配方式的比较： 文件存储空间管理1) 文件存储器空间的划分与初始化。 一般来说，一个文件存储在一个文件卷中。文件卷可以是物理盘的一部分，也可以是整个物理盘，支持超大型文件的文件卷也可以由多个物理盘组成，如下图所示。 逻辑卷与物理盘的关系： 在一个文件卷中，文件数据信息的空间（文件区）和存放文件控制信息FCB的空间（目 录区）是分离的。由于存在很多种类的文件表示和存放格式，所以现代操作系统中一般都有 很多不同的文件管理模块，通过它们可以访问不同格式的逻辑卷中的文件。逻辑卷在提供文件服务前，必须由对应的文件程序进行初始化，划分好目录区和文件区，建立空闲空间管理 表格及存放逻辑卷信息的超级块。 2) 文件存储器空间管理。 文件存储设备分成许多大小相同的物理块，并以块为单位交换信息，因此，文件存储设备的管理实质上是对空闲块的组织和管理，它包括空闲块的组织、分配与回收等问题。 ①空闲表法空闲表法属于连续分配方式，它与内存的动态分配方式类似，为每个文件分配一块连续的存储空间。系统为外存上的所有空闲区建立一张空闲盘块表，每个空闲区对应于一个空闲 表项，其中包括表项序号、该空闲区第一个盘块号、该区的空闲盘块数等信息。再将所有空闲区按其起始盘块号递增的次序排列，见下表。 空闲盘块表： 空闲盘区的分配与内存的动态分配类似，同样是釆用首次适应算法、循环首次适应算法等。例如，在系统为某新创建的文件分配空闲盘块时，先顺序地检索空闲盘块表的各表项，直至找到第一个其大小能满足要求的空闲区，再将该盘区分配给用户，同时修改空闲盘块表。 系统在对用户所释放的存储空间进行回收时，也釆取类似于内存回收的方法，即要考虑回收区是否与空闲表中插入点的前区和后区相邻接，对相邻接者应予以合并。 ②空闲链表法将所有空闲盘区拉成一条空闲链，根据构成链所用的基本元素不同，可把链表分成两种形式：空闲盘块链和空闲盘区链。 空闲盘块链是将磁盘上的所有空闲空间，以盘块为单位拉成一条链。当用户因创建文件 而请求分配存储空间时，系统从链首开始，依次摘下适当的数目的空闲盘块分配给用户。当 用户因删除文件而释放存储空间时，系统将回收的盘块依次插入空闲盘块链的末尾。这种方法的优点是分配和回收一个盘块的过程非常简单，但在为一个文件分配盘块时，可能要重复多次操作。 空闲盘区链是将磁盘上的所有空闲盘区（每个盘区可包含若干个盘块）拉成一条链。在每个盘区上除含有用于指示下一个空闲盘区的指针外，还应有能指明本盘区大小（盘块数） 的信息。分配盘区的方法与内存的动态分区分配类似，通常釆用首次适应算法。在回收盘区时，同样也要将回收区与相邻接的空闲盘区相合并。 ③位示图法位示图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有 一个二进制位与之对应。当其值为“0”时，表示对应的盘块空闲；当其值为“1”时，表示对应的盘块已分配。 盘块的分配：1、顺序扫描位示图，从中找出一个或一组其值为“0”的二进制位。2、将所找到的一个或一组二进制位，转换成与之对应的盘块号。假定找到的其值为“0” 的二进制位，位于位示图的第i行、第j列，则其相应的盘块号应按下式计算（n代表每行 的位数）： b = n (i-1) + j3、修改位示图，令map[i, j] = 1。 盘块的回收：1、将回收盘块的盘块号转换成位示图中的行号和列号。2、转换公式为 i=(b-1)DIVn+l j=(b-l)MOD n+13、修改位示图，令map[i, j] = 0。 ④成组链接法空闲表法和空闲链表法都不适合用于大型文件系统，因为这会使空闲表或空闲链表太大。在UNIX系统中釆用的是成组链接法，这种方法结合了空闲表和空闲链表两种方法，克服了表太大的缺点。其大致的思想是：把顺序的n个空闲扇区地址保存在第一个空闲扇区内， 其后一个空闲扇区内则保存另一顺序空闲扇区的地址，如此继续，直至所有空闲扇区均予以链接。系统只需要保存一个指向第一个空闲扇区的指针。假设磁盘最初全为空闲扇区；其成组链接如下图所示。通过这种方式可以迅速找到大批空闲块地址。 成组链接法示意图： 表示文件存储器空闲空间的“位向量”表或第一个成组链块以及卷中的目录区、文件区划分信息都需要存放在辅存储器中，一般放在卷头位置，在UNIX系统中称为“超级块”。在对卷中文件进行操作前，“超级块”需要预先读入系统空间的主存，并且经常保持主存“超 级块”与辅存卷中“超级块”的一致性。 注意：本书如无特别提示，所使用的位示图法，行和列都是从1开始编号。特别注意，如果题目中指明从0开始编号，则上述的计算方法要进行相应调整。 磁盘的结构磁盘(Disk)是由表面涂有磁性物质的金属或塑料构成的圆形盘片，通过一个称为磁头的导体线圈从磁盘中存取数据。在读/写操作期间，磁头固定，磁盘在下面高速旋转。 如下所示，磁盘的盘面上的数据存储在一组同心圆中，称为磁道。每个磁道与磁头一样宽, 一个盘面有上千个磁道。磁道又划分为几百个扇区，每个扇区固定存储大小（通常为512B), 一个扇区称为一个盘块。相邻磁道及相邻扇区间通过一定的间隙分隔开，以避免精度错误。 注意，由于扇区按固定圆心角度划分，所以密度从最内而外道递减，磁盘的存储能力受限于最内道的最大密度。 磁盘安装在一个磁盘驱动器中，它由磁头臂、用于旋转磁盘的主轴和用于数据输入/输出的电子设备组成。如下图所示，多个盘片垂直堆叠，组成磁盘组，每个盘面对应一个磁头，所有磁头固定在一起，与磁盘中心的距离相同且一起移动。所有盘片上相对位置相同的磁道组成柱面。按照这种物理结构组织，扇区就是磁盘可寻址的最小存储单位，磁盘地址用“柱面号 • 盘面号 • 扇区号（或块号）”表示。 磁盘按不同方式可以分为若干类型：磁头相对于盘片的径向方向固定的称为固定头磁盘，每个磁道一个磁头；磁头可移动的称为活动头磁盘，磁头臂可以来回伸缩定位磁道。磁盘永久固定在磁盘驱动器内的称为固定盘磁盘；可移动和替换的称为可换盘磁盘。 磁盘调度算法一次磁盘读写操作的时间由寻找（寻道）时间、延迟时间和传输时间决定： 1) 寻找时间Ts：活动头磁盘在读写信息前，将磁头移动到指定磁道所需要的时间。这个时间除跨越n条磁道的时间外，还包括启动磁臂的时间s，即：式中，m是与磁盘驱动器速度有关的常数，约为0.2ms，磁臂的启动时间约为2ms。 2)延迟时间Tr：磁头定位到某一磁道的扇区（块号）所需要的时间，设磁盘的旋转速度为r，则：对于硬盘，典型的旋转速度为5400r/m，相当于一周11.1ms，则Tr为5.55ms;对于软盘，其旋转速度在300~600r/m之间，则Tr为50~100ms。 3) 传输时间Tt：从磁盘读出或向磁盘写入数据所经历的时间，这个时间取决于每次所读/写的字节数b和磁盘的旋转速度：式中，r为磁盘每秒钟的转数；N为一个磁道上的字节数。 在磁盘存取时间的计算中，寻道时间与磁盘调度算法相关，下面将会介绍分析几种算法，而延迟时间和传输时间都与磁盘旋转速度相关，且为线性相关，所以在硬件上，转速是磁盘性能的一个非常重要的参数。 总平均存取时间Ta可以表示为： 虽然这里给出了总平均存取时间的公式，但是这个平均值是没有太大实际意义的，因为在实际的磁盘I/O操作中，存取时间与磁盘调度算法密切相关。调度算法直接决定寻找时间，从而决定了总的存取时间。 目前常用的磁盘调度算法有以下几种： 先来先服务(First Come First Served, FCFS)算法FCFS算法根据进程请求访问磁盘的先后顺序进行调度，这是一种最简单的调度算法，如下图所示。该算法的优点是具有公平性。如果只有少量进程需要访问，且大部分请求都是访问簇聚的文件扇区，则有望达到较好的性能；但如果有大量进程竞争使用磁盘，那么这种算法在性能上往往接近于随机调度。所以，实际磁盘调度中考虑一些更为复杂的调度算法。 FCFS磁盘调度算法： 例如，磁盘请求队列中的请求顺序分别为55、58、39、18、90、160、150、38、184，磁头初始位置是100磁道，釆用FCFS算法磁头的运动过程如上图所示。磁头共移动了 (45+3+19+21+72+70+10+112+146)=498 个磁道，平均寻找长度=498/9=55.3。 最短寻找时间优先(Shortest Seek Time First, SSTF)算法SSTF算法选择调度处理的磁道是与当前磁头所在磁道距离最近的磁道，以使每次的寻找时间最短。当然，总是选择最小寻找时间并不能保证平均寻找时间最小，但是能提供比 FCFS算法更好的性能。这种算法会产生“饥饿”现象。如图4-26所示，若某时刻磁头正在 18号磁道，而在18号磁道附近频繁地增加新的请求，那么SSTF算法使得磁头长时间在18 号磁道附近工作，将使184号磁道的访问被无限期地延迟，即被“饿死”。 SSTF磁盘调度算法： 例如，磁盘请求队列中的请求顺序分别为55、58、39、18、90、160、150、38、184，磁头初始位置是100磁道，釆用SSTF算法磁头的运动过程如上图所示。磁头共移动了 (10+32+3+16+1+20+132+10+24)=248 个磁道，平均寻找长度=248/9=27.5。 扫描(SCAN)算法（又称电梯算法）SCAN算法在磁头当前移动方向上选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象，如下图所示。由于磁头移动规律与电梯运行相似，故又称为电梯调度算法。SCAN算法对最近扫描过的区域不公平，因此，它在访问局部性方面不如FCFS算法和 SSTF算法好。 SCAN磁盘调度算法： 例如，磁盘请求队列中的请求顺序分别为55、58、39、18、90、160、150、38、184，磁头初始位置是100 磁道。釆用SCAN算法时，不但要知道磁头的当前位置，还要知道磁头的移动方向，假设磁头沿磁道号增大的顺序移动，则磁头的运动过程如上图所示。 磁头共移动了(50+10+24+94+32+3+16+1+20)=250 个磁道，平均寻找长度=250/9=27.8。 循环扫描(Circulair SCAN, C-SCAN)算法在扫描算法的基础上规定磁头单向移动来提供服务，回返时直接快速移动至起始端而不服务任何请求。由于SCAN算法偏向于处理那些接近最里或最外的磁道的访问请求，所以使用改进型的C-SCAN算法来避免这个问题。 釆用SCAN算法和C-SCAN算法时磁头总是严格地遵循从盘面的一端到另一端，显然，在实际使用时还可以改进，即磁头移动只需要到达最远端的一个请求即可返回，不需要到达磁盘端点。这种形式的SCAN算法和C-SCAN算法称为LOOK和C-LOOK调度。这是因为它们在朝一个给定方向移动前会查看是否有请求。注意，若无特别说明，也可以默认SCAN算法和C-SCAN算法为LOOK和C-LOOK调度。 C-SCAN磁盘调度算法： 例如，磁盘请求队列中的请求顺序分别为55、58、39、18、90、160、150、38、184，磁头初始位置是100磁道。釆用C-SCAN算法时，假设磁头沿磁道号增大的顺序移动，则磁头的运动过程如图4-28所示。 磁头共移动了(50+10+24+166+20+1+16+3+32)=322个磁道，平均寻道长度=322/9=35.8。 对比以上几种磁盘调度算法：FCFS算法太过简单，性能较差，仅在请求队列长度接近于1时才较为理想；SSTF算法较为通用和自然；SCAN算法和C-SCAN算法在磁盘负载较大时比较占优势。 除减少寻找时间外，减少延迟时间也是提高磁盘传输效率的重要因素。可以对盘面扇区进行交替编号，对磁盘片组中的不同盘面错位命名。假设每个盘面有8个扇区，磁盘片组共8个盘面，则可以釆用如下图所示的编号。 磁盘片组扇区编号： 磁盘是连续自转设备，磁头读/写一个物理块后，需要经过短暂的处理时间才能开始读/写下一块。假设逻辑记录数据连续存放在磁盘空间中，若在盘面上按扇区交替编号连续存放，则连续读/写多个记录时能减少磁头的延迟时间；同柱面不同盘面的扇区若能错位编号，连续读/写相邻两个盘面的逻辑记录时也能减少磁头延迟时间。 由于传输时间由磁盘转速决定，所以无法通过其他方法减少传输时间。以上图为例，在随机扇区访问情况下，定位磁道中的一个扇区平均需要转过4个扇区，这时，延迟时间是传输时间的4倍，这是一种非常低效的存取方式。理想化的情况是不需要定位而直接连续读取扇区，没有延迟时间，这样磁盘数据存取效率可以成倍提高。但是由于读取扇区的顺序是不可预测的，所以延迟时间不可避免。上图中的编号方式是读取连续编号扇区时的一种方法。 磁盘的管理磁盘初始化一个新的磁盘只是一个含有磁性记录材料的空白盘。在磁盘能存储数据之前，它必须分成扇区以便磁盘控制器能进行读和写操作，这个过程称为低级格式化（物理分区）。低级格式化为磁盘的每个扇区釆用特别的数据结构。每个扇区的数据结构通常由头、数据区域（通常为512B大小）和尾部组成。头部和尾部包含了一些磁盘控制器所使用的信息。 为了使用磁盘存储文件，操作系统还需要将自己的数据结构记录在磁盘上：第一步将磁盘分为由一个或多个柱面组成的分区（即我们熟悉的C盘、D盘等形式的分区）；第二步对物理分区进行逻辑格式化（创建文件系统)，操作系统将初始的文件系统数据结构存储到磁盘上，这些数据结构包括空闲和已分配的空间以及一个初始为空的目录。 引导块计算机启动时需要运行一个初始化程序（自举程序），它初始化CPU、寄存器、设备控制器和内存等，接着启动操作系统。为此，该自举程序应找到磁盘上的操作系统内核，装入内存，并转到起始地址，从而开始操作系统的运行。 自举程序通常保存在ROM中，为了避免改变自举代码需要改变ROM硬件的问题，故只在ROM中保留很小的自举装入程序，将完整功能的自举程序保存在磁盘的启动块上，启动块位于磁盘的固定位（会给予保护）。拥有启动分区的磁盘称为启动磁盘或者系统磁盘。 坏块由于磁盘有移动部件且容错能力弱，所以容易导致一个或多个扇区损坏。部分磁盘甚至从出厂时就有坏扇区。根据所使用的磁盘和控制器，对这些块有多种处理方式。 对于简单磁盘，如电子集成驱动器（IDE)。坏扇区可手工处理，如MS-DOS的Format命令执行逻辑格式化时便会扫描磁盘以检查坏扇区。坏扇区在FAT表上会标明，因此程序不会使用。 对于复杂的磁盘，如小型计算机系统接口（SCSI)，其控制器维护一个磁盘坏块链表。该链表在出厂前进行低级格式化时就初始化了，并在磁盘的整个使用过程中不断更新。低级格式化将一些块保留作为备用，对操作系统透明。控制器可以用备用块来逻辑地替代坏块，这种方案称为扇区备用。 总结思考磁盘结构 引导控制块(Boot Control Block)包括系统从该分区引导操作系统所需要的信息。 如果磁盘没有操作系统，那么这块的内容为空。它通常为分区的第一块。UFS称其为引导块(Boot Block)；NTFS称其为分区引导扇区(Partition Boot Sector)。 分区控制块(Partition Control Block)包括分区详细信息，如分区的块数、块的大小、空闲块的数量和指计、空闲FCB的数量和指针等。UPS称其为超级块(Superblock)；NTFS称其为主控文件表(Master File Table)。 内存结构内存分区表包含所有安装分区的信息。 内存目录结构用来保存近来访问过的目录信息。对安装分区的目录，可以包括一个指向分区表的指针。 系统范围的打开文件表，包括每个打开文件的FCB复制和其他信息。 单个进程的打开文件表，包括一个指向系统范围内已打开文件表中合适条目和其他信息的指针。 文件系统实现概述为了创建一个文件，应用程序调用逻辑文件系统。逻辑文件系统知道目录结构形式，它将分配一个新的FCB给文件，把相应目录读入内存，用新的文件名更新该目录和FCB，并将结果写回到磁盘。 典型的FCB： 一旦文件被创建，它就能用于I/O，不过首先要打开文件。调用open将文件名传给文件系统，文件系统根据给定文件名搜索目录结构。部分目录结构通常缓存在内存中以加快目录 操作。找到文件后，其FCB复制到系统范围的打开文件表。该表不但存储FCB，也有打开该文件的进程数量的条目。 然后，单个进程的打开文件表中会增加一个条目，并通过指针将系统范围的打开文件表的条目同其他域（文件当前位置的指针和文件打开模式等）相连。调用open返回的是一个 指向单个进程的打开文件表中合适条目的指针。所有文件操作都是通过该指针进行。 文件名不必是打开文件表的一部分，因为一旦完成对FCB在磁盘上的定位，系统就不再使用文件名了。对于访问打开文件表的索引，UNIX称之为文件描述符(File Descriptor)；而Windows 2000称之为文件句柄(File Handle)。因此，只要文件没有被关闭，所有文件操作通过打开文件表查表来进行。 当一个进程关闭文件，就删除一个相应的单个进程打开文件表的条目即目录项，系统范围内打开文件表的打开数也会递减。当打开文件的所有用户都关闭了一个文件时，更新的文件信息会复制到磁盘的目录结构中，系统范围的打开文件表的条目也将删除。 在实际中，系统调用open会首先搜索系统范围的打开文件表以确定某文件是否已被其他进程所使用。如果是，就在单个进程的打开文件表中创建一项，并指向现有系统范围的打开文件表的相应条目。该算法在文件已打开时，能节省大量开销。 混合索引分配的实现混合索引分配已在UNIX系统中釆用。 在UNK SystemV的索引结点中，共设置了13个地址项，即iaddr(O)~iaddr(12)，如下图所示。在BSD UNIX的索引结点中，共设置了13个地址项，它们都把所有的地址项分成两类，即直接地址和间接地址。 UNIX系统的inode结构示意图： 1) 直接地址 为了提高对文件的检索速度，在索引结点中可设置10个直接地址项，即用iaddr(O)~iaddr(9)来存放直接地址。换言之，在这里的每项中所存放的是该文件数据所在盘块的盘块号。假如每个盘块的大小为4KB，当文件不大于40KB时，便可直接从索引结点中读出该文件的全部盘块号。 2) 一次间接地址 对于大、中型文件，只釆用直接地址并不现实。可再利用索引结点中的地址项iaddr(lO) 来提供一次间接地址。这种方式的实质就是一级索引分配方式。图中的一次间址块也就是索引块，系统将分配给文件的多个盘块号记入其中。在一次间址块中可存放1024个盘块号， 因而允许文件长达4MB。 3) 多次间接地址 当文件长度大于4MB+40KB（—次间址与10个直接地址项）时，系统还须釆用二次间址分配方式。这时，用地址项iaddr(11)提供二次间接地址。该方式的实质是两级索引分配方 式。系统此时是在二次间址块中记入所有一次间址块的盘号。在釆用二次间址方式时，文件最大长度可达4GB。同理，地址项iaddr(12)作为三次间接地址，其所允许的文件最大长度可达4TB。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>学习</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统原理之基础知识]]></title>
    <url>%2F2017%2F07%2F15-operation-system-basic-knowledge%2F</url>
    <content type="text"><![CDATA[操作系统原理之基础知识操作系统是很重要的基础知识，尽管现在的软件开发中不是特别需要考虑很底层的东西，但是了解操作系统的知识，对编程的深入理解也是有裨益的。现在结合这篇博客对操作系统基础知识做一些巩固和总结。 基本概念在信息化时代，软件被称为计算机系统的灵魂。而作为软件核心的操作系统，已经与现代计算机系统密不可分、融为一体。计算机系统自下而上可粗分为四个部分：硬件、操作系统、应用程序和用户（这里的划分与计算机组成原理的分层不同）。操作系统管理各种计算机硬件，为应用程序提供基础，并充当计算机硬件与用户之间的中介。 硬件，如中央处理器、内存、输入/输出设备等，提供了基本的计算资源。应用程序，如字处理程序、电子制表软件、编译器、网络浏览器等，规定了按何种方式使用这些资源来解决用户的计算问题。操作系统控制和协调各用户的应用程序对硬件资源的分配与使用。 在计算机系统的运行过程中，操作系统提供了正确使用这些资源的方法。 综上所述，操作系统(Operating System, OS)是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境的程序集合。计算机操作系统是随着计算机研究和应用的发展逐步形成并发展起来的，它是计算机系统中最基本的系统软件。 特征操作系统是一种系统软件，但与其他的系统软件和应用软件有很大的不同，它有自己的特殊性即基本特征。操作系统的基本特征包括并发、共享、虚拟和异步。这些概念对理解和掌握操作系统的核心至关重要，将一直贯穿于各个章节中。 并发(Concurrence)并发是指两个或多个事件在同一时间间隔内发生。操作系统的并发性是指计算机系统中同时存在多个运行着的程序，因此它具有处理和调度多个程序同时执行的能力。在操作系统 中，引入进程的目的是使程序能并发执行。 注意同一时间间隔（并发）和同一时刻（并行）的区别。在多道程序环境下，一段时间内，宏观上有多道程序在同时执行，而在每一时刻，单处理机环境下实际仅能有一道程序执行，故微观上这些程序还是在分时地交替执行。橾作系统的并发性是通过分时得以实现的。 注意，并行性是指系统具有可以同时进行运算或操作的特性，在同一时刻完成两种或两种以上的工作。并行性需要有相关硬件的支持，如多流水线或多处理机硬件环境。 简单说：并发性是通过单处理器分时执行多个作业实现的，而并行性是指多处理器可以真正同时处理多个作业。 共享（Sharing)资源共享即共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。 共享可分为两种资源共享方式：互斥共享方式、同时访问方式。 1) 互斥共享方式 系统中的某些资源，如打印机、磁带机，虽然它们可以提供给多个进程使用，但为使所打印或记录的结果不致造成混淆，应规定在一段时间内只允许一个进程访问该资源。 为此，当进程A访问某资源时，必须先提出请求，如果此时该资源空闲，系统便可将之分配给进程A使用，此后若再有其他进程也要访问该资源时（只要A未用完）则必须等待。仅当进程A访问完并释放该资源后，才允许另一进程对该资源进行访问。我们把这种资源共享方式称为互斥式共享，而把在一段时间内只允许一个进程访问的资源称为临界资源或独占资源。 计算机系统中的大多数物理设备，以及某些软件中所用的栈、变量和表格，都属于临界资源，它们都要求被互斥地共享。 2) 同时访问方式 系统中还有另一类资源，允许在一段时间内由多个进程“同时”对它们进行访问。这里所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问即“分时共享”。典型的可供多个进程“同时”访问的资源是磁盘设备，一些用重入码编写的文件也可以被“同时”共享，即若干个用户同时访问该文件。 并发和共享是操作系统两个最基本的特征，这两者之间又是互为存在条件的： 并发则可能存在共享，而共享会影响并发。 资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题；若系统不能对资源共享实施有效的管理，也必将影响到程序的并发执行，甚至根本无法并发执行。 虛拟（Virtual)虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实的，即实际存在的；而后者是虚的，是用户感觉上的事物。用于实现虚拟的技术，称为虚拟技术。 在操作系统中利用了多种虚拟技术，分别用来实现虚拟处理器、虚拟内存和虚拟外部设备等。 在虚拟处理器技术中，是通过多道程序设计技术，让多道程序并发执行的方法，来分时使用一个处理器的。此时，虽然只有一个处理器，但它能同时为多个用户服务，使每个终端用户都感觉有一个中央处理器（CPU)在专门为它服务。利用多道程序设计技术，把一个物理上的CPU虚拟为多个逻辑上的CPU，称为虚拟处理器（比如笔者的电脑，配有酷睿i5处理器，只有两个物理处理器，但是从资源管理器中可以看到有四个逻辑处理器，也就是说每个物理处理器被分为2个逻辑处理器）。 类似地，可以通过虚拟存储器技术，将一台机器的物理存储器变为虚拟存储器，以便从逻辑上来扩充存储器的容量（比如虚拟内存，利用用户的硬盘来实现对内存容量的扩充）。当然,这时用户所感觉到的内存容量是虚的。我们把用户所感觉到的存储器（实际是不存在的）称为虚拟存储器。 还可以通过虚拟设备技术，将一台物理I/O设备虚拟为多台逻辑上的I/O设备，并允许每个用户占用一台逻辑上的I/O设备，这样便可以使原来仅允许在一段时间内由一个用户访问的设备（即临界资源)，变为在一段时间内允许多个用户同时访问的共享设备。 因此，操作系统的虚拟技术可归纳为： 时分复用技术（如处理器的分时共享）、空分复用技术（如虚拟存储器）。 异步(Asynchronism)在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。 异步性使得操作系统运行在一种随机的环境下，可能导致进程产生与时间有关的错误（就像对全局变量的访问顺序不当会导致程序出错一样）。但是只要运行环境相同，操作系统必须保证多次运行进程，都获得相同的结果。这也是线程和进程管理部分的知识。 目标和功能为了给多道程序提供良好的运行环境，操作系统应具有以下几方面的功能：处理机管理、 存储器管理、设备管理和文件管理。为了方便用户使用操作系统，还必须向用户提供接口。同时操作系统可用来扩充机器，以提供更方便的服务、更高的资源利用率。 操作系统是计算机系统资源的管理者。1) 处理机管理在多道程序环境下，处理机的分配和运行都以进程（或线程）为基本单位，因而对处理机的管理可归结为对进程的管理。并发时在计算机内同时运行多个进程，所以，进程何时创建、何时撤销、如何管理、如何避免冲突、合理共享就是进程管理的最主要的任务。 进程管理的主要功能有：进程控制、进程同步、进程通信、死锁处理、处理机调度等。 2) 存储器管理存储器管理是为了给多道程序的运行提供良好的环境，方便用户使用以及提高内存的利用率，主要包括内存分配、地址映射、内存保护与共享和内存扩充等功能。 3) 文件管理计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为文件系统。文件管理包括文件存储空间的管理、目录管理及文件读写管理和保护等。 4) 设备管理设备管理的主要任务是完成用户的I/O请求，方便用户使用各种设备，并提高设备的利用率，主要包括缓冲管理、设备分配、设备处理和虛拟设备等功能。 操作系统是用户与计算机硬件系统之间的接口。为方便用户使用计算机，操作系统还提供了用户接口。操作系统提供的接口主要分为两类：一类是命令接口，普通用户可以利用这些操作命令来组织和控制作业的执行（比如Linux中有很多命令可以直接使用）；一类是程序接口，编程人员可以使用它们来请求操作系统服务（比如Windows编程中有很多系统API提供调用）。 1) 命令接口 使用命令接口进行作业控制的主要方式有两种，即联机控制方式和脱机控制方式。按作业控制方式的不同，可以将命令接口分为联机命令接口和脱机命令接口。 联机命令接口又称交互式命令接口，适用于分时或实时系统的接口。它由一组键盘操作命令组成。用户通过控制台或终端输入操作命令，向系统提出各种服务要求。用户每输入完一条命令，控制权就转入操作系统的命令解释程序，然后由命令解释程序对输入的命令解释并执行，完成指定的功能。之后，控制权又转回到控制台或终端，此时用户又可以输入下一条命令。 脱机命令接口又称批处理命令接口，即适用于批处理系统，它由一组作业控制命令（或称作业控制语句）组成（比如Bash脚本）。脱机用户不能直接干预作业的运行，应事先用相应的作业控制命令形成一份作业操作说明书，连同作业一起提交给系统。当系统调度到该作业时，由系统中的命令解释程序对作业说明书上的命令或作业控制语句遂条解释执行，从而间接地控制作业的运行。 2) 程序接口 程序接口由一组系统调用命令（简称系统调用，也称广义指令）组成。用户通过在程序中使用这些系统调用命令来请求操作系统为其提供服务。用户在程序中可以直接使用这组系统调用命令向系统提出各种服务要求，如使用各种外部设备，进行有关磁盘文件的操作，申请分配和回收内存以及其他各种控制要求。也就是说，用户向系统接口发出合法请求后，由操作系统去执行，用户或应用程序无需干预。 而当前最为流行的是图形用户界面(GUI)即图形接口，用户通过鼠标和键盘，在图形界面上单击或使用快捷键就能很方便地使用操作系统。不过GUI最终是通过调用程序接口实现的，严格地说它不属于操作系统的一部分。换句话说操作系统即使没有GUI，也一样能正常运行（比如Linux服务器版）。 操作系统用做扩充机器没有任何软件支持的计算机称为裸机，它仅构成计算机系统的物质基础，而实际呈现在用户面前的计算机系统是经过若干层软件改造的计算机。裸机在最里层，它的外面是操作系统，类似同心圆结构。操作系统提供资源管理功能、以及方便用户使用的各种服务，从而将裸机改造成功能更强、更方便使用的机器。 通常把覆盖了软件的机器称为扩充机器，又称之为虚拟机。 发展与分类手工操作阶段（此阶段无操作系统）用户在计算机上算题的所有工作都要人工干预，如程序的装入、运行、结果的输出等。随着计算机硬件的发展，人机矛盾（速度和资源利用）越来越大，必须寻求新的解决办法。 手工操作阶段有两个突出的特点：1、用户独占全机，虽然不会出现因资源已被其他用户占用而等待的现象，但是资源利用率低。2、CPU等待手工操作，CPU计算能力利用的不充分。 唯一的解决办法就是用高速的机器代替相对较慢的手工操作来对作业进行控制。 批处理阶段（操作系统开始出现）为了解决人机矛盾、CPU和I/O设备之间速度不匹配的矛盾，出现了批处理系统。它按发展历程又分为单道批处理系统、多道批处理系统（多道程序设计技术出现以后）。 1) 单道批处理系统系统对作业的处理是成批进行的，但内存中始终保持一道作业。该系统是在解决人机矛盾、CPU与I/O设备速率不匹配的矛盾中形成的。 单道批处理系统的主要特征如下：1、自动性。在顺利的情况下，磁带上的一批作业能自动地逐个依次运行，无需人工干预。 ‘2、顺序性。磁带上的各道作业是顺序地进入内存，各道作业的完成顺序与它们进入内存的顺序，在正常情况下应完全相同，即先调入内存的作业先完成。3、单道性。内存中仅有一道程序运行，即监督程序每次从磁带上只调入一道程序进入内存运行，当该程序完成或发生异常情况时，才调入其后继程序进入内存运行。 但是此时面临的问题是：每次主机内存中仅存放一道作业，每当它运行期间（注意这里是“运行时”，并不是“完成后”）发出输入/输出请求后，高速的CPU便处于等待低速的I/O完成输入输出操作的状态。为此，为了进一步提高资源的利用率和系统的吞吐量，引入了多道程序技术。 2) 多道批处理系统 多道程序设计技术允许多个程序同时进入内存并运行。即同时把多个程序放入内存，并允许它们交替在CPU中运行，它们共享系统中的各种硬、软件资源。当一道程序因I/O请求而暂停运行时，CPU便立即转去运行另一道程序。它没有用某些机制提高某一技术方面的瓶颈问题，而是让系统的各个组成部分都尽量去“忙”，花费很少时间去切换任务，达到了系统各部件之间的并行工作，使其整体在单位时间内的效率翻倍。 多道程序设计技术的特点有：1、多道：计算机内存中同时存放多道相互独立的程序。2、宏观上并行：同时进入系统的多道程序都处于运行过程中，即它们先后开始了各自的运行，但都未运行完毕。3、微观上串行：内存中的多道程序轮流占有CPU，交替执行。 多道程序设计技术的实现需要解决下列问题：1、处理器分配问题。2、内存分配问题。3、I/O设备分配问题。4、如何组织和存放大量的程序和数据，以便于用户使用和保证其安全性与一致性。 釆用多道程序设计技术就相应的形成了多道批处理操作系统。该系统把用户提交的作业成批地送入计算机内存，然后由作业调度程序自动地选择作业运行。 多道批处理操作系统优点是：1、资源利用率高，多道程序共享计算机资源，从而使各种资源得到充分利用；2、系统吞吐量大，CPU和其他资源保持“忙碌”状态。 多道批处理操作系统缺点是：1、用户响应的时间较长。2、不提供人机交互能力，用户既不能了解自己程序的运行情况，也不能控制计算机。 分时操作系统在操作系统中釆用分时技术就形成了分时系统。 所谓分时技术就是把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用。若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时停止运行，把处理器让给其他作业使用，等待下一轮再继续运行。由于计算机速度很快，作业运行轮转得很快，给每个用户的感觉好像是自己独占一台计算机。 分时操作系统是多个用户通过终端同时共享一台主机，这些终端连接在主机上，用户可以同时与主机进行交互操作而互不干扰。所以，实现分时系统最关键的问题是如何使用户能与自己的作业进行交互，即当用户在自己的终端上键入命令时，系统应能及时接收并及时处理该命令，再将结果返回用户。 分时系统也是支持多道程序设计的系统，但它不同于多道批处理系统。 多道批处理是实现作业自动控制而无需人工干预的系统，而分时系统是实现人机交互的系统。 这使得分时系统具有与批处理系统不同的特征，其主要特征如下：1、同时性。同时性也称多路性，指允许多个终端用户同时使用一台计算机，即一台计算机与若干台终端相连接，终端上的这些用户可以同时或基本同时使用计算机。2、交互性。用户能够方便地与系统进行人机对话，即用户通过终端釆用人4^1对话的方式直接控制程序运行，与同程序进行交互。3、独立性。系统中多个用户可以彼此独立地进行操作，互不干扰，单个用户感觉不到别人也在使用这台计算机，好像只有自己单独使用这台计算机一样。4、及时性。用户请求能在很短时间内获得响应。分时系统釆用时间片轮转方式使一台计算机同时为多个终端服务，使用户能够对系统的及时响应感到满意。 实时操作系统虽然分时操作系统比较好地解决了人机交互问题，但是也是有它的局限性的。在一些应用场合，需要系统能对外部的信息在规定的时间（比时间片的时间还短）内作出处理（比如飞机订票系统或导弹制导系统)。因此，实时系统应运而生。 为了能在某个时间限制内完成某些紧急任务而不需时间片排队，诞生了实时操作系统。这里的时间限制可以分为两种情况：硬实时系统、软实时系统。如果某个动作必须绝对地在规定的时刻（或规定的时间范围）发生，则称为硬实时系统。例如，飞行器的飞行自动控制系统，这类系统必须提供绝对保证，让某个特定的动作在规定的时间内完成。如果能够接受偶尔违反时间规定，并且不会引起任何永久性的损害，则称为软实时系统，如飞机订票系统、银行管理系统。 在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完接收的事件。实时橾作系统的主要特点是及时性和可靠性。 网络操作系统网络操作系统把计算机网络中的各台计算机有机地结合起来，提供一种统一、经济而有效的使用各台计算机的方法，实现各个计算机之间的互相传送数据。网络操作系统的主要特点是网络中各种资源的共享以及各台计算机之间的通信。 分布式计算机系统分布式计算机系统是由多台计算机组成并满足下列条件的系统：1、系统中任意两台计算机通过通信方式交换信息；2、系统中的每一台计算机都具有同等的地位，即没有主机也没有从机；3、每台计算机上的资源为所有用户共享；4、系统中的任意若千台计算机都可以构成一个子系统，并且还能重构；5、任何工作都可以分布在几台计算机上，由它们并行工作、协同完成。 用于管理分布式计算机系统的操作系统称为分布式计算机系统。该系统的主要特点是分布性和并行性。分 布式操作系统与网络操作系统本质上的不同之处在于分布式操作系统中，若干台计算机相互协同完成同一个任务。 个人计算机操作系统个人计算机操作系统是目前使用最广泛的操作系统，能满足用户日常生活中的需求，比如文字处理、电子表格、游戏等。常见的有Windows、Linux和Macintosh等。 操作系统的发展历程如下图所示： 此外具体细分还有嵌入式操作系统、服务器操作系统、多处理器操作系统等。 运行机制计算机系统中，通常CPU执行两种不同性质的程序：一种是操作系统内核程序；另一种是用户自编程序或系统外层的应用程序。 对操作系统而言，这两种程序的作用不同，前者是后者的管理者，因此“管理程序”要执行一些特权指令，而“被管理程序”出于安全考虑不能执行这些指令。所谓特权指令，是指计算机中不允许用户直接使用的指令，如I/O指令、置中断指令，存取用于内存保护的寄存器、送程序状态字到程序状态字寄存器等指令。 操作系统在具体实现上划分了用户态（目态）和核心态（管态)，以严格区分两类程序。 在软件工程思想和结构程序设计方法的影响下诞生的现代操作系统，几乎都是层次式的结构。操作系统的各项功能分别被设置在不同的层次上。一些与硬件关联较紧密的模块，诸如时钟管理、中断处理、设备驱动等处于最底层。其次是运行频率较髙的程序，诸如进程管理、存储器管理和设备管理等。这两部分内容构成了操作系统的内核。这部分内容的指令操作工作在核心态。 内核是计算机上配置的底层软件，是计算机功能的延伸。不同系统对内核的定义稍有区别，大多数操作系统内核包括四个方面的内容。 时钟管理在计算机的各种部件中，时钟是最关键的设备，计算机取指令、分时实现很多是基于时钟的固定频率（节拍）。 时钟的第一功能是计时，操作系统需要通过时钟管理，向用户提供标准的系统时间。时钟的第二功能是中断的管理，可以实现进程的切换。诸如，在分时操作系统中，釆用时间片轮转调度的实现；在实时系统中，按截止时间控制运行的实现；在批处理系统中，通过时钟管理来衡量一个作业的运行程度等。 因此，系统管理的方方面面无不依赖于时钟。 中断机制引入中断技术的初衷是提高多道程序运行环境中CPU的利用率，而且主要是针对外部设备的。后来逐步得到发展，形成了多种类型，成为操作系统各项操作的基础。例如，键盘或鼠标信息的输入、进程的管理和调度、系统功能的调用、设备驱动、文件访问等，无不依赖于中断机制。可以说，现代操作系统是靠中断驱动的软件。 中断机制中，只有一小部分功能属于内核，负责保护和恢复中断现场的信息，转移控制权到相关的处理程序。这样可以减少中断的处理时间，提高系统的并行处理能力。 原语按层次结构设计的操作系统，底层必然是一些可被调用的公用程序片，它们各自完成一个规定的操作。其特点是：1、它们处于操作系统的最底层，是最接近硬件的部分。2、这些程序的运行具有原子性（其操作只能一气呵成，这主要是从系统的安全性和便于管理考虑的）。3、这些程序的运行时间都较短，而且调用频繁。 通常把具有这些特点的程序称为原语（Atomic Operation)。定义原语的直接方法是关闭中断，让它的所有动作不可分割地执行，执行完毕后再打开中断。 系统中的设备驱动、CPU切换、进程通信等功能中的部分操作都可以定义为原语，使它们成为内核的组成部分。 用于系统控制的数据结构和管理系统中用来登记状态信息的数据结构很多，比如作业控制块、进程控制块(PCB)、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表等。 为了实现有效的管理，系统需要一些基本的操作，常见的操作有以下三种：1、进程管理：进程状态管理、进程调度和分派、创建与撤销进程控制块等。2、存储器管理：存储器的空间分配和回收、内存信息保护程序、代码对换程序等。3、设备管理：缓冲区管理、设备分配和回收等。 核心态指令实际上包括系统调用类指令和一些针对时钟、中断和原语的操作指令。 中断和异常在操作系统中引入核心态和用户态这两种工作状态后，就需要考虑这两种状态之间如何进行状态切换。 操作系统内核工作在核心态，而用户程序工作在用户态。但系统不允许用户程序实现核心态的功能，而它们有时又必须使用这些功能。因此，需要在核心态建立一些“门”，实现从用户态进入核心态。在实际操作系统中，CPU运行上层程序时唯一能进入这些“门”的途径就是通过中断或异常。当中断或异常发生时，运行用户态的CPU会立即进入核心态，这是通过硬件实现的（例如，用一个特殊寄存器的一位来表示CPU所处的工作状态，0表示核心态，1表示用户态。若要进入核心态，只需将该位置0即可)。 中断是操作系统中非常重要的一个概念，对一个运行在计算机上的实用操作系统而言，缺少了中断机制，将是不可想象的。 中断(Interruption)，也称外中断，指来自CPU执行指令以外的事件的发生，如设备发出的I/O结束中断，表示设备输入/输出处理已经完成，希望处理机能够向设备发下一个输入 /输出请求，同时让完成输入/输出后的程序继续运行；时钟中断，表示一个固定的时间片已到，让处理机处理计时、启动定时运行的任务等。这一类中断通常是与当前程序运行无关的事件，即它们与当前处理机运行的程序无关。 异常(Exception)，也称内中断、例外或陷入(Trap)，指源自CPU执行指令内部的事件，如程序的非法操作码、地址越界、算术溢出、虚存系统的缺页以及专门的陷入指令等引起的事件。对异常的处理一般要依赖于当前程序的运行现场，而且异常不能被屏蔽，一旦出现应立即处理。 关于内中断和外中断的联系与区别如下图所示： 系统调用所谓系统调用就是用户在程序中调用操作系统所提供的一些子功能（接口），系统调用可以被看做特殊的公共子程序。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、进行I/O传输以及管理文件等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。通常，一个操作系统提供的系统调用命令有几十乃至上百条之多。 这些系统调用按功能大致可分为如下几类：1、设备管理。完成设备的请求或释放，以及设备启动等功能。2、文件管理。完成文件的读、写、创建及删除等功能。3、进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。4、进程通信。完成进程之间的消息传递或信号传递等功能。5、内存管理。完成内存的分配、回收以及获取作业占用内存区大小及始址等功能。 显然，系统调用运行在系统的核心态。通过系统调用的方式来使用系统功能，可以保证系统的稳定性和安全性，防止用户随意更改或访问系统的数据或命令。系统调用命令是由操作系统提供的一个或多个子程序模块实现的。 这样，操作系统的运行环境可以理解为：用户通过操作系统运行上层程序（如系统提供的命令解释程序或用户自编程序)，而这个上层程序的运行依赖于操作系统的底层管理程序提供服务支持，当需要管理程序服务时，系统则通过硬件中断机制进入核心态，运行管理程序；也可能是程序运行出现异常情况，被动地需要管理程序的服务，这时就通过异常处理来进入核心态。当管理程序运行结束时，用户程序需要继续运行，则通过相应的保存的程序现场退出中断处理程序或异常处理程序，返回断点处继续执行。 在操作系统这一层面上，我们关心的是系统核心态和用户态的软件实现和切换，对于硬件层面的实现原理和详细理解，可以结合“计算机组成原理”课程中有关中断的内容进行学习。 由用户态转向核心态的例子：1、用户程序要求操作系统的服务，即系统调用。2、发生一次中断。3、用户程序中产生了一个错误状态。4、用户程序中企图执行一条特权指令。 从核心态转向用户态由一条指令实现，这条指令也是特权命令：一般是中断返回指令。 值得注意的是：某个进程由用户态进入核心态，不是仅仅切换一下状态那么简单，运行过程中所使用的堆栈也可能需要由用户堆栈切换为系统堆栈，不过这个系统堆栈也是属于该进程的。 体系结构操作系统的体系结构是一个开放的问题。正如上文所述，操作系统在核心态为应用程序提供公共的服务，那么操作系统在核心态应该提供什么服务、以及怎样提供服务？有关这个问题的回答形成了两种主要的体系结构：大内核和微内核。 大内核大内核系统将操作系统的主要功能模块都作为一个紧密联系的整体运行在核心态，从而为应用提供高性能的系统服务。因为各管理模块之间共享信息，能有效利用相互之间的有效特性，所以具有无可比拟的性能优势。 但随着体系结构和应用需求的不断发展，需要操作系统提供的服务越来越多，而且接口形式越来越复杂，操作系统的设计规模也急剧增长，操作系统也面临着“软件危机”困境。为此，操作系统设计人员试图按照复杂性、时间常数、抽象级别等因素，将操作系统内核分成基本进程管理、虚存、I/O与设备管理、IPC、文件系统等几个层次，继而定义层次之间的服务结构，提高操作系统内核设计上的模块化。但是由于层次之间的交互关系错综复杂，定义清晰的层次间接口非常困难，复杂的交互关系也使得层次之间的界限极其模糊。 微内核为解决操作系统的内核代码难以维护的问题，于是提出了微内核的体系结构。它将内核中最基本的功能（如进程管理等）保留在内核，而将那些不需要在核心态执行的功能移到用户态执行，从而降低了内核的设计复杂性。而那些移出内核的操作系统代码根据分层的原则被划分成若干服务程序，它们的执行相互独立，交互则都借助于微内核进行通信。 微内核结构有效地分离了内核与服务、服务与服务，使得它们之间的接口更加清晰，维护的代价大大降低，各部分可以独立地优化和演进，从而保证了操作系统的可靠性。 微内核结构的最大问题是性能问题，因为需要频繁地在核心态和用户态之间进行切换，操作系统的执行开销偏大。因此有的操作系统将那些频繁使用的系统服务又移回内核，从而保证系统性能。但是有相当多的实验数据表明，体系结构不是引起性能下降的主要因素，体系结构带来的性能提升足以弥补切换开销带来的缺陷。为减少切换开销，也有人提出将不是所有的程序必须的系统服务改造成运行库链接到用户程序的一种解决方案，当程序需要时再装载，这样的体系结构称为库操作系统。 总结思考并行性与并发性并行性和并发性是既相似又有区别的两个概念。并行性是指两个或多个事件在同一时刻（瞬间同时）发生。并发性是指两个或多个事件在同一时间间隔（一段时间）内发生。 在多道程序环境下，并发性是指在一段时间内，宏观上有多个程序在并发的同时运行，但在单处理器系统中每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。倘若在计算机系统中有多个处理器，那每个处理器都可以执行各自的任务，也就意味着这些任务可以实现并行执行，但每个处理器仍然是在并发的执行。 特权指令与非特权指令所谓特权指令是指有特殊权限的指令，由于这类指令的权限最大，如果使用不当，将导致整个系统崩溃。比如：清内存、置时钟、分配系统资源、修改虚存的段表或页表、修改用户的访问权限等。如果所有的程序都能使用这些指令，那么可想而知眼前的正在使用的计算机每天会奔溃多少次。为了保证系统安全，这类指令只能由操作系统或其他系统软件使用，不直接提供给用户使用。因此，特权指令必须在核心态执行。实际上，CPU在核心态下可以执行指令系统的全集。形象地说，特权指令就是那些儿童不宜的东西，而非特权指令则是老少皆宜。 为了防止用户程序中使用特权指令，用户态下只能使用非特权指令，核心态下可以使用全部指令。当在用户态下使用特权指令时，将产生中断以阻止用户使用特权指令。所以把用户程序放在用户态下运行，而操作系统中必须使用特权指令的那部分程序在核心态下运行，保证了计算机系统的安全可靠。 从用户态转换为核心态的唯一途径是中断或异常。 访管指令与访管中断访管指令是一条可以在用户态下执行的指令。在用户程序中，因要求操作系统提供服务而有意识地（功能需要）使用访管指令，从而产生一个中断事件（自愿中断），将操作系统转换为核心态，称为访管中断。访管中断由访管指令产生，程序员使用访管指令向操作系统请求服务。 为什么要在程序中引入访管指令呢？这是因为用户程序只能在用户态下运行，如果用户程序想要完成在用户态下无法完成的工作，该怎么办。所以解决这个问题就要靠访管指令。 访管指令本身不是特权指令，其基本功能是让程序拥有“自愿进管”的手段，从而引起访管中断。 当处于用户态的用户程序使用访管指令时，系统根据访管指令的操作数执行访管中断处理程序，访管中断处理程序将按系统调用的操作数和参数转到相应的例行子程序。完成服务功能后，退出中断回到用户态并返回到用户程序断点继续执行。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>学习</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个有趣的面试题：Integer的缓存机制]]></title>
    <url>%2F2017%2F07%2F12-one-interesting-interview-question-integer-cache%2F</url>
    <content type="text"><![CDATA[一个有趣的面试题：Integer的缓存机制微信上看到了一个有趣的面试题，其实也是关于Integer的底层实现的一些细节。整理记录一下哈哈。 面试题这是一个简单的Java程序，真的很简单的。1234567891011121314public class IntegerCacheTest &#123; @Test public void test() &#123; Integer i1 = 100; Integer i2 = 100; System.out.println(i1 == i2); Integer i3 = 1000; Integer i4 = 1000; System.out.println(i3 == i4); &#125;&#125; 那么输出的结果是什么呢？是下面这个吗？ truetrue 结果当然不是是这个： truefalse 这是为什么呢？？ 分析使用Eclipse的Java Class Decomplier插件反编译上面的class文件。class文件可以在项目目录里找到，如果是Java Project，就在Bin里，如果是Dynamic Web Project在build里可以找到。反编译上面的class文件如下：12345678910111213import org.junit.Test;public class IntegerCacheTest &#123; @Test public void test() &#123; Integer i1 = Integer.valueOf(100); Integer i2 = Integer.valueOf(100); System.out.println(i1 == i2); Integer i3 = Integer.valueOf(1000); Integer i4 = Integer.valueOf(1000); System.out.println(i3 == i4); &#125;&#125; 可以看大Java的自动装拆箱机制，使用了Integer.valueOf的方法。 再来看看Integer.valueOf方法：12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 结合源码中的java doc文档： Returns an Integer instance representing the specified int value. If a new Integer instance is not required, this method should generally be used in preference to the constructor Integer(int), as this method is likely to yield significantly better space and time performance by caching frequently requested values. This method will always cache values in the range -128 to 127, inclusive, and may cache other values outside of this range. 看到了吗，原来是先在缓存中（-128~127，也是一个short）找找，有就返回，没有就创建一个新的Integer对象。 再来看看那个IntegerCache：123456789101112131415161718192021222324252627282930313233private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125; &#125; 仔细阅读源码可以发现，IntegerCache为Integer的静态且不可实例化的内部类。最小的值为-127，最大的值默认为127，也可以根据getSavedProperty(“java.lang.Integer.IntegerCache.high”)获得自定义的值，但是不能小于127，也不能大于Integer.MAX_VALUE - (-low) -1。 然后创建长度为(high - low) + 1的Integer数组，再由循环依次创建Integer的对象。 这个就是IntegerCache的原理了。 结论结论：面试题中第一个为100，在默认缓存的数组中，直接返回缓存中的Integer对象。而1000不在缓存范围，就每次都新建一个。 而且Integer中大多数为静态方法，final常量，且没有setInteger的方法，Integer内存放的value类型也为final,不能被修改。那么缓存中Integer对象也没有安全问题。1private final int value; 补充那么下面代码的执行结果呢？1234567Integer i5 = new Integer(100);Integer i6 = new Integer(100);System.out.println(i5 == i6);Integer i7 = new Integer("1000");Integer i8 = new Integer("1000");System.out.println(i7 == i8); 看看new Integer(int value)和new Integer(String value)是怎么实现的吧1234567public Integer(int value) &#123; this.value = value;&#125;public Integer(String s) throws NumberFormatException &#123; this.value = parseInt(s, 10);&#125; 输出： falsefalse 一个是类似普通的对象创建的过程，另一个就是使用parseInt过程。这两个过程都是新建对象的方式。 另外再看看equals和hashCode的方法：123456789101112131415@Overridepublic int hashCode() &#123; return Integer.hashCode(value);&#125;public static int hashCode(int value) &#123; return value;&#125;public boolean equals(Object obj) &#123; if (obj instanceof Integer) &#123; return value == ((Integer)obj).intValue(); &#125; return false;&#125; 而 == 比较的是对象的引用，是否引用了同一个对象（其实也是内存地址的比较）；如果是基本数据类型，则是值的比较。 而Object类的equals()方法比较是否是一个对象的方法是内存地址的比较，是可以重写的。 Integer类重写了equals()方法，只要instanceof 是Integer.class，且value相等，就认为相等。 Integer类也重写了hashCode()方法，直接返回vlaue的值。 一般来说，一个类如果涉及到比较，应该重写equals()方法，因为内存地址比较没有意义。 在集合类中还有hashCode的重写。 代码1234567891011121314151617181920212223242526272829303132public class IntegerCacheTest &#123; @Test public void test() &#123; Integer i1 = 100; Integer i2 = 100; System.out.println(i1 == i2); Integer i3 = 1000; Integer i4 = 1000; System.out.println(i3 == i4); Integer i5 = new Integer(100); Integer i6 = new Integer(100); System.out.println(i5 == i6); Integer i7 = new Integer("100"); Integer i8 = new Integer("100"); System.out.println(i7 == i8); System.out.println(i1.equals(i2)); System.out.println(i3.equals(i4)); System.out.println(i5.equals(i6)); System.out.println(i7.equals(i8)); System.out.println(i1.hashCode()); System.out.println(i3.hashCode()); System.out.println(i5.hashCode()); System.out.println(i7.hashCode()); &#125;&#125; 输出结果： truefalsefalsefalsetruetruetruetrue1001000100100 思考在平时编程中，往往有些整数会常常用到，比如-1，0，1，2等等，也会经常遇到int和Integer之间的转换，Integer是不可变对象，再加上Integer的缓存机制，可以减少对象的建立，加快运行的速度，降低内存的占用。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC设计模式和三层结构联系]]></title>
    <url>%2F2017%2F07%2F10-mvc-and-3-tier-architecture%2F</url>
    <content type="text"><![CDATA[MVC设计模式和三层结构的联系这个是最近在简书上看到的，转载了原作者文章，并且自己也做了补充。 简述在软件开发中，MVC与三层架构这两个专业词汇经常耳闻，同时总有很多人将它们混为一谈，认为三层架构就是指MVC，给它画上等号，但实际上，这是错误的认知，并不是说它们没有任何关系，而是MVC与三层架构不是简单的相等。下面将拿java web开发中的MVC（SSM框架）与三层架构进行比较，让大家理清两者之间的关系。 概念系统架构所谓系统架构是指整个应用系统程序大的结构，常见的系统架构有三层架构与MVC。前面已经说了，三层架构与MVC不是简单的相等，它们存在差别，但又联系。现在可以肯定的是，这两种系统架构的出现，都是为了降低系统模块间的耦合度。 三层架构 三层架构(3-tier architecture)通常意义上的三层架构就是将整个业务应用划分为:表现层(Presentation layer)、业务逻辑层(Business Logic Layer)、数据访问层(Data access layer)。区分层次的目的即为了“高内聚低耦合”的思想。在软件体系架构设计中，分层式结构是最常见，也是最重要的一种结构。微软推荐的分层式结构一般分为三层，从下至上分别为: 数据访问层、业务逻辑层(又或称为领域层)、表示层。 三层架构是指：视图层View、服务层Service、持久层Dao，分别完成不同的功能。 View层：用于接收用户提交请求的代码在这里编写。 Service层：系统的业务逻辑主要在这里编写。 Dao层：直接操作数据库的代码在这里编写。 为了更好的降低各层间的耦合度，在三层架构程序设计中，采用面向抽象编程。即上层对下层的调用，是通过接口实现的。而下层对上层的真正服务提供者，是下层接口的实现类。服务标准（接口）是相同的，服务提供者（实现类）可以更换。这就实现了层间的耦合。 MVCMVC是指：Model模型、View视图、Controller控件器。 View：视图，为用户提供使用界面，与用户直接进行交互。 Model：模型，承载数据，并对用户提交请求进行计算的模块。其分为两类，一类称为数据承载Bean，一类称为业务处理Bean。所谓数据承载Bean是指实体类，专门承载业务数据的，如Student、User等。而业务处理Bean则是指Service或Dao对象，专门用于处理用户提交请求的。 Controller：控制器，用于将用户请求转发给相应的Model进行处理，并处理Model的计算结果向用户提供相应响应。 MVC架构程序的工作流程是这样的： （1）用户通过View页面向服务端提出请求，可以是表单请求、超链接请求、AJAX请求等。 （2）服务端Controller控制器接收到请求后对请求进行解析，找到相应 的Model对用户请求进行处理。 （3）Model处理后，将处理结果再交给Controller。 （4）Controller在接到处理结果后，根据处理结果找到要作为向客户端发回的响应View页面。页面经渲染（数据填充）后，再发送给客户端。 关系MVC与三层架构的关系MVC与三层架构很相似，但它们并不一样。如果以三层架构为背景，那么MVC的三个部分分别对应的是什么？ 三层架构中的View层简单的说就是跟用户发生直接关系的层，MVC中的V和C就是这样的存在，所以MVC中的V和C均属于三层架构的View层。同时，我们知道MVC中的M（Model）包括了数据承载Bean和业务处理Bean，其中业务处理Bean分为Service或Dao对象，分别对应业务逻辑处理和数据库操作，相应的，它们对应的是三层架构中的Service层和Dao层。故，它们的关系如下图所示： SSM与三层架构的关系SSM即SpringMVC、Spring、Mybatis三个框架。它们在三层架构中所处的位置是不同的，即它们在三层架构中的功能各不相同，各司其职。 SpringMVC：作为View层的实现者，完成用户的请求接收功能。SpringMVC的Controller作为整个应用的控制器，完成用户请求的转发及对用户的响应。 MyBatis：作为 Dao层的实现者，完成对数据库的增、删、改、查功能。 Spring：以整个应用大管家的身份出现。整个应用中所有的Bean的生命周期行为，均由Spring来管理。即整个应用中所有对象的创建、初始化、销毁，及对象间关联关系的维护，均由Spring进行管理。 补充Model和Entity整理自知乎 相同：两者都是都是一个类，里面有些属性字段。 区别：Model是一个模型，是一个集合，里面装了各种数据，属于MVC设计模式中的M，将一个Model传递给View，在视图页面就可以使用Model里的数据呈现到页面上。而Entity是实体，就是和数据表一一对应的，一个实体一张表。 然而，官方的demo没有entity这个说法，他只有model。model既是表，也是传递给view的，换句话说，就是官方的demo内的“model”即是model又是entity。而我们在实际运用中，需要将Model分成ViewModel和Entity，甚至还要加入DTO。ViewModel是视图所需要的model，说白了就是视图上显示数据的。而entity只是数据表字段。dto是数据传输对象，业务需要哪些数据，就放哪些数据。 比如数据库中用户User表有很多字段，但是注册的时候视图页面只需要账号、密码、手机、注册时间这几个字段。那就可以建立一个RegisterDto，存放部分数据字段，提交时将这个dto的数据传递给model后再写入数据到数据库，至于传递数据可以手动复制给entity也可以使用automapper来自动映射。 再举一个具体的例子： 比如一个新闻页面需要的有：这篇新闻的各种字段(Title，CreateTime，Content等)、最新文章10条、最热文章10条。 那这个视图就需要这样一个ViewModel: 12345public class NewsView&#123; public News news&#123;get;set;&#125; //这篇新闻的全部数据 public List&lt;News&gt; lastNews&#123;get;set;&#125; //最新10篇新闻 public List&lt;News&gt; hotNews&#123;get;set;&#125; //最热10篇新闻&#125; 而新闻实体Entity（对应数据库中新闻表news）： 1234567public class News&#123; public int id&#123;get;set;&#125; public string title&#123;get;set;&#125; public string content&#123;get;set;&#125; public int clicks&#123;get;set;&#125; public Timestamp createTime&#123;get;set;&#125;&#125; 这样在控制器Controller的action中返回的Model就是NewsView，使得页面能够使用ViewModel中的数据显示这篇新闻的内容，还有最新最热的10篇文章列表。 但是最新和最热的文章，一般只需要一个包含标题和日期，没有必要知道所有的内容。而在上文的ViewModel中最新最热的文章也是直接使用了News，会包含全部的内容，所以在这种情况下需要使用DTO。 12345public class NewsDto&#123; public int id&#123;get;set;&#125; public string title&#123;get;set;&#125; public Timestamp createTime&#123;get;set;&#125;&#125; 将上面的ViewModel改成： 12345public class NewsView&#123; public News news&#123;get;set;&#125; //这篇新闻的全部数据 public List&lt;NewsDto&gt; lastNews&#123;get;set;&#125; //最新10篇新闻的简要信息 public List&lt;NewsDto&gt; hotNews&#123;get;set;&#125; //最热10篇新闻的简要信息&#125; 这样就能实现业务的灵活性。 完]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>学习</tag>
        <tag>知识点</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的异常分类和处理原则]]></title>
    <url>%2F2017%2F05%2F04-javase-exception%2F</url>
    <content type="text"><![CDATA[Java的异常分类和处理原则刚刚学习Java时，感觉异常处理很累赘，在发生异常时就随便的try-catch或者throw，也不理解为什么要设立这个复杂的处理机制。直到真正着手做一些练习或者项目时，才日益发觉异常处理的重要性，胡乱处理既给开发的程序留下隐患，也对开发调试不利。为此，整理了一下异常相关的知识，也感谢《老马说编程》的文章。 基础概念Java的异常处理机制底层比较复杂，作为开发者，详细了解底层机制并不是首要的，而是如何去正确的使用它。 Java的异常分类基本结构如下： Throwable |— Exception |— RuntimeException |— Error 这里还有一个摘自微信《老马说编程》的一张图片： Throwable是基类，定义了stackTrace，detailMessage，在1.4后添加了cause异常链支持，异常链能使得程序在发生异常处打印出Cause by，更能准确定位错误发生的位置和起因。Throwable里有常用的printStackTrace()方法，用以遍历打印出错误栈信息和异常链信息，了解一下这个方法对异常处理的流程也能有个基本认识。 Error往往是不可处理的，不可挽救的错误，比如VirtualMacheError，OutOfMemoryError，StackOverFlowError等等。程序中遇到这些错误，往往只能被虚拟机干掉。 Exception分为checked和unchecked两种，unchecked均是继承自RuntimeException，在代码种遇到unchecked异常可以不用catch或者throw，而checked必须要求程序员处理。 在Java中，方法执行return代表正常退出，throw代表异常退出。这和学习c语言时有不同，c语言中-1是程序执行异常结束，而0是正常执行结束。c语言中这种方法比较方便，但是程序中异常判断的标准和业务代码混在一起，如果业务结果确实是-1，那么还能简单的认为异常退出吗？换句话说，在程序中如果一个函数返回了-1，有时是处理的数据结果是-1，有时确实时异常，比如文件读写出错，程序终止，EXIT_CODE为-1。比如在做除法时，C语言中可以这样写：123456int div(int a, int b) &#123; if (b == 0) return -1; int res = a / b; return res;&#125; 如果调用的参数时div(2,-2)，那么执行的返回结果是-1，又如果是div(2,0)，执行的返回结果是也是-1。这就有不足的地方，此时如果将b==0做一个特殊处理，能够使得程序员知道这是异常，那个是正确的结果，会好很多，因此异常机制存在是有道理的。 在C#中，异常均为unchecked，而java中，区分了为checked和unchecked，这两者的讨论一直没有到底哪个好，哪个不好的结果。 异常栈：在Java中，一个方法的正确执行后会执行return语句，而执行期间发生错误，则立即停止执行该方法，将异常返回到调用者，调用者可以获得异常栈信息。异常栈信息包括了从异常发生点到最上层调用的轨迹，也还包括行号，在异常分析中起到关键作用。不过这是默认的程序执行的规则，如果代码中加入catch则会由细微变化。 异常处理1、unchecked异常可以不用catch或者throw，而checked必须要求程序员处理，程序员可以选择将错误在方法内catch处理掉，也可以选择直接throws出去，当然也可以在catch内做一些其它操作后再throw出去。 2、无论是checked还是unchecked，如果在方法中，对异常做catch操作，则只是try-catch代码块中的剩余代码不会执行，之外的代码正常执行；若对发生的异常不做catch处理，而是仅仅在方法上加上throws抛出，那么一旦方法出现异常，则异常点之后往下的剩余代码均不执行，相当于整个方法的代码都在try代码块中。 3、finally总能在方法（正常或异常）返回到上一层调用者前执行，除非finally有System.exit(0)，此时程序会整个终止，如果再做返回没有任何意义。在finally内，不建议对方法中的值做修改，因为发生异常时，原来的方法中值会被保护，finally中修改的值对原方法中的变量无效；也不要有return，因为finally主要是处理异常的，存在return会使得finally下面的代码无法执行，另一方面也会造成原来的异常信息丢失；也不要在finally里再抛出异常，原因和return差不多。因此，finally主要用于关闭在try中打开着的资源，无论try中的代码是否正确执行。 4、就算方法中什么异常也没有，方法上仍然是可以有throws异常的。当覆盖方法时，只能抛出在基类方法的异常说明里列出的那些异常，有些基类的方法声明抛出异常其实并没有抛出异常，这是因为可能在其子类的覆盖方法中会抛出异常。 5、构造器可以抛出任何异常而不必理会基类构造器所抛出的异常，派生类构造器异常说明必须包含基类构造器异常说明，因为构造派生类对象时会调用基类构造器。此外，派生类构造器不能捕获基类构造器抛出的异常。 6、异常不能代替正常的条件判断，比如在数组遍历时，应当认真判断数组的下标，不应该让虚拟机来抛出ArrayOutOfIndexException；反过来，真正出现异常的时候，应该抛出异常，而不是返回特殊值，比如在计算除法时，对除数为0时应该抛出异常，而不是返回-1；另外，异常不能假装当正常处理，发生异常时除非特殊情况，一定要处理，不能catch了但什么也没做，printStackTrace()不能算作正确的异常处理，但是一种处理的方式。比如在伤心时，哭不能解决问题，但是能够让别人了解到，也能够释放情绪。 7、如果发生了异常，程序最终的一定会做的操作是printStackTrace()。就算程序中没有体现，虚拟机也会调用这个方法，打印出异常信息。 8、根据实际情况选择抛出unchecked异常，checked异常，和返回特殊值，这三种处理都不是完全排他的，而是相互融合的，这也是异常处理的困难的地方。 下面看几段代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// uncheckedpublic void test8() &#123; System.out.println("111"); try &#123; System.out.println("222"); int a = 1 / 0; System.out.println("333"); &#125; catch (Exception e) &#123;// ArithmeticException - RuntimeException e.printStackTrace(); &#125; finally &#123; System.out.println("444"); &#125; System.out.println("555");&#125;// uncheckedpublic void test9() &#123; System.out.println("111"); int a = 1 / 0;// 隐含的有一个ArithmeticException - RuntimeException System.out.println("555");&#125;// checkedpublic void test10(String dataStr) &#123; DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); System.out.println("111"); try &#123; System.out.println("222"); Date date = df.parse(dataStr); System.out.println(date); System.out.println("333"); &#125; catch (Exception e) &#123;// ParseException - Exception e.printStackTrace(); &#125; finally &#123; System.out.println("444"); &#125; System.out.println("555");&#125;// checkedpublic void test11(String dataStr) throws ParseException &#123; System.out.println("111"); DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); df.parse(dataStr); System.out.println("222");&#125; 测试代码：123456789101112131415161718192021222324252627282930313233@Testpublic void test3() &#123; MyTest t = new MyTest(); t.test8();&#125;@Testpublic void test4() &#123; MyTest t = new MyTest(); t.test9();&#125;@Testpublic void test5() &#123; MyTest t = new MyTest(); t.test10("2016年11月2日 12时08分29秒");&#125;@Testpublic void test6() &#123; MyTest t = new MyTest(); t.test10("2016-11-02 12:08:29");&#125;@Testpublic void test7() &#123; MyTest t = new MyTest(); try &#123; t.test11("2016年11-02 12:08:29"); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125;&#125; 执行结果：12345678910111213141516171819202122232425262728293031323334353637383940test3:111222java.lang.ArithmeticException: / by zero at com.chain.javase.test.day08.MyTest.test8(MyTest.java:84) at com.chain.javase.test.day08.ExceptionTest.test3(ExceptionTest.java:41) ...444555test4:111但junit抛出：java.lang.ArithmeticException: / by zerotest5:111222java.text.ParseException: Unparseable date: "2016年11月2日 12时08分29秒" at java.text.DateFormat.parse(Unknown Source) at com.chain.javase.test.day08.MyTest.test10(MyTest.java:111) at com.chain.javase.test.day08.ExceptionTest.test5(ExceptionTest.java:53) ...444555test6:111222Wed Nov 02 12:08:29 CST 2016333444555test7:111java.text.ParseException: Unparseable date: "2016年11-02 12:08:29" at java.text.DateFormat.parse(Unknown Source) at com.chain.javase.test.day08.MyTest.test7(MyTest.java:127) at com.chain.javase.test.day08.ExceptionTest.test7(ExceptionTest.java:66) ... 异常典例1、(Unchecked)RuntimeException - NullPointerException：12345@Testpublic void test(Person person) &#123; String name = person.getName(); System.out.println(name);&#125; 2、(checked)Exception - ParseException12345public void test7(String dateStr) throws ParseException &#123; DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); Date date = df.parse(dateStr); System.out.println(date);&#125; 由1，2可以看出，unchecked主要是指运行过程中容易发生的异常，比如person可能为null，根本无法调用getName方法，就会报出空指针异常，这个是编译器无法避免的异常；再看ParseException，如果传入的dateStr字符串不是一个符合pattern的时间日期，而是比如”2017年05月01日 12时08分28秒”，那么就无法转换成Date类，就会抛出异常。对比这两个异常，一个checked，一个unchecked，区别主要在于checked异常一定要程序员做处理，而unchecked不强制要求处理。对于checked和unchecked后文会继续讨论。 3、一段使用异常链的代码：12345678910111213141516171819202122232425262728293031323334public void f() throws MyException &#123; throw new MyException("自定义异常");&#125;public void g() throws Exception &#123; try &#123; f(); &#125; catch (MyException e) &#123; e.printStackTrace();//第一次打印栈轨迹 throw new Exception("重新抛出的异常1", e); &#125;&#125;public void h() throws IOException &#123; try &#123; g(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace();//第二次打印栈轨迹 IOException io = new IOException("重新抛出异常2"); io.initCause(e); throw io; &#125;&#125;@Testpublic void test2() &#123; MyTest t = new MyTest(); try &#123; t.h(); &#125; catch (IOException e) &#123; e.printStackTrace();//第三次打印栈轨迹 &#125;&#125; 调用h方法后打印出的精简信息：完整信息点击此处查看1234567891011121314151617181920212223242526272829303132第一次打印：com.chain.javase.test.day08.MyException: 自定义异常 at com.chain.javase.test.day08.MyTest.f(MyTest.java:50) at com.chain.javase.test.day08.MyTest.g(MyTest.java:55) at com.chain.javase.test.day08.MyTest.h(MyTest.java:64) at com.chain.javase.test.day08.ExceptionTest.test2(ExceptionTest.java:31) ...第二次打印：java.lang.Exception: 重新抛出的异常1 at com.chain.javase.test.day08.MyTest.g(MyTest.java:58) at com.chain.javase.test.day08.MyTest.h(MyTest.java:64) at com.chain.javase.test.day08.ExceptionTest.test2(ExceptionTest.java:31) ...Caused by: com.chain.javase.test.day08.MyException: 自定义异常 at com.chain.javase.test.day08.MyTest.f(MyTest.java:50) at com.chain.javase.test.day08.MyTest.g(MyTest.java:55) ... 25 more第三次打印：java.io.IOException: 重新抛出异常2 at com.chain.javase.test.day08.MyTest.h(MyTest.java:68) at com.chain.javase.test.day08.ExceptionTest.test2(ExceptionTest.java:31) ...Caused by: java.lang.Exception: 重新抛出的异常1 at com.chain.javase.test.day08.MyTest.g(MyTest.java:58) at com.chain.javase.test.day08.MyTest.h(MyTest.java:64) ... 24 moreCaused by: com.chain.javase.test.day08.MyException: 自定义异常 at com.chain.javase.test.day08.MyTest.f(MyTest.java:50) at com.chain.javase.test.day08.MyTest.g(MyTest.java:55) ... 25 more 由上面可以清晰的看出错误的代码具体在那个位置，尤其是加入了cause之后。 异常底层看一下Throwable的常用的printStackTrace()：123456789101112131415161718192021222324private void printStackTrace(PrintStreamOrWriter s) &#123; // Guard against malicious overrides of Throwable.equals by // using a Set with identity equality semantics. Set&lt;Throwable&gt; dejaVu = Collections.newSetFromMap(new IdentityHashMap&lt;Throwable, Boolean&gt;()); dejaVu.add(this); synchronized (s.lock()) &#123; // Print our stack trace s.println(this); StackTraceElement[] trace = getOurStackTrace(); for (StackTraceElement traceElement : trace) s.println("\tat " + traceElement); // Print suppressed exceptions, if any for (Throwable se : getSuppressed()) se.printEnclosedStackTrace(s, trace, SUPPRESSED_CAPTION, "\t", dejaVu); // Print cause, if any Throwable ourCause = getCause(); if (ourCause != null) ourCause.printEnclosedStackTrace(s, trace, CAUSE_CAPTION, "", dejaVu); &#125;&#125; 由代码可见，printStackTrace()这个方法先打印出自身this的toString信息，然后再依次打印stacktrace、suppressed exceptions、cause。 健壮代码1、一个典型错误的处理方式：12345678910111213try &#123; OutputStreamWriter out = ... Connection conn = ... Statement stat = conn.createStatement(); ResultSet rs = stat.executeQuery("select uid, name from user"); while (rs.next()) out.println("ID：" + rs.getString("uid") + "，姓名：" + rs.getString("name")); conn.close(); out.close();&#125;catch(Exception e) &#123; e.printStackTrace();&#125; 上面的代码在正常情况下，功能的实现是没有问题的，但是如果遇到异常情况，那么可能就有各种各样的问题了。 2、结合上文的一些内容，这是我认为的处理方式（每个人对异常处理的见解不一样）：1234567891011121314151617181920212223242526272829303132333435363738394041//try-catch内的代码不要太多，不利于定位错误发生的地点OutputStreamWriter out = ...Connection conn = ...try &#123; Statement stat = conn.createStatement(); ResultSet rs = stat.executeQuery("select uid, name from user"); while (rs.next()) out.println("ID：" + rs.getString("uid") + "，姓名: " + rs.getString("name"));//分开catch错误，便于分别处理&#125; catch(SQLException sqlex) &#123; //当发生SQL错误时，之前打印的信息可能就无效了，需要打印告知用户数据无效。 //另外，也可以将输出放置在流中，程序执行到末尾时再调用一次性输出。 System.err.println("系统出现错误，原先打印信息无效."); //记录log logger.error("读取数据时出现SQL错误",sqlex); //分类复杂的SQL错误一般让调用者再逐一catch会降低代码可读性，可以抛出RuntimeException throw new MySQLRuntimeException("读取数据时出现SQL错误", sqlex);&#125; catch(IOException ioex) &#123; logger.error("写入数据时出现IO错误",sqlex); throw new MySQLRuntimeException("写入数据时出现IO错误", ioex);//使用finally无论程序执行正确与否，会保证关闭资源&#125; finally &#123; if (conn != null) &#123; try &#123; conn.close(); &#125; catch(SQLException sqlex2) &#123; logger.error("不能关闭数据库连接",sqlex2); //对于无法关闭的异常，调用者也无法处理，不如内部直接处理掉，或者重新包装成RuntimeException System.err(this.getClass().getName() + ".mymethod - 不能关闭数据库连接: " + sqlex2.toString()); &#125; &#125; if (out != null) &#123; try &#123; out.close(); &#125; catch(IOException ioex2) &#123; logger.error("不能关闭输出文件",ioex2); System.err(this.getClass().getName() + ".mymethod - 不能关闭输出文件" + ioex2.toString()); &#125; &#125;&#125; 异常讨论一种普遍的说法是： RuntimeException(unchecked exception)表示编程的逻辑错误，编程时应该检查以避免这些错误，比如说像空指针异常，如果真的出现了这些异常，程序退出也是正常的。程序员应该检查程序代码的bug，比如完善边界检查，长度判断，非空判断等等，而不是想办法处理这种异常。 checked exception表示程序代码本身没问题，但由于I/O、网络、数据库等其他不可预测的外在错误导致的异常，这类异常不是由于代码bug引起的，而是外部因素导致的，那么本方法的调用者应该想办法去处理异常。 由上面的说法，换句话说，RuntimeException其实是提醒程序员，代码写的不过健壮，要完善代码，而其他的异常就不是程序员能够控制的异常了，比如数据库连接的释放，IO的操作，好的健壮代码不应该抛出RuntimeException，但是可以抛出checked Exception。 另一种被认同的观点是： Java中的这个区分是没有太大意义的，可以统一使用RuntimeException即unchecked exception来代替。 这个观点的基本理由是，无论是checked还是unchecked异常，无论是否出现在throws声明中，我们都应该在合适的地方以适当的方式进行处理，而不是只为了满足编译器的要求，盲目处理异常，既然都要进行处理异常，checked exception的强制声明和处理就显得啰嗦，尤其是在调用层次比较深的情况下。 个人观点： 对于有些checked exception，比如再创建String时，那个charset参数，如果传入肯定能支持的编码，那么抛出的UnsupportedEncodingException的checked exception就没有太大的再上抛给调用者的意义，所以可以包装成RuntimeException，类似的还有NoSuch异常；还有在编写工具类时，遇到关闭流的操作时的IOExcption等无法再得到有效解决的问题，也可以进行包装；再比如对于开发者而言，复杂的SQL异常的有很多种类的Exception，也可以包装成一个统一的Exception做处理，减少累赘，当然使用复杂的种类繁多的Exception也是可以的。 其实观点本身并不太重要，更重要的是一致性，一个项目中，应该对如何使用异常达成一致，按照约定使用即可。Java中已有的异常和类库也已经在哪里，我们还是要按照他们的要求进行使用。 参考资料1、Java中的常用异常处理方法2、Java异常机制3、Java异常链4、Java的异常5、Java异常类学习 文后感想异常处理细细学来，和黑客技术一样，感觉就像一门艺术。 异常处理的目的是在于让程序出现错误，不至于一律都选择退出，也不至于带“病”运行，而是能够让程序遇到故障能尽可能的恢复正常运行。 完善自己的代码编写才是最重要的，尽量较少不必要的异常的发生。 最简单细微的东西往往容易被忽略，最微小的细节可能会酿成不可挽回的损失。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法的时间和空间复杂度]]></title>
    <url>%2F2017%2F02%2F19-algorithm-time-complex%2F</url>
    <content type="text"><![CDATA[算法的时间和空间复杂度算法分析是很重要的过程，一个算法的好坏由很多因素可以判断。算法也是应用的精髓，比如导航中的算法等等。 算法分析为什么要进行算法分析预测算法所需的资源： 计算时间（CPU 消耗）内存空间（RAM 消耗）通信时间（带宽消耗） 预测算法的运行时间： 在给定输入规模时，所执行的基本操作数量。或者称为算法复杂度（Algorithm Complexity）。 如何衡量算法复杂度内存（Memory）时间（Time）指令的数量（Number of Steps）特定操作的数量磁盘访问数量网络包数量 渐进复杂度（Asymptotic Complexity） 算法的运行时间与什么相关取决于输入的数据。（例如：如果数据已经是排好序的，时间消耗可能会减少。）取决于输入数据的规模。（例如：6 和 6 * 109）取决于运行时间的上限。（因为运行时间的上限是对使用者的承诺。） 算法分析的种类最坏情况（Worst Case）：任意输入规模的最大运行时间。（Usually）平均情况（Average Case）：任意输入规模的期待运行时间。（Sometimes）最佳情况（Best Case）：通常最佳情况不会出现。（Bogus） 例如，在一个长度为 n 的列表中顺序搜索指定的值，则最坏情况：n 次比较平均情况：n/2 次比较最佳情况：1 次比较 而实际中，我们一般仅考量算法在最坏情况下的运行情况，也就是对于规模为 n 的任何输入，算法的最长运行时间。这样做的理由是：一个算法的最坏情况运行时间是在任何输入下运行时间的一个上界（Upper Bound）。对于某些算法，最坏情况出现的较为频繁。大体上看，平均情况通常与最坏情况一样差。 算法分析要保持大局观（Big Idea），其基本思路：忽略掉那些依赖于机器的常量。关注运行时间的增长趋势。 比如：T(n) = 73n3 + 29n3 + 8888 的趋势就相当于 T(n) = Θ(n3)。 渐近记号（Asymptotic Notation）通常有 O、 Θ 和 Ω 记号法。 Θ 记号渐进地给出了一个函数的上界和下界，当只有渐近上界时使用 O 记号，当只有渐近下界时使用 Ω 记号。 尽管技术上 Θ 记号较为准确，但通常仍然使用 O 记号表示。 使用 O 记号法（Big O Notation）表示最坏运行情况的上界。 例如：线性复杂度 O(n) 表示每个元素都要被处理一次。平方复杂度 O(n2) 表示每个元素都要被处理 n 次。 例如：T(n) = O(n3) 等同于 T(n) ∈ O(n3)T(n) = Θ(n3) 等同于 T(n) ∈ Θ(n3).相当于:T(n) 的渐近增长不快于 n3。T(n) 的渐近增长与 n3 一样快。 注1：logab = y 其实就是 ay = b。所以，log24 = 2，因为 22 = 4。同样 log28 = 3，因为 23 = 8。我们说，log2n 的增长速度要慢于 n，因为当 n = 8 时，log2n = 3。注2：通常将以 10 为底的对数叫做常用对数。为了简便，N 的常用对数 log10 N 简写做 lg N，例如 log10 5 记做 lg 5。注3：通常将以无理数 e 为底的对数叫做自然对数。为了方便，N 的自然对数 loge N 简写做 ln N，例如 loge 3 记做 ln 3。注4：在算法导论中，采用记号 lg n = log2 n ，也就是以 2 为底的对数。改变一个对数的底只是把对数的值改变了一个常数倍，所以当不在意这些常数因子时，我们将经常采用 “lg n”记号，就像使用 O 记号一样。计算机工作者常常认为对数的底取 2 最自然，因为很多算法和数据结构都涉及到对问题进行二分。 计算代码块的渐进运行时间的方法有如下步骤：确定决定算法运行时间的组成步骤。找到执行该步骤的代码，标记为 1。查看标记为 1 的代码的下一行代码。如果下一行代码是一个循环，则将标记 1 修改为 1 倍于循环的次数 1 x n。如果包含多个嵌套的循环，则将继续计算倍数，例如 1 x n x m。找到标记到的最大的值，就是运行时间的最大值，即算法复杂度描述的上界。 下面是一些常见的算法复杂度的直观函数图： 一些常见的排序算法的时间和空间复杂度，以及算法是否稳定： 时间复杂度概念时间复杂度是总运算次数表达式中受n的变化影响最大的那一项(不含系数)。 比如：一般总运算次数表达式类似于这样： 1a*2n+b*n3+c*n2+d*n*lg(n)+e*n+f 当a!=0时，时间复杂度就是 O(2n);当a=0,b&lt;&gt;0，时间复杂度就是 O(n3);当a,b=0,c&lt;&gt;0，时间复杂度就是 O(n2);依此类推。 例子: 1234567891011121314151617181920212223(1) // 循环了n*n次，当然是O(n2) for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) s++;(2) // 循环了(n+n-1+n-2+...+1)≈(n2)/2，因为时间复杂度是不考虑系数的，所以也是O(n2) for(i=1;i&lt;=n;i++) for(j=i;j&lt;=n;j++) s++;(3) // 循环了(1+2+3+...+n)≈(n^2)/2,当然也是O(n2) for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++) s++;(4) // 循环了n-1≈n次，所以是O(n) i=1;k=0; while(i&lt;=n-1) &#123; k+=10*i; i++; &#125;(5) // 循环了(12+22+32+...+n2)=n(n+1)(2n+1)/6(这个公式要记住哦)≈(n3)/3，不考虑系数，自然是O(n3) for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++) for(k=1;k&lt;=j;k++) x=x+1; 另外，在时间复杂度中，log2n与lg(n)(同lg10(n))是等价的，因为对数换底公式：logab=logcb/logca所以，log2n=log210 * lg(n),忽略掉系数，二者当然是等价的。 计算1.一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。 一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。 2.一般情况下，算法的基本操作重复执行的次数是模块n的某一个函数f（n），因此，算法的时间复杂度记做：T（n）=O（f（n））。随着模块n的增大，算法执行的时间的增长率和f（n）的增长率成正比，所以f（n）越小，算法的时间复杂度越低，算法的效率越高。 在计算时间复杂度的时候，先找出算法的基本操作，然后根据相应的各语句确定它的执行次数，再找出T（n）的同数量级（它的同数量级有以下：1，Log2n ，n ，nLog2n ，n的平方，n的三次方，2的n次方，n!），找出后，f（n）=该数量级，若T(n)/f(n)求极限可得到一常数c，则时间复杂度T（n）=O（f（n））。 3.常见的时间复杂度按数量级递增排列，常见的时间复杂度有： 常数阶O(1), 对数阶O(log2n), 线性阶O(n), 线性对数阶O(nlog2n), 平方阶O(n2)，立方阶O(n3)，…，k次方阶O(nk), 指数阶O(2n) 。 其中，1）O(n)，O(n2)， 立方阶O(n3),…， k次方阶O(nk) 为多项式阶时间复杂度，分别称为一阶时间复杂度，二阶时间复杂度，依此类推。2）O(2n)，指数阶时间复杂度，该种不实用3）对数阶O(log2n)，线性对数阶O(nlog2n)，除了常数阶以外，该种效率最高。 例：算法： 12345678910for(i=1;i&lt;=n;++i) &#123; for(j=1;j&lt;=n;++j) &#123; // 该步骤属于基本操作 执行次数：n2 c[i][j]=0; for(k=1;k&lt;=n;++k) &#123; //该步骤属于基本操作 执行次数：n3 c[i][j]+=a[i][k]*b[k][j]; &#125; &#125;&#125; 则有 T（n）= n2+n3，根据上面括号里的同数量级，我们可以确定 n3为T（n）的同数量级则有f（n）= n3，然后根据T（n）/f（n）求极限可得到常数c则该算法的 时间复杂度：T（n）=O（n3) 定义如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)，它是n的某一函数 T(n)称为这一算法的“时间复杂性”。 当输入量n逐渐加大时，时间复杂性的极限情形称为算法的“渐近时间复杂性”。 我们常用大O表示法表示时间复杂性，注意它是某一个算法的时间复杂性。大O表示只是说有上界，由定义如果f(n)=O(n)，那显然成立f(n)=O(n^2)，它给你一个上界，但并不是上确界，但人们在表示的时候一般都习惯表示前者。 此外，一个问题本身也有它的复杂性，如果某个算法的复杂性到达了这个问题复杂性的下界，那就称这样的算法是最佳算法。 “大O记法”：在这种描述中使用的基本参数是 n，即问题实例的规模，把复杂性或运行时间表达为n的函数。这里的“O”表示量级 (order)，比如说“二分检索是 O(logn)的”,也就是说它需要“通过logn量级的步骤去检索一个规模为n的数组”。 记法 O(f(n)) 表示当n增大时，运行时间至多将以正比于 f(n)的速度增长。 这种渐进估计对算法的理论分析和大致比较是非常有价值的，但在实践中细节也可能造成差异。 例如，一个低附加代价的O(n2)算法在n较小的情况下可能比一个高附加代价的 O(nlogn)算法运行得更快。当然，随着n足够大以后，具有较慢上升函数的算法必然工作得更快。 O(1) 交换i和j的内容 1234temp=i;i=j;j=temp;解：以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。 如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。 O(n2) 123456sum=0； （1次）for(i=1;i&lt;=n;i++) （n次）for(j=1;j&lt;=n;j++) （n2次）sum++； （n2次）解：T(n)=2n^2+n+1=O(n^2) 该程序的时间复杂度T(n)=O(n2)。 12345678910for (i=1;i&lt;n;i++) &#123; // 频度是n-1 y=y+1; for (j=0;j&lt;=(2*n);j++) &#123; //频度是(n-1)*(2n+1)=2n2-n-1 x++; &#125;&#125;解：f(n)=2n2-n-1+(n-1)=2n2-2 该程序的时间复杂度T(n)=O(n2)。 O(n) 12345678910// 频度:2a=0;b=1;// 频度:nfor (i=1;i&lt;=n;i++) &#123; s=a+b; // 频度:n-1 b=a; // 频度:n-1 a=s; // 频度:n-1&#125;解：T(n)=2+n+3(n-1)=4n-1=O(n)。该程序的时间复杂度T(n)=O(n)。 O(log2n) 123456i=1; // 频度是1while (i&lt;=n) &#123; i=i*2; // 频度是f(n)&#125;解：2^f(n)&lt;=n 即 f(n)&lt;=log2n。该程序的时间复杂度T(n)，取最大值f(n)=log2n，T(n)=O(log2n)。 O(n3) 1234567891011121314for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;i;j++) &#123; for(k=0;k&lt;j;k++) &#123; x=x+2; &#125; &#125;&#125;解：当 i=m,j=k 时, 内层循环的次数为 k。当 i=m 时, j可以取 0,1,...,m-1。所以这里最内循环共进行了 0+1+...+m-1=(m-1)m/2次。进而,i从0取到n, 则循环共进行了: 0+(1-1)*1/2+...+(n-1)n/2=n(n+1)(n-1)/6。进而得出时间复杂度为 O(n3)。 我们还应该区分算法的最坏情况的行为和期望行为。 如快速排序的最坏情况运行时间是 O(n2)，但期望时间是 O(nlogn)。 通过每次都仔细地选择基准值，我们有可能把平方情况 (即O(n2)情况)的概率减小到几乎等于 0。 在实际中，精心实现的快速排序一般都能以 (O(nlogn)时间运行。 下面是一些常用的记法（技巧）： 访问数组中的元素是常数时间操作，或说O(1)操作。 一个算法如果能在每个步骤去掉一半数据元素，如二分检索，通常它就取 O(logn)时间。 用strcmp比较两个具有n个字符的串需要O(n)时间。 常规的矩阵乘算法是O(n3)，因为算出每个元素都需要将n对元素相乘并加到一起，所有元素的个数是n2。 指数时间算法通常来源于需要求出所有可能结果。例如，n个元素的集合共有2n个子集,所以要求出所有子集的算法将是O(2n)的。指数算法一般说来是太复杂了，除非n的值非常小，因为，在这个问题中增加一个元素就导致运行时间加倍。 不幸的是，确实有许多问题 (如著名的“巡回售货员问题” )，到目前为止找到的算法都是指数的。如果我们真的遇到这种情况，通常应该用寻找近似最佳结果的算法替代之。 空间复杂度空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。 一个算法在计算机存储器上所占用的存储空间，包括程序代码所占用的空间，输入数据所占用的空间和辅助变量所占用的空间这三个方面。 算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。 存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。算法在运行过程中临时占用的存储空间随算法的不同而异，有的算法只需要占用少量的临时工作单元，而且不随问题规模的大小而改变，我们称这种算法是“就地”进行的，是节省存储的算法，如这些介绍过的几个算法都是如此； 有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如将在第九章介绍的快速排序和归并排序算法就属于这种情况。 分析一个算法所占用的存储空间要从各方面综合考虑。 如对于递归算法来说，一般都比较简短，算法本身所占用的存储空间较少，但运行时需要一个附加堆栈，从而占用较多的临时工作单元；若写成非递归算法，一般可能比较长，算法本身占用的存储空间较多，但运行时将可能需要较少的存储单元。 一个算法的空间复杂度只考虑在运行过程中为局部变量分配的存储空间的大小，它包括为参数表中形参变量分配的存储空间和为在函数体中定义的局部变量分配的存储空间两个部分。 若一个算法为递归算法，其空间复杂度为递归所使用的堆栈空间的大小，它等于一次调用所分配的临时存储空间的大小乘以被调用的次数(即为递归调用的次数加1，这个1表不开始进行的一次非递归调用)。 算法的空间复杂度一般也以数量级的形式给出。 如当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为0(log2n)；当一个算法的空间复杂度与n成线性比例关系时，可表示为0(n)。 若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。 对于一个算法，其时间复杂度和空间复杂度往往是相互影响的。 当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，当追求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。 另外，算法的所有性能之间都存在着或多或少的相互影响。 因此，当设计一个算法(特别是大型算法)时，要综合考虑算法的各项性能，算法的使用频率，算法处理的数据量的大小，算法描述语言的特性，算法运行的机器系统环境等各方面因素，才能够设计出比较好的算法。 空间复杂度是程序运行所以需要的额外消耗存储空间,也用O()来表示。 比如插入排序的时间复杂度是O(n2),空间复杂度是O(1)。而一般的递归算法就要有O(n)的空间复杂度了,因为每次递归都要存储返回信息。 一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量。 算法执行时间的度量不是采用算法执行的绝对时间来计算的，因为一个算法在不同的机器上执行所花的时间不一样，在不同时刻也会由于计算机资源占用情况的不同，使得算法在同一台计算机上执行的时间也不一样，所以对于算法的时间复杂性，采用算法执行过程中其基本操作的执行次数，称为计算量来度量。 算法中基本操作的执行次数一般是与问题规模有关的，对于结点个数为n的数据处理问题，用T(n)表示算法基本操作的执行次数。 在评价算法的时间复杂性时，不考虑两算法执行次数之间的细小区别，而只关心算法的本质差别: 为此，引入一个所谓的O()记号，则T1(n)=2n=O(n),T2(n)=n+1=O(n)。 一个函数f(n)是O(g(n))的，则一定存在正常数c和m，使对所有的n&gt;m，都满足f(n)&lt;c*g(n)。 示例代码示例代码（1）： 123456decimal Factorial(int n) &#123; if (n == 0) return 1; else return n * Factorial(n - 1);&#125; 阶乘（factorial），给定规模 n，算法基本步骤执行的数量为 n，所以算法复杂度为 O(n)。 示例代码（2）： 123456789int FindMaxElement(int[] array) &#123; int max = array[0]; for (int i = 0; i &lt; array.Length; i++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; &#125; return max;&#125; 这里，n 为数组 array 的大小，则最坏情况下需要比较 n 次以得到最大值，所以算法复杂度为 O(n)。 示例代码（3）： 12345678long FindInversions(int[] array) &#123; long inversions = 0; for (int i = 0; i &lt; array.Length; i++) for (int j = i + 1; j &lt; array.Length; j++) if (array[i] &gt; array[j]) inversions++; return inversions;&#125; 这里，n 为数组 array 的大小，则基本步骤的执行数量约为 n*(n-1)/2，所以算法复杂度为 O(n2)。 示例代码（4）： 1234567long SumMN(int n, int m) &#123; long sum = 0; for (int x = 0; x &lt; n; x++) for (int y = 0; y &lt; m; y++) sum += x * y; return sum;&#125; 给定规模 n 和 m，则基本步骤的执行数量为 n*m，所以算法复杂度为 O(n2)。 示例代码（5）： 12345678decimal Sum3(int n) &#123; decimal sum = 0; for (int a = 0; a &lt; n; a++) for (int b = 0; b &lt; n; b++) for (int c = 0; c &lt; n; c++) sum += a * b * c; return sum;&#125; 这里，给定规模 n，则基本步骤的执行数量约为 nnn ，所以算法复杂度为 O(n3)。 示例代码（6）： 123456decimal Calculation(int n) &#123; decimal result = 0; for (int i = 0; i &lt; (1 &lt;&lt; n); i++) result += i; return result;&#125; 这里，给定规模 n，则基本步骤的执行数量为 2n，所以算法复杂度为 O(2n)。 示例代码（7）： 斐波那契数列： Fib(0) = 0Fib(1) = 1Fib(n) = Fib(n-1) + Fib(n-2)F() = 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 … 123456int Fibonacci(int n) &#123; if (n &lt;= 1) return n; else return Fibonacci(n - 1) + Fibonacci(n - 2);&#125; 这里，给定规模 n，计算 Fib(n) 所需的时间为计算 Fib(n-1) 的时间和计算 Fib(n-2) 的时间的和。 T(n&lt;=1) = O(1) T(n) = T(n-1) + T(n-2) + O(1) 123456 fib(5) / \ fib(4) fib(3) / \ / \ fib(3) fib(2) fib(2) fib(1)/ \ / \ / \ 通过使用递归树的结构描述可知算法复杂度为 O(2^n)。 示例代码（8）： 123456789101112131415int Fibonacci(int n) &#123; if (n &lt;= 1) return n; else &#123; int[] f = new int[n + 1]; f[0] = 0; f[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; f[i] = f[i - 1] + f[i - 2]; &#125; return f[n]; &#125;&#125; 同样是斐波那契数列，我们使用数组 f 来存储计算结果，这样算法复杂度优化为 O(n)。 示例代码（9）： 123456789101112131415161718int Fibonacci(int n) &#123; if (n &lt;= 1) return n; else &#123; int iter1 = 0; int iter2 = 1; int f = 0; for (int i = 2; i &lt;= n; i++) &#123; f = iter1 + iter2; iter1 = iter2; iter2 = f; &#125; return f; &#125;&#125; 同样是斐波那契数列，由于实际只有前两个计算结果有用，我们可以使用中间变量来存储，这样就不用创建数组以节省空间。同样算法复杂度优化为 O(n)。 示例代码（10）： 通过使用矩阵乘方的算法来优化斐波那契数列算法。 12345678910111213141516171819202122232425262728293031323334static int Fibonacci(int n) &#123; if (n &lt;= 1) return n; int[,] f = &#123; &#123; 1, 1 &#125;, &#123; 1, 0 &#125; &#125;; Power(f, n - 1); return f[0, 0];&#125;static void Power(int[,] f, int n) &#123; if (n &lt;= 1) return; int[,] m = &#123; &#123; 1, 1 &#125;, &#123; 1, 0 &#125; &#125;; Power(f, n / 2); Multiply(f, f); if (n % 2 != 0) Multiply(f, m);&#125;static void Multiply(int[,] f, int[,] m) &#123; int x = f[0, 0] * m[0, 0] + f[0, 1] * m[1, 0]; int y = f[0, 0] * m[0, 1] + f[0, 1] * m[1, 1]; int z = f[1, 0] * m[0, 0] + f[1, 1] * m[1, 0]; int w = f[1, 0] * m[0, 1] + f[1, 1] * m[1, 1]; f[0, 0] = x; f[0, 1] = y; f[1, 0] = z; f[1, 1] = w;&#125; 优化之后算法复杂度为O(log2n)。 示例代码（11）： 在 C# 中使用公式法，得到更简洁的代码如下。 123456static double Fibonacci(int n) &#123; double sqrt5 = Math.Sqrt(5); double phi = (1 + sqrt5) / 2.0; double fn = (Math.Pow(phi, n) - Math.Pow(1 - phi, n)) / sqrt5; return fn;&#125; 示例代码（12）： 12345678910111213private static void InsertionSortInPlace(int[] unsorted) &#123; for (int i = 1; i &lt; unsorted.Length; i++) &#123; if (unsorted[i - 1] &gt; unsorted[i]) &#123; int key = unsorted[i]; int j = i; while (j &gt; 0 &amp;&amp; unsorted[j - 1] &gt; key) &#123; unsorted[j] = unsorted[j - 1]; j--; &#125; unsorted[j] = key; &#125; &#125;&#125; 插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的有序数据。算法适用于少量数据的排序，时间复杂度为 O(n2)。 推导案例摘自软考书。 已知递推关系式T(n)=2T(n/2)+n，求时间复杂度。 这个递推关系式其实是在给n个元素进行快速排序时最好情况（每次分割都恰好将记录分为两个长度相等的子序列）下的时间递推关系式，其中T(n/2)是一个子表需要的处理时间，n 为当次分割需要的时间。 注意，这里实际上是用比较次数（数组的比较）来度量表示所需时间。 可以对此表达式进行变形得：T(n)/n-T(n/2)/(n/2)=1 用n/2代替上式中的n可得：T(n/2)/(n/2)-T(n/4)/(n/4)=1 继续用n/2代替上式中的n可得：T(n/4)/(n/4)-T(n/8)/(n/8)=1…T(2)/2-T(1)/1=1 算法共需要进行[lbn]+1次分割(n个元素的序列的对半分割树的高度跟具有n个结的完全二叉树高度相等，软设级别的只需知道即可，不必深究)。 将上述[lbn]+1个式子相加，删除相互抵消的部分得：T(n)/n-T(1)/1=[lbn]+1 而T(1)=1，那么上式可转化为：T(n)=n[lbn]+2n 而在求时间复杂度时关注“大头”，注意到O(n)&lt;O(nlbn)而且对数的底可省略或为任意常数值，那么： T(n)=O(nlogn)=O(nlgn) 数学上，一般将底为10的对数简略为lg，底为2的对数简略为lb，底为e的对数简略为ln。 参考博文123]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>转载</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的进制转换和ScaleConvertUtils]]></title>
    <url>%2F2016%2F12%2F28-number-scale-convert-utils%2F</url>
    <content type="text"><![CDATA[Java中的进制转换和ScaleConvertUtils复习Java基础时，学到了进制转换部分，就想着自己搞了一个进制转换的工具类，当然工具类还有不完善的地方。 工具简介进制转换在JavaAPI中已经封装，但是自己实现还是有很多要学习的地方，涉及到无符号数的表示、负数的转换、浮点数在计算机中的表示、位操作等。本工具也支持多进制之间的转换，进制与字符串之间的互转。 下面贴出简单测试代码：1234567891011121314@Testpublic void test() throws Exception &#123; int a = -10; String s1 = ScaleConvertUtils.toBinaryString(a); System.out.println(s1); int a1 = ScaleConvertUtils.parseBinaryString(s1); System.out.println(a1); float b = -12.34f; String s2 = ScaleConvertUtils.toBinaryString(b); System.out.println(s2); float b1 = ScaleConvertUtils.parseBinaryStringToFloat(s2); System.out.println(b1);&#125; 输出： 11111111111111111111111111110110-1011000001010001010111000010100100-12.34 下载地址：点击这里下载jar包，源码在这里。 完]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过桥问题和倒水问题]]></title>
    <url>%2F2016%2F12%2F19-cross-bridge-and-water%2F</url>
    <content type="text"><![CDATA[过桥问题和倒水问题过桥问题和倒水问题都是笔试面试中的热门智力题，不但微软、GOOGLE、百度、腾讯等公司采用，甚至在IQ测试与公务员考试中都能见到。 在此整理下具体的做法。 过桥问题 在漆黑的夜里，四位旅行者来到了一座狭窄而且没有护栏的桥边。如果不借助手电筒的话，大家是无论如何也不敢过桥去的。不幸的是，四个人一共只带了一只手电筒，而桥窄得只够让两个人同时通过。如果各自单独过桥的话，四人所需要的时间分别是1，2，5，8分钟；而如果两人同时过桥，所需要的时间就是走得比较慢的那个人单独行动时所需的时间。问题是，你如何设计一个方案，让用的时间最少。 这个题目被微软、GOOGLE、百度、华硕、建设银行等很多公司用作笔试题或面试题。当然也有用在IQ测试中。 解答其实也容易，关键就是在于能者多劳——用时短的人必须要多跑几趟以便传递手电筒。 设这四个人叫做A，B，C，D，他们所需要的时间分别是1，2，5，8分钟。 更加细化的解决方案是：1、要么是最快者将最慢的送过桥，2、要么是最快的2个将最慢的2个送过桥。 即将过桥的人按其过桥的时间从小到大排列，设为A，B，…… Y，Z。其中A和B是最快的二个，Y和Z是最慢的二个。 那么就有二种方案： 方案一 最快者将最慢者送过桥 第一步：A和Z过桥，花费Z分钟。 第二步：如果桥那边还有人，则A回来，花费A分钟，没有人则不用回来。 这两步后总人数就减小1个，花费时间为A + A + Z分钟。 方案二 最快的2个将最慢的2个送过桥 第一步：A和B过桥，花费B分钟。 第二步：A回来，花费A分钟。 第三步：Y和Z过桥，花费Z分钟。 第四步：B回来，花费B分钟。 这四步后总人数同样减小2个，花费时间为A + B + B + Z分钟。 之后比较这两个方法的时间，找到时间消耗最小就行。 接下来就是代码时间： 假设一次过桥的人数最多是2人。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138package com.chain.blog.test.day09;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.Scanner;/** * 过桥问题：遵循“能者多劳”的准则 * * @author Chain * */public class CrossBridgeTest &#123; public static void main(String[] args) &#123; test1(); &#125; // 两种方案分别最短耗时 private static int cost1 = 0; private static int cost2 = 0; // 两种方案各自的具体实施方案 private static List&lt;String&gt; list1 = new ArrayList&lt;&gt;(); private static List&lt;String&gt; list2 = new ArrayList&lt;&gt;(); private static void test1() &#123; try (Scanner in = new Scanner(System.in)) &#123; int n = in.nextInt(); List&lt;Integer&gt; speed1 = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; int s = in.nextInt(); speed1.add(s); &#125; Collections.sort(speed1); List&lt;Integer&gt; speed2 = new ArrayList&lt;&gt;(speed1); process1(speed1, 0); process2(speed2, 0); print(); &#125; &#125; private static void print() &#123; System.out.println("方案一耗时: " + cost1); System.out.println("方案一具体实施: "); for (String s : list1) &#123; System.out.println(s); &#125; System.out.println(); System.out.println("方案二耗时: " + cost2); System.out.println("方案二具体实施: "); for (String s : list2) &#123; System.out.println(s); &#125; &#125; // 方案二 private static void process2(List&lt;Integer&gt; t, int times) &#123; int size = t.size(); // 如果人数少于4个人，使用方案一 if (size &lt; 4) &#123; cost2 = process1(t, times, list2, cost2); return; &#125; list2.add("第" + (times + 1) + "次循环："); int fast1 = 0; int fastSpeed1 = t.get(fast1); int fast2 = fast1 + 1; int fastSpeed2 = t.get(fast2); int slow1 = size - 1; int slowSpeed1 = t.get(slow1); int slow2 = slow1 - 1; int slowSpeed2 = t.get(slow2); list2.add("第" + (fast1 + 1) + "个人\t和\t第" + (fast2 + 1) + "个人\t过河"); cost2 += fastSpeed2; list2.add("第" + (fast1 + 1) + "个人\t回头"); cost2 += fastSpeed1; list2.add("第" + (slow1 + 1) + "个人\t和\t第" + (slow2 + 1) + "个人\t过河"); cost2 += slowSpeed1; list2.add("第" + (fast2 + 1) + "个人\t回头"); cost2 += fastSpeed2; t.remove(slow1); t.remove(slow2); process2(t, times + 1); &#125; private static void process1(List&lt;Integer&gt; t, int times) &#123; cost1 = process1(t, times, list1, cost1); &#125; // 方案一 private static int process1(List&lt;Integer&gt; t, int times, List&lt;String&gt; list, int cost) &#123; list.add("第" + (times + 1) + "次循环："); int size = t.size(); // 列表为空时直接返回 if (size &lt; 1) &#123; list.add("过河人数为0"); return cost; &#125; int fast = 0; int fastSpeed = t.get(fast); // 如果只有一个人，直接过河就行 if (size &lt; 2) &#123; list.add("第" + (fast + 1) + "个人\t单独\t过河"); cost += fastSpeed; return cost; &#125; // 最快者将最慢者送过桥 int slow = size - 1; int slowSpeed = t.get(slow); list.add("第" + (fast + 1) + "个人\t和\t第" + (slow + 1) + "个人\t过河"); cost += slowSpeed; t.remove(slow); size = t.size(); // 如果桥那边还有人 if (size &gt; 1) &#123; list.add("第" + (fast + 1) + "个人\t回头"); cost += fastSpeed; cost = process1(t, times + 1, list, cost); &#125; return cost; &#125;&#125; 测试结果： 1234567891011121314151617181920212241 2 5 10方案一耗时: 19方案一具体实施: 第1次循环：第1个人 和 第4个人 过河第1个人 回头第2次循环：第1个人 和 第3个人 过河第1个人 回头第3次循环：第1个人 和 第2个人 过河方案二耗时: 17方案二具体实施: 第1次循环：第1个人 和 第2个人 过河第1个人 回头第4个人 和 第3个人 过河第2个人 回头第2次循环：第1个人 和 第2个人 过河 倒水问题这个题目的版本非常多，有微软版的，腾讯版的，新浪版的等等。 给你一个容量为5升的桶和一个容量为3升的桶，水不限使用，要求精确得到4升水。 解法肯定有很多，可以用宽度优先搜索（BFS），也可以用穷举法。 穷举法实现比较方便，其基本思想是用：用小桶容量的倍数对大桶的容量进行取余。 比如3升的桶和5升的桶得到4升水可以这样做： 3 % 5 = 3 6 % 5 = 1 9 % 5 = 4 成功得到4升水。（PS：上面的过程用如何用文字描述了？） 同样，用7升的桶和11升的桶得到2升水可以这样做： 7 % 11 = 7 14 % 11 = 3 21 % 11 = 10 28 % 11 = 6 35 % 11 = 2 成功得到2升水。 但是也需要注意下的就是可能存在无解的情况。 比如用2升的桶和4升的桶得到3升水。因为2和4的最大公约数是2即GCD(2，4)=2，而2无法整除3。 倒水问题也也容易推广到多个桶的情况，分析方法和上文差不多，这里就不再赘述了。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结合UML图理解类之间的关系(Java)]]></title>
    <url>%2F2016%2F11%2F18-understant-classes-relationship-with-uml%2F</url>
    <content type="text"><![CDATA[结合UML图理解类之间的关系(Java)Java是一门面对对象的语言，用来抽象的描述不同对象之间的关系。对象之间的关系主要有泛化、实现、依赖、关联、聚合、组合。刚刚学习Java时，觉得很陌生，现在查阅一些资料后，整理出这篇博客。 基本概念泛化(generalization)概念：指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力。继承是类与类或者接口与接口之间最常见的关系。体现：在Java代码中此类关系通过关键字extends明确标识，且在设计时一般没有什么二义性。代码：1public class Student extends Person &#123;&#125; 别名：is-a图示： 实现(Realization)概念：指的是一个class类实现interface接口（可以是多个）的功能；实现是类与接口之间最常见的关系。子类比父类拓展了功能。体现：在Java代码中此类关系通过关键字implements明确标识，且在设计时一般没有什么二义性。别名：(is-)like-a代码：123public class BookDaoImpl implements BookDao &#123;&#125;public class BookDaoImpl extends BaseDaoImpl implements BookDao &#123;&#125; 图示： 依赖(Dependency)概念：可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是B类的变化会影响到A。体现：在Java代码中，类B作为参数被类A在某个method方法中使用，也就是局部变量。代码：1public void drink(Water water) &#123;&#125; 别名：use-a图示： 关联(Association)概念：体现的是两个类、或者类与接口之间语义级别的一种强依赖关系。这种关系比“依赖”更强、不存在“依赖”关系的偶然性，也不是临时性的，一般是长期性的，而且双方的关系一般是平等的、关联可以是单向、双向的、自身关联。体现：在Java代码中，被关联类B以类属性的形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的成员变量。代码：123public class Employee &#123; Computer computer;&#125; 别名：(has-a)图示： 聚合(Aggregation)_概念：聚合是关联关系的一种特例，他体现的是整体与部分的关系，拥有的关系，可以是多和一的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享；体现：表现在代码层面，其实和关联关系是一致的，没有什么太大的区别，只能从语义级别来区分。代码：1234public class Car &#123; Set&lt;Wheel&gt; wheel; Set&lt;Door&gt; doors;&#125; 别名：has-a图示： 组合(合成)(Composition)概念：组合也是关联关系的一种特例，这种关系比聚合更强，也称为强聚合；他同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束，两者生命周期一致。体现：表现在代码层面，和关联关系是一致的，只能从语义级别来区分。代码：1234567public class Person &#123; Head head = new Head();&#125;public class Company &#123; Set&lt;Department&gt; departments = new HashSet&lt;&gt;();&#125; 别名：contains-a图示： 补充说明：对于继承、实现这两种关系没多少疑问，他们体现的是一种类与类、或者类与接口间的纵向关系；而其他的四类关系则体现的是类与类、或者类与接口间的引用，是一种横向关系，也是比较难区分的。有很多事物间的关系要想准确定性是很难的，前文也提到这四种关系都是语义级别的，所以从代码层面并不能完全清楚的区分。但总的来说，后几种关系所表现的强弱程度依次为：组合 &gt; 聚合 &gt; 关联 &gt; 依赖； UML示例这个是我根据前文基本概念画的一张经典UML类关系图，包含泛化，实现，依赖，关联，聚合，组合。图片是SVG格式，如果浏览器不支持，可以查看JPEG图片文件。 图中的接口实现的箭头不是标准的。正确的关系表示箭头如下： UML代码根据这张UML图，可以生成对应的Java代码。这里我使用Idea根据UML图写了一个测试案例，可以点击这里下载。 这里只贴出Test部分的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.chain.test.day01;import org.junit.Test;public class UMLTest &#123; // 被 依赖 的对象需要提前创建好。 private static Air air = new Air(); private static Water water = new Water(); @Test public void test() &#123; Company company = new Company("Oracle"); Department department1 = new Department("Database"); Department department2 = new Department("Router"); // 公司和部门是 组合 关系，公司不能没有部门。 company.addDepartment(department1); company.addDepartment(department2); Computer computer1 = new Computer(); Computer computer2 = new Computer(); Computer computer3 = new Computer(); // 电脑和员工是 关联 关系，员工可以没有电脑，只不过没有电脑的员工不能办公(work)。 Employee employee1 = new Employee("Jack", computer1); Employee employee2 = new Employee("Mark"); Employee employee3 = new Employee("Peter"); Employee employee4 = new Employee("James"); Employee employee5 = new Employee("May"); employee3.setComputer(computer2); employee4.setComputer(computer3); // 部门和员工是 聚合 关系，部门是整体，员工是部门，员工可以不隶属于任何部门内。 // 比如employee2就不属于任何部门 department1.addEmployee(employee1); department1.addEmployee(employee3); department2.addEmployee(employee4); department2.addEmployee(employee5); // 输出公司内的部门，以及各部门内的员工信息 System.out.println(company); // 调用员工的work方法，没有电脑的员工不能办公(work)。 employee1.work(); employee2.work(); employee3.think(); employee4.breath(air); employee5.drink(water); &#125;&#125; 输出： Company{name=’Oracle’, departments=[Department{name=’Database’, employees=[Employee{name=Jack}, Employee{name=Peter}]}, Department{name=’Router’, employees=[Employee{name=May}, Employee{name=James}]}]}Employee Jack work with the computer.Employee Mark doesn’t have a computer.Head doSomethingAir doSomethingWater doSomething 参考资料参考一参考二参考三]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么计算机存储负整数为反码+1]]></title>
    <url>%2F2016%2F10%2F28-why-negative-integer-save-to-fanma-plusone%2F</url>
    <content type="text"><![CDATA[为什么计算机存储负整数为反码+1在学习计算机基础时，数值存储在计算机中均是补码形式，正整数在计算机存储是原封不动的，原来什么样，存储也是什么样，也就是说补码=原码=反码；而负整数却是补码=反码+1，反码为原码的除符号位均取反。那么为什么负整数要这样存储？ 负整数的存储首先看两个正整数相加，比如 7 + 3 ，计算机以补码形式存储和计算。 效果如下： 1234 ‭0...0111+ ‭0...0011‬---------- ‭ 0...1010‬ 可以看到第一位符号位均为0，计算结果也正确，满足 7 + 3 = 10。 接在我们在算 7 - 3 ，计算机中不能直接做减法运算，只能做加法运算（为什么？因为电路上加法器好做，具体可以移步百度百科）。实际运算其实是 7 + (-3)。如果 -3 不使用补码=反码+1，而是和正数一样，那会怎么样呢？ 效果如下： 1234 0...0111+ 1...0011---------- 1...1010 可以看到计算结果为 -10，计算结果显然不正确。应该为 7 + (-3) = 4。 下面将负整数 -3 取反，结果如下(WORD)： 123~ 1000 0000 0000 0011--------------------- ‭1111 1111 1111 1100‬ 此时的反码和 7 运算的结果呢？ 1234 0000 0000 0000 0111+ 1111 1111 1111 1100‬--------------------- 0000 0000 0000 0011 运算结果为 3 ，这显然与正确结果有出入，要是再加上一就对了。 再将反码+1，得到补码： 1234 1111 1111 1111 1100‬+ 0000 0000 0000 0001--------------------- 1111 1111 1111 1101 此时将补码与 7 运算，得到结果： 1234 0000 0000 0000 0111+ 1111 1111 1111 1101--------------------- 0000 0000 0000 0100 运算结果为 4 ，这个和 7 - 3 = 7 + (-3) = 4 的结果是一致的。 因此，计算机中负整数的存储为补码 = 反码 + 1。 特殊数字：零WORD下，+0的存储如下： 123+0的原码：0000 0000 0000 0000+0的反码：0000 0000 0000 0000+0的补码：0000 0000 0000 0000 -0的存储如下： 123-0的原码：1000 0000 0000 0000-0的反码：1111 1111 1111 1111-0的补码：0000 0000 0000 0000 在Eclipse中测试一下： 123456789@Testpublic void test4() &#123; int a = 0; int b = -0; System.out.println(Integer.toBinaryString(a)); System.out.println(Integer.toBinaryString(b)); System.out.println(a); System.out.println(b);&#125; 结果： 0000 由此可以看出，+0和-0在计算机中存储一样，计算机中没有+0和-0的概念，只有0。另外，也可以看出，-0的存储的符号位为0，哈哈。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解字符集和编码以及Java中的乱码解决]]></title>
    <url>%2F2016%2F10%2F02-javase-understand-charset%2F</url>
    <content type="text"><![CDATA[理解字符集和编码以及Java中的乱码解决回顾复习一下字符集和编码，以及如何解决Java中乱码的问题，也查阅整理了Java中char的含义。 基本概念1、字符、字节、字 字符：人类使用的记号，抽象意义上的一个符号。比如阿拉伯数字“1”，英文字母“A”，中文汉字“中”。 字节：计算机中的一个存储单位，8个比特为一个字节。 在C语言中，用char来表示一个字节，如果用于存储字符的话则对应的为ASCII字符集编码表，而Java中byte表示一个字节，而char表示的是Unicode字符集，UTF-16BE(Big Edition)编码表。 字：这个也是一个计算机中的存储单位，英文为WORD，表示两个字节。对应的还有DWORD,QWORD。 Java中WORD-short(两个字节),DWORD-int(四个字节),QWORD-long(八个字节)。 注：有些教科书中讲“一个汉字占两个字节”是不全面的，准确的说“在有些汉字编码（比如GB2312）中，一个汉字占两个字节，而再其他编码中，汉字不一定占两个字节，比如UTF系列”。 2、字符集、编码 字符集：首先是一个集合，集合内包含了一些被选择的字符。是一种规范。 比如GBK包含了GB2312的字符，但是GB2312内没有GBK的一些字符。 编码：字符如何在计算机中存储，每个字符用一个字节还是多个字节，以及存储的具体格式。是一种方式，用于传播和存储。 比如ASCII均用一个字节来存储字符，而GB2312中一个字节且序号低于127的表示原来ASCII内的字符，两个字节且每个字节序号都高于127的表示汉字等，也是GB2312与ASCII兼容的由来；在GBK中，高字节序号低于127表示源来的ASCII内的字符，高字节序号高于127则连同低字节一起两个字节表示汉字等。（高字节可以理解为第一个字节，低字节为第二个字节） 注：不少编码和字符集是同时制定的，如GB2312既表示字符集也表示编码。而Unicode则表示字符集，UTF-8，UTF-16等表示编码。 3、ASCII、ANSI、Unicode 这三者其实是字符集发展的历史历程。ASCII -&gt; ANSI -&gt; Unicode ASCII：American Standard Code for Information Interchange。这个是最早在DOS系统中使用,包括一些控制字符，数字，英文字母大小写，特殊字符，对于英文环境足够使用。字符集中的字符序号和实际编码格式是一样的。 ANSI：American National Standards Institute。美国国家标准协会。这不是一个编码，而是一种标准。比如在简体中文的Windows操作系统中ANSI指的是GB2312，在繁体中文的Windows操作系统中ANSI指的是BIG5，在日文操作系统中ANSI指的是JIS。其实这个很蛋疼，比如日本的网友发了一个ANSI标准(JIS编码)的文本，中国伙伴也以ANSI(GB2312)打开，却是乱码。 Unicode：万国码。主要是将全世界的字符放到一个字符集合中，解决跨平台和跨语言的问题。Unicode有很多编码方案，常用的是UTF-8，还有UTF-16,UTF-32等。UTF( UCS Transformation Format)是Unicode的具体编码实现方式。 补充：1、ANSI转其他编码比如Unicode是人为规定的，而Unicode转其他编码是可以算出来的。2、ISO-8859-1是最简单的单字节编码。3、这里再介绍一下UTF-8： UTF-8是变长编码，编码长度和Unicode编码有关，UTF-8（一到四个字节）兼容ASCII，UTF-16（两个或四个字节）不兼容ASCII。 Unicode序号(十六进制) UTF-8 字节流(二进制) 000000-00007F 0xxxxxxx 000080-0007FF 110xxxxx 10xxxxxx 000800-00FFFF 1110xxxx 10xxxxxx 10xxxxxx 010000-1FFFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 摘自百度的例子：“汉”这个字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用三字节模板：1110xxxx 10xxxxxx 10xxxxxx。将0x6C49写成二进制是：0110 1100 0100 1001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。汉字在UTF-8中范围是[0x4e00,0x9fbb]，三字节编码。 注意：在编程中，源文件的编码格式也很重要，一个项目中的源文件编码应当统一，一般使用UTF-8。否则，会出现字符显示异常，甚至莫名其妙的编译问题。 常见现象1、存储的数据是对的，打开文档时选错编码格式。现象：以GBK编码写了一篇文档，打开时的软件却错误的选择了UTF-8的编码，从而导致中文显示乱码，英文和数字正常。分析：GBK和UTF-8都是兼容ASCII的，所以英文和数字正常。而中文在GBK和UTF-8这两个编码方式中是不一样的，换句话说，存储的数据是不一样的。解决：这个时候只要设置打开文本的软件编码格式为GBK，再重新打开文本就行，此时千万不要修改和保存文档。一般以什么编码保存，就以什么编码再打开最好。 2、将文本进行转码解决：如果原先文本是以GBK编码存储，想转为UTF-8，则将原文本以GBK格式先打开，然后复制文本的内容到剪贴板，删除原文本文件内的所有内容，更改文本的存储编码为UTF-8，再粘贴刚才复制的内容保存即可。 3、打开文本发现乱码后，又修改了文本，并保存。解决：这个解决起来很麻烦，而且恢复成功率不高，取决于文本编辑器如何对文本进行保存。 Java中的char前面已经说到，Java中的char是采用Unicode字符集，UTF-16BE的编码。UTF-16使用两个或四个字节表示一个字符，Unicode编号范围在65536以内的占两个字节，超出范围的占四个字节。BE (Big Endian)的意思大端，即是先输出高位字节，再输出低位字节，这与整数的在内存中的表示是一样的。换句话说char只能表示编号在65536以内的字符，超过部分需要用两个char凑四个字节表示。 Java的源文件如果是GBK编码，那么打开这个源文件也需要用GBK编码。如果IDE不支持GBK，比如使用英文操作系统，那么就会默认以其他如UTF-8编码打开，这样就会显示乱码。因此，最好统一项目源码为UTF-8编码。 在C语言中,char是一个字节，只能表示256个字符，而Java中的char就可表示的字符大了不少。在Java中，用一个char就可以表示汉字。另外，也可以直接赋数值，或者赋Unicode编码序号值。 123456789101112131415char c1 = '汉';char c2 = '\u6c49';int i3 = c1;// 27721char c3 = (char) i3;char c4 = 0x6c49;System.out.println(c1);System.out.println(c2);System.out.println(i3);System.out.println(c3);System.out.println(c4);System.out.println(Integer.toBinaryString(c1));if ((c1 &gt;= 0x4e00) &amp;&amp; (c1 &lt;= 0x9fbb)) &#123; System.out.println("中文");&#125; 输出： 汉汉27721汉汉110110001001001中文 char本质上也是数值，它和short一样是占两个字节，只不是它是无符号数，范围和short不一样，char可以参与数值运算、位运算，但是作为数值赋值和运算时会自动转型为int。 char的运算主要运用在判断某个字符是否是[0-9A-Za-z]，转换字母大小写，这点和学C语言时char的作用是类似的。 Java中的转码在WEB项目中，字符编码的问题一直很头疼，很容易就遇到乱码的问题。 先说一下历史背景：12345678910111213RFC 1738规定：只有字母和数字[0-9a-zA-Z]，一些特殊符号如$ (美元)、- (负号，减号)、_ (下划线)、. (点)、+ (加号)、! (英文感叹号)、* (星号)、&apos; (英文单引号)、( (英文左括弧)、) (英文右括弧)、, (英文逗号)，以及某些保留字，才可以不经过编码直接用于URL 也就是说，除规定之外的其他字符不能出现在URL中。这个规定是好的，但是RFC 1738没有规定具体的编码方法，而是交给各个浏览器厂家自行制定方案。这也就是如今令人头疼的乱码问题的由来，不同的操作系统、不同的浏览器、不同的字符集，将导致完全不同的编码结果。 1URL格式：schema://host[:port#]/path/.../[;url-params][?query-string][#anchor] 那么有没有什么比较好的办法解决这个问题呢？解决：本文写于2016年，现在的字符编码问题已经好了很多。主流的Chrome浏览器默认对URL的query部分和URL的path中的非RFC 1738的字符采用UTF-8编码，而有些老浏览器编码则是与操作系统甚至页面有关。如果需要兼容这一部分老浏览器，最好的做法是在前端使用JS中encodeURL方法对URL__进行UTF-8编码__。也就是说页面中的超链接href，URL中的参数，AJAX.GET中的url，最好都使用encodeURL方法来屏蔽差异。界面的显示字符编码可以在meta中注明使用的charset。 GET：1234567891、GET /JavaWeb-Test/charSet?req=123你好abc HTTP/1.1Host: localhost:8080Cache-Control: no-cachePostman-Token: 82b3c5f8-8463-be94-f1ff-b81b9ef5400d2、GET /JavaWeb-Test/charSet?req=123%E4%BD%A0%E5%A5%BDabc HTTP/1.1Host: localhost:8080Cache-Control: no-cachePostman-Token: bec648b3-3733-2b4f-7b85-edd226708e91 12345678910111213141516171819protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("UTF-8"); response.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=utf-8"); PrintWriter pw = response.getWriter(); String req = request.getParameter("req"); System.out.println(req); pw.println(req); pw.println("&lt;br/&gt;"); byte[] bytes = req.getBytes("ISO-8859-1"); String tras = new String(bytes, "UTF-8"); System.out.println(tras); pw.println(tras); pw.println("&lt;br/&gt;"); //tras为最终的正确参数&#125; POST：1234567891011121314151、POST /JavaWeb-Test/charSet HTTP/1.1Host: localhost:8080Content-Type: application/x-www-form-urlencodedCache-Control: no-cachePostman-Token: 54d9777a-e4c3-305a-9385-0c0941875e09req=123%E4%BD%A0%E5%A5%BDabc2、POST /JavaWeb-Test/charSet HTTP/1.1Host: localhost:8080Content-Type: application/x-www-form-urlencodedCache-Control: no-cachePostman-Token: cc92d9c9-d864-8b39-4b05-8ec9828b74ddreq=123你好ABC 1234567891011121314protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("UTF-8"); response.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=utf-8"); PrintWriter pw = response.getWriter(); String req = request.getParameter("req"); System.out.println(req); pw.println(req); pw.println("&lt;br/&gt;"); //req为最终的正确参数&#125; 补充：在项目中到底使用UTF-8还是GBK:现在项目最好使用UTF-8，特别是面向多终端，不同的操作系统，不同的国家。因为有些英文操作系统并不默认携带有GBK的编码，而UTF-8被广泛的支持。如果仅仅是中文的网站，可以使用GBK，因为GBK每个字符只占两个字节，UTF-8中汉字占三个字节，是变长编码，使用GBK节省空间。当然，无论是GBK还是UTF-8，对英文和数字支持都是没有问题的。 其他知识点整理自这里 UTF字节序和BOM字节序（大小端）： UTF-8以字节为编码单元，没有字节序的问题。UTF-16以两个字节为编码单元，在解释一个UTF-16文本前，首先要弄清楚每个编码单元的字节序。 问题：例如收到一个“奎”的Unicode编码是594E，“乙”的Unicode编码是4E59。如果我们收到UTF-16字节流“594E”，那么这是“奎”还是“乙”？解决：在UCS编码中有一个叫做”ZERO WIDTH NO-BREAK SPACE”的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符”ZERO WIDTH NO-BREAK SPACE”。这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符”ZERO WIDTH NO-BREAK SPACE”又被称作BOM。 BOM： UTF-8没有字节序的问题，所以不需要BOM来表明字节顺序。但是可以用BOM来表明编码方式。字符”ZERO WIDTH NO-BREAK SPACE”的UTF-8编码是EF BB BF（读者可以用我们前面介绍的编码方法验证一下）。所以如果接收者收到以EF BB BF开头的字节流，就知道这是UTF-8编码了。 BOM与XML: XML解析读取XML文档时，W3C定义了3条规则： ①如果文档中有BOM，就定义了文件编码； 如果是FF FE则为UTF-16LE如果是FE FF则为UTF-16BE如果是EF BB BF则为UTF-8 ②如果文档中没有BOM，就查看XML声明中的编码属性；比如：1&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; ③如果上述两者都没有，就假定XML文档采用UTF-8编码。 Windows记事本支持的编码（1）ANSI编码记事本默认保存的编码格式是：ANSI，即本地操作系统默认的内码，简体中文操作系统一般为GB2312。这个怎么验证呢？用记事本保存后，使用EmEditor、EditPlus和UltraEdit之类的文本编辑器打开。打开后，在右下角会显示编码：GB2312。 （2）Unicode编码用记事本另存为时，编码选择“Unicode”，用EmEditor打开该文件，发现编码格式是：UTF-16LE+BOM（有签名）。用十六进制方式查看，发现开头两字节为：FF FE。这就是BOM。 （3）Unicode big endian用记事本另存为时，编码选择“Unicode”，用EmEditor打开该文件，发现编码格式是：UTF-16BE+BOM（有签名）。用十六进制方式查看，发现开头两字节为：FE FF。这就是BOM。 （4）UTF-8用记事本另存为时，编码选择“UTF-8”，用EmEditor打开该文件，发现编码格式是：UTF-8（有签名）。用十六进制方式查看，发现开头三个字节为：EF BB BF。这就是BOM。 编辑软件自动判断文件的编码方式 首先说一个奇特的例子：在简体中文Windows环境下，新建记事本文档为test.txt,写入”联通”两个字，默认ANSI编码保存并关闭，再打开test.txt文本文件后后发现变成一个方块黑点（Win10中为两个菱形）。 软件通常有三种途径来决定文本的字符集和编码。 （1）对于Unicode文本最标准的途径是检测文本最开头的几个字节。如： 开头字节 Charset/encoding EF BB BF UTF-8 FE FF UTF-16/UCS-2, little endian(UTF-16LE) FF FE UTF-16/UCS-2, big endian(UTF-16BE) FF FE 00 00 UTF-32/UCS-4, little endian 00 00 FE FF UTF-32/UCS-4, big-endian （2）采取一种比较安全的方式来决定字符集及其编码，那就是弹出一个对话框来询问用户。 然而MBCS文本（ANSI）没有这些位于开头的字符集标记，现在很多软件保存文本为Unicode时，可以选择是否保存这些位于开头的字符集标记。因此，软件不应该依赖于这种途径。这时，软件可以采取一种比较安全的方式来决定字符集及其编码，那就是弹出一个对话框来询问用户。 （3）采取自己“猜”的方法。 如果软件不想麻烦用户，或者它不方便向用户请示，那它只能采取自己“猜”的方法，软件可以根据整个文本的特征来猜测它可能属于哪个CharSet，这就很可能不准了。 现在再来解释一下之前的奇特的例子：使用UltraEdit打开那个test.txt,可以看到十六进制下为C1 AA CD A8，二进制则为‭11000001 10101010 11001101 10101000，观察前文的UTF-8编码，‬符合模板二，因而记事本会认为这是UTF-8编码存储的，打开后自然是乱码了。可以设置UltraEdit右下角打开的编码为GB2312或GBK，就可以正常显示。 谈谈“烫烫烫”和“棍斤拷”参考1 参考2 在学习C/C++语言时，调试状态下有时会出现“烫烫烫”和“屯屯屯”。而在学习Java时，在CMD调试或者WEB项目时，会碰到“浣犲ソ”、“涓 浗”和“钝斤拷”，前端则会遇到“锘锘锘”和“锘匡豢”。 前者主要原因是C语言调试器会默认将栈内的未初始化数据初始化为”0xcc”，堆内的未初始化数据初始化为”0xcd”。0xcc对应的是中断向量表中的3号中断（INT 3)。 微软的调试器之所以会写入一些特定的字符，主要是为了便于检查出程序在调试过程中发生错误的原因，就像flag一样。因此一定要注意数组的初始化、数组的越界检查，字符串末尾的0，出现了“烫烫烫”总比程序崩溃要好很多。 中者主要是字符编码和转码的问题。Unicode尽管被成为万国码，但是和其他编码转化时仍然会有一些字符是用Unicode没法表示的，Unicode转为其他编码可以算出来，而其他编码转为Unicode只能人工写一个转换表，因此Unicode使用了一个占位符来表示这些没有被收编的字符，这就是：U+FFFD REPLACEMENT CHARACTER。另一方面，U+FFFD使用UTF-8编码结果是0xef 0xbf 0xbd。如果这个0xef 0xbf 0xbd被重复多次，例如 0xef 0xbf 0xbd 0xef 0xbf 0xbd，然后放到GBK环境中显示的话，一个汉字占2个字节，那么最终的显示就变成了“锟斤拷”。因此在涉及到转码的时候要格外注意转码。 后者主要是前文讲的BOM问题。BOM在UTF-8表示为EF BB BF。两个EF BB BF就总共是六个字节，在GBK编码中刚好是三个汉字，也就是“锘匡豢”。因此在编写HTML等页面时不使用BOM，而在页面中注明charset=utf-8，页面本身以UTF-8编码保存即可。 下面在简体中文操作系统中复现这些现象： 1、“烫烫烫”和“屯屯屯”1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; //栈：烫烫烫 char a[10]; printf("%s\n",a); //堆：屯屯屯 int* b = (int* )malloc(sizeof(int)*10); printf("%s\n",b); free(b); b = NULL; return 0;&#125; 2、“浣犲ソ”和“钝斤拷”12345678910111213141516171819202122232425262728@Testpublic void test6() throws UnsupportedEncodingException &#123; /* 错误的转码 */ // 浣犲ソ String str = "你好"; byte[] bytes = str.getBytes("UTF-8"); String s = new String(bytes, "GBK"); System.out.println(s); // 涓 浗 String str2 = "中国"; byte[] bytes2 = str2.getBytes("UTF-8"); String s2 = new String(bytes2, "GBK"); System.out.println(s2); // 锟斤拷 String str3 = "联通"; byte[] bytes3 = str3.getBytes("UTF-8"); String s3 = new String(bytes3, "GBK"); // System.out.println(s3); byte[] bytes4 = s3.getBytes("UTF-8"); for (byte b : bytes4) System.out.print(Integer.toHexString(b) + " "); System.out.println(); String s4 = new String(bytes4, "GBK"); System.out.println(s4);&#125; 3、“锘锘锘”和“锘匡豢”现在基本遇不到了。 4、使用Java汇总模拟12345678910111213141516171819202122232425262728@Testpublic void test5() throws UnsupportedEncodingException &#123; byte[] bytes = new byte[100]; // 烫烫烫 bytes[0] = (byte) 0xcc; bytes[1] = (byte) 0xcc; bytes[2] = (byte) 0xcc; bytes[3] = (byte) 0xcc; bytes[4] = (byte) 0xcc; bytes[5] = (byte) 0xcc; // 屯屯屯 bytes[6] = (byte) 0xcd; bytes[7] = (byte) 0xcd; bytes[8] = (byte) 0xcd; bytes[9] = (byte) 0xcd; bytes[10] = (byte) 0xcd; bytes[11] = (byte) 0xcd; // 锘匡豢 bytes[12] = (byte) 0xef; bytes[13] = (byte) 0xbb; bytes[14] = (byte) 0xbf; bytes[15] = (byte) 0xef; bytes[16] = (byte) 0xbb; bytes[17] = (byte) 0xbf; System.out.println(new String(bytes, "GBK"));&#125; 最后附上一首诗：手持两把锟斤拷, (GBK与UTF-8)口中疾呼烫烫烫。(VC++)脚踏千朵屯屯屯, (VC++)笑看万物锘锘锘。(HTML) 完]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射和ReflectionUtils]]></title>
    <url>%2F2016%2F09%2F12-javase-note-reflection%2F</url>
    <content type="text"><![CDATA[Java反射和ReflectionUtils复习了佟老师和毕老师的视频，也阅读了一些写的很棒的博客，整理一下Java中关于反射的笔记。包括一个ReflectionUtils。 什么是反射反射，即Reflect，使得程序在运行时能够像照镜子一样获得自身的一些信息。比如一个类中可以有那些方法，那些字段，而不需要知道源代码。 Java是一门静态语言，即在编译是就确定了类型，换句话说程序在运行时是不能修改自身的。这和Python或者JavaScript不一样，后者是动态语言，可以在程序运行时动态的进行修改。 JavaScript动态特性的例子：123456789101112131415161718192021window.onload = function() &#123; var person = new Object(); person.name = "Jack"; person.getName = function() &#123; return this.name; &#125; console.log(person.getName()); person.getName = function() &#123; return "Mr." + this.name; &#125; console.log(person.getName()); person.getName = undefined; console.log(person.getName());&#125; 输出结果： jackMr.jackUncaught TypeError: person.getName is not a function 反射的作用一个经常被提到的例子就是JBDC中DriverManager使用Class.forName()来加载JDBC的驱动。123456789for (String aDriver : driversList) &#123; try &#123; println("DriverManager.Initialize: loading " + aDriver); Class.forName(aDriver, true, ClassLoader.getSystemClassLoader()); &#125; catch (Exception ex) &#123; println("DriverManager.Initialize: load failed: " + ex); &#125;&#125; DriverManager只需要根据预先设好的JDBC驱动类的名字就可以加载并生成驱动实例。比如设置“java.mysql.jdbc.Driver”就可以加载好MySQL数据库的驱动，设置“oracle.jdbc.driver.OracleDriver”就可以加载好Oracle数据库的驱动。 在之后的学习中，也了解到比如Struts、Spring、Hibernate等诸多框架中都是使用了反射。比如在配置文件中写上Bean实例的全名，Spring就可以根据这个全名利用反射自动的生成实例放在IOC容器中。 另一方面，反射能够有效降低类之间的耦合，一个大型的框架或者软件中，需要不断的后期去修改升级。如果修改或增加了功能，每次都重新发布整体新包让用户重新安装也不大方便。为此，可以使用很多方法去将程序模块化，降低耦合。这里举反射的例子，还是上面的JDBC的驱动，比如一开始使用版本是1.0，后来升级到了1.1，只需要替换相应的jar包或者再修改下配置文件就行，而不需要修改其他部分的代码。 此外，使用反射可以生成一些模板方法，避免容易犯低级错误的重复劳动，比如下面两对SQL语句。 12345INSERT INTO USER(ID,NAME,AGE) VALUES (123456,'jack',20);INSERT INTO DEPARTMENT(ID,NAME) VALUES (11111,'技术部');SELECT * FROM USER WHERE ID = 123456;SELECT * FROM DEPARTMENT WHERE ID = 123456; 观察发现基本语法写法一致，只是内容不一样而已。使用反射原理，传入User和Department两个对象就可以生成这两种SQL语句（Hibernate的原理之一）。 可以使用getMethods()方法获得所有可访问的方法，getFields获得所有可访问的字段，然后再获得这个由方法和字段获得对象中存储的字段值(value)，最终就可以拼凑出SQL来。 反射工具类这个是反射工具类，基于佟老师的讲课视频，加以整理。 包括：1、获得类中某个名为xxx的方法2、执行类或对象中某个名为xxx的方法3、获得类中某个名为yyy的字段(属性)4、设置对象中名为yyy的字段(属性)的值5、获得类中某个构造方法6、通过类中的构造方法和参数创建类实例7、获得类、方法、字段的某个注解8、获得某个类后者其父类的泛型参数类型 下面贴上源码，完整的包括测试代码在这里可以下载： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346package com.chain.javase.reflect.utils;import java.lang.annotation.Annotation;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.ArrayList;import java.util.List;/** * 反射工具类 * * @author Chain * */public class ReflectionUtils &#123; /** * 根据类名（className）获得对应的“类实例”（instance of Class） * * @param className * 类名 * @return 类实例 */ public static Class getClassByName(String className) &#123; Class clz = null; try &#123; clz = Class.forName(className); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return clz; &#125; /** * 根据对象（Object）获得对应的“类实例”（instance of Class） * * @param obj * 对象 * @return 类实例 */ public static Class getClassByObject(Object obj) &#123; return obj.getClass(); &#125; public static Method getDeclaredMethod(Object obj, String methodName, Class... parameterTypes) &#123; return getDeclaredMethod(getClassByObject(obj), methodName, parameterTypes); &#125; public static Method getDeclaredMethod(String className, String methodName, Class... parameterTypes) &#123; return getDeclaredMethod(getClassByName(className), methodName, parameterTypes); &#125; /** * 获得类中对应的具有某个参数列表的方法 * * @param clz * 类 * @param methodName * 方法名 * @param parameterTypes * 方法的参数列表的Class类型 * @return */ public static Method getDeclaredMethod(Class clz, String methodName, Class... parameterTypes) &#123; for (Class c = clz; c != Object.class; c = c.getSuperclass()) &#123; try &#123; Method m = c.getDeclaredMethod(methodName, parameterTypes); return m; &#125; catch (NoSuchMethodException | SecurityException e) &#123; // e.printStackTrace(); continue; &#125; &#125; return null; &#125; /** * 忽略或者设置方法或者属性的修饰符（“暴力访问”） * * @param obj * @param bool */ private static void setAccessible(Object obj, boolean bool) &#123; if (obj instanceof Method) ((Method) obj).setAccessible(bool); else if (obj instanceof Field) ((Field) obj).setAccessible(bool); &#125; /** * 根据类名获得类的实例（需要类具有无参构造函数） * * @param className * @return */ public static Object getObjectByName(String className) &#123; return getObjectByClass(getClassByName(className)); &#125; /** * 根据“类实例”获得类的实例（需要类具有无参构造函数） * * @param clz * @return */ public static Object getObjectByClass(Class clz) &#123; Object obj = null; try &#123; obj = clz.newInstance(); &#125; catch (InstantiationException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; return obj; &#125; public static Object invokeMethod(String classToInvoke, Method m, Object... methodParams) &#123; Object obj = getObjectByName(classToInvoke); return invokeMethod(obj, m, methodParams); &#125; public static Object invokeMethod(Class classToInvoke, Method m, Object... methodParams) &#123; Object obj = getObjectByClass(classToInvoke); return invokeMethod(obj, m, methodParams); &#125; /** * 执行对象的某个方法 * * @param objToInvoke * @param m * @param methodParams * @return */ public static Object invokeMethod(Object objToInvoke, Method m, Object... methodParams) &#123; Object result = null; try &#123; setAccessible(m, true); result = m.invoke(objToInvoke, methodParams); &#125; catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) &#123; // e.printStackTrace(); &#125; return result; &#125; public static Field getDeclaredField(Object obj, String fieldName) &#123; return getDeclaredField(getClassByObject(obj), fieldName); &#125; public static Field getDeclaredField(String clzName, String fieldName) &#123; return getDeclaredField(getClassByName(clzName), fieldName); &#125; /** * 获得类中的某个属性（字段） * * @param clz * @param fieldName * @return */ public static Field getDeclaredField(Class clz, String fieldName) &#123; for (Class c = clz; c != Object.class; c = c.getSuperclass()) &#123; try &#123; Field f = c.getDeclaredField(fieldName); return f; &#125; catch (SecurityException | NoSuchFieldException e) &#123; // e.printStackTrace(); continue; &#125; &#125; return null; &#125; public static Object setField(String clzName, Field f, Object value) &#123; return setField(getObjectByName(clzName), f, value); &#125; public static Object setField(Class clz, Field f, Object value) &#123; return setField(getObjectByClass(clz), f, value); &#125; /** * 设置对象中某个属性的值 * * @param obj * @param f * @param value * @return */ public static Object setField(Object obj, Field f, Object value) &#123; try &#123; setAccessible(f, true); f.set(obj, value); &#125; catch (IllegalArgumentException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; return obj; &#125; public static Constructor getConstructor(String clzName, Class... parameterTypes) &#123; return getConstructor(getClassByName(clzName), parameterTypes); &#125; public static Constructor getConstructor(Object obj, Class... parameterTypes) &#123; return getConstructor(getClassByObject(obj), parameterTypes); &#125; /** * 获得类的某个构造器 * * @param clz * @param parameterTypes * @return */ public static Constructor getConstructor(Class clz, Class... parameterTypes) &#123; for (Class c = clz; c != Object.class; c = c.getSuperclass()) &#123; try &#123; Constructor cs = c.getConstructor(parameterTypes); return cs; &#125; catch (SecurityException | NoSuchMethodException e) &#123; // e.printStackTrace(); continue; &#125; &#125; return null; &#125; /** * 根据构造器创建类实例 * * @param cs * @param initArgs * @return */ public static Object newInstanceByConstrutor(Constructor cs, Object... initArgs) &#123; Object obj = null; try &#123; obj = cs.newInstance(initArgs); &#125; catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) &#123; e.printStackTrace(); &#125; return obj; &#125; /** * 获得加在类上的注解 * * @param clz * @param annotationClass * @return */ public static Annotation getDeclaredAnnotation(Class clz, Class annotationClass) &#123; Annotation an = clz.getDeclaredAnnotation(annotationClass); return an; &#125; /** * 获得加在属性上的注解 * * @param f * @param annotationClass * @return */ public static Annotation getDeclaredAnnotation(Field f, Class annotationClass) &#123; Annotation an = f.getDeclaredAnnotation(annotationClass); return an; &#125; /** * 获得加在方法上的注解 * * @param m * @param annotationClass * @return */ public static Annotation getDeclaredAnnotation(Method m, Class annotationClass) &#123; Annotation an = m.getDeclaredAnnotation(annotationClass); return an; &#125; /** * 获得加在构造器上的注解 * * @param c * @param annotationClass * @return */ public static Annotation getDeclaredAnnotation(Constructor c, Class annotationClass) &#123; Annotation an = c.getDeclaredAnnotation(annotationClass); return an; &#125; /** * 获得类（或父类）的泛型参数类型中的某一个 * * @param clz * @param index * @return */ public static Class getSuperGenericType(Class clz, int index) &#123; List&lt;Class&gt; lst = getSuperGenericTypes(clz); if (lst.size() - 1 &lt; index) return Object.class; return lst.get(index); &#125; /** * * 获得类（或父类）的泛型参数类型的列表 * * @param clz * @return */ public static List&lt;Class&gt; getSuperGenericTypes(Class clz) &#123; List&lt;Class&gt; lst = new ArrayList&lt;&gt;(); if (clz == null) &#123; lst.add(Object.class); return lst; &#125; Type genericType = clz.getGenericSuperclass(); if (!(genericType instanceof ParameterizedType)) &#123; lst.add(Object.class); return lst; &#125; Type[] params = ((ParameterizedType) genericType).getActualTypeArguments(); for (int i = 0; i &lt; params.length; i++) if (params[i] instanceof Class) lst.add((Class) params[i]); else lst.add(Object.class); return lst; &#125;&#125; 编程就像练功一样，这只是一个简单的工具类。像反射，注解，泛型等Java中哪怕是最基本的知识点，也需要不断的去阅读书籍和源码，才能体会到它们的更牛的用法。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码分析StringBuffer和StringBuilder]]></title>
    <url>%2F2016%2F09%2F07-springbuilder-and-springbuffer%2F</url>
    <content type="text"><![CDATA[源码分析StringBuffer和StringBuilder一直都说StringBuffer是线程安全的，而StringBuilder是线程不安全的。那么到底StringBuilder不安全在哪，StringBuffer又为什么是安全的呢？ 背景知识线程安全：线程安全简单讲就是多线程访问同一段代码或者同一个变量时，可能会出现不可预料的结果。 测试代码编写了如下测试代码：MyThread是对StringBuilder的操作线程，对传入的StringBuilder实例进行append操作，循环执行100次。123456789101112131415161718192021package com.chain.test.day02;public class MyThread implements Runnable &#123; private StringBuilder sb; private char c; public MyThread(StringBuilder sb, char c) &#123; super(); this.sb = sb; this.c = c; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; sb.append(c); &#125; System.out.println(Thread.currentThread().getName() + ": sb.length: " + sb.length()); &#125;&#125; MyThread2是对StringBuffer的操作线程，对传入的StringBuffer实例进行append操作，循环执行100次。123456789101112131415161718192021package com.chain.test.day02;public class MyThread2 implements Runnable &#123; private StringBuffer sb; private char c; public MyThread2(StringBuffer sb, char c) &#123; super(); this.sb = sb; this.c = c; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; sb.append(c); &#125; System.out.println(Thread.currentThread().getName() + ": sb.length: " + sb.length()); &#125;&#125; 最后是测试的方法，每次循环都实例化一个StringBuilder或者StringBuffer，并做为公共的操作对象传入MyThead和MyThread2中。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.chain.test.day02;public class StringBufferBuilderTest &#123; public static void main(String[] args) &#123; // new StringBufferBuilderTest().testA(); new StringBufferBuilderTest().testB(); &#125; public void testA() &#123; for (int i = 0; i &lt; 10; i++) &#123; StringBuilder sb1 = new StringBuilder(); test1(sb1); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(); System.out.println("Test1-" + i + ": " + sb1.length()); System.out.println(); &#125; &#125; public void testB() &#123; for (int i = 0; i &lt; 10; i++) &#123; StringBuffer sb2 = new StringBuffer(); test2(sb2); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(); System.out.println("Test1-" + i + ": " + sb2.length()); System.out.println(); &#125; &#125; public void test2(StringBuffer sb2) &#123; for (int i = 0; i &lt; 10; i++) new Thread(new MyThread2(sb2, (char) (i + 65))).start(); &#125; public void test1(StringBuilder sb1) &#123; for (int i = 0; i &lt; 10; i++) new Thread(new MyThread(sb1, (char) (i + 65))).start(); &#125;&#125; 测试结果分别执行testA和TestB的结果如下：执行testA：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129Thread-2: sb.length: 263Thread-1: sb.length: 297Thread-3: sb.length: 397Thread-0: sb.length: 100Thread-4: sb.length: 497Thread-7: sb.length: 597Thread-9: sb.length: 720Thread-5: sb.length: 818Thread-6: sb.length: 897Thread-8: sb.length: 997Test1-0: 997Thread-11: sb.length: 100Thread-13: sb.length: 300Thread-12: sb.length: 259Thread-14: sb.length: 992Thread-16: sb.length: 892Thread-15: sb.length: 868Thread-17: sb.length: 692Thread-18: sb.length: 692Thread-19: sb.length: 574Thread-10: sb.length: 400Test1-1: 992Thread-20: sb.length: 100Thread-21: sb.length: 300Thread-24: sb.length: 500Thread-23: sb.length: 400Thread-22: sb.length: 300Thread-29: sb.length: 1000Thread-27: sb.length: 900Thread-26: sb.length: 800Thread-28: sb.length: 700Thread-25: sb.length: 600Test1-2: 1000Thread-30: sb.length: 100Thread-32: sb.length: 200Thread-31: sb.length: 300Thread-35: sb.length: 600Thread-36: sb.length: 800Thread-33: sb.length: 500Thread-34: sb.length: 400Thread-39: sb.length: 900Thread-38: sb.length: 1000Thread-37: sb.length: 700Test1-3: 1000Thread-40: sb.length: 100Thread-42: sb.length: 200Thread-41: sb.length: 300Thread-45: sb.length: 500Thread-43: sb.length: 700Thread-44: sb.length: 600Thread-46: sb.length: 500Thread-47: sb.length: 1000Thread-48: sb.length: 1000Thread-49: sb.length: 1000Test1-4: 1000Thread-50: sb.length: 100Thread-51: sb.length: 200Thread-52: sb.length: 300Thread-54: sb.length: 400Thread-55: sb.length: 578Thread-53: sb.length: 578Thread-56: sb.length: 678Thread-58: sb.length: 778Thread-59: sb.length: 878Thread-57: sb.length: 978Test1-5: 978Thread-60: sb.length: 100Thread-61: sb.length: 200Thread-65: sb.length: 300Thread-63: sb.length: 400Thread-62: sb.length: 500Thread-64: sb.length: 600Thread-66: sb.length: 700Thread-68: sb.length: 800Thread-69: sb.length: 900Thread-67: sb.length: 1000Test1-6: 1000Thread-71: sb.length: 200Thread-70: sb.length: 200Thread-74: sb.length: 300Thread-72: sb.length: 400Thread-77: sb.length: 500Thread-73: sb.length: 600Thread-78: sb.length: 700Thread-79: sb.length: 800Thread-75: sb.length: 900Thread-76: sb.length: 1000Test1-7: 1000Thread-80: sb.length: 100Thread-81: sb.length: 200Thread-82: sb.length: 300Thread-83: sb.length: 400Thread-84: sb.length: 500Thread-86: sb.length: 600Thread-85: sb.length: 700Thread-87: sb.length: 800Thread-88: sb.length: 900Thread-89: sb.length: 1000Test1-8: 1000Thread-90: sb.length: 142Thread-91: sb.length: 200Thread-92: sb.length: 300Thread-93: sb.length: 400Thread-94: sb.length: 500Thread-95: sb.length: 600Thread-98: sb.length: 899Thread-97: sb.length: 899Thread-99: sb.length: 700Thread-96: sb.length: 999Test1-9: 999 执行testB：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129Thread-1: sb.length: 200Thread-3: sb.length: 400Thread-2: sb.length: 300Thread-0: sb.length: 200Thread-5: sb.length: 500Thread-6: sb.length: 658Thread-7: sb.length: 878Thread-9: sb.length: 864Thread-8: sb.length: 1000Thread-4: sb.length: 900Test1-0: 1000Thread-10: sb.length: 100Thread-11: sb.length: 200Thread-12: sb.length: 400Thread-13: sb.length: 300Thread-15: sb.length: 600Thread-14: sb.length: 500Thread-17: sb.length: 800Thread-16: sb.length: 700Thread-19: sb.length: 1000Thread-18: sb.length: 900Test1-1: 1000Thread-20: sb.length: 100Thread-21: sb.length: 279Thread-23: sb.length: 449Thread-22: sb.length: 300Thread-25: sb.length: 600Thread-24: sb.length: 507Thread-29: sb.length: 985Thread-27: sb.length: 1000Thread-26: sb.length: 845Thread-28: sb.length: 732Test1-2: 1000Thread-30: sb.length: 100Thread-34: sb.length: 200Thread-33: sb.length: 400Thread-32: sb.length: 400Thread-31: sb.length: 500Thread-35: sb.length: 600Thread-36: sb.length: 700Thread-37: sb.length: 824Thread-39: sb.length: 1000Thread-38: sb.length: 1000Test1-3: 1000Thread-40: sb.length: 100Thread-41: sb.length: 200Thread-43: sb.length: 400Thread-44: sb.length: 400Thread-45: sb.length: 600Thread-42: sb.length: 545Thread-48: sb.length: 900Thread-46: sb.length: 700Thread-49: sb.length: 1000Thread-47: sb.length: 900Test1-4: 1000Thread-50: sb.length: 100Thread-53: sb.length: 300Thread-55: sb.length: 400Thread-54: sb.length: 500Thread-51: sb.length: 300Thread-52: sb.length: 700Thread-56: sb.length: 600Thread-59: sb.length: 883Thread-58: sb.length: 1000Thread-57: sb.length: 1000Test1-5: 1000Thread-60: sb.length: 100Thread-61: sb.length: 200Thread-64: sb.length: 360Thread-63: sb.length: 541Thread-65: sb.length: 400Thread-62: sb.length: 600Thread-69: sb.length: 700Thread-66: sb.length: 913Thread-67: sb.length: 1000Thread-68: sb.length: 913Test1-6: 1000Thread-70: sb.length: 100Thread-71: sb.length: 200Thread-73: sb.length: 400Thread-72: sb.length: 300Thread-74: sb.length: 500Thread-75: sb.length: 600Thread-77: sb.length: 700Thread-76: sb.length: 800Thread-78: sb.length: 1000Thread-79: sb.length: 1000Test1-7: 1000Thread-80: sb.length: 100Thread-81: sb.length: 200Thread-82: sb.length: 400Thread-84: sb.length: 300Thread-85: sb.length: 500Thread-83: sb.length: 600Thread-88: sb.length: 800Thread-86: sb.length: 700Thread-87: sb.length: 900Thread-89: sb.length: 1000Test1-8: 1000Thread-90: sb.length: 100Thread-91: sb.length: 200Thread-96: sb.length: 421Thread-95: sb.length: 644Thread-98: sb.length: 421Thread-94: sb.length: 1000Thread-97: sb.length: 521Thread-93: sb.length: 1000Thread-92: sb.length: 800Thread-99: sb.length: 700Test1-9: 1000 结果分析由测试结果可以看到，StringBuilder确实是线程非安全的，而StringBuffer是线程安全的。 代码并不能保证添加字符的前后顺序，但是可以判断最终添加的个数（长度）。 注：线程在执行sb.length()时，其他线程仍然在对sb进行append操作，所以打印的并非是100的倍数。但是最后一个线程退出时所打印的值是sb.length()的准确值。 使用反编译工具或者加入java的源码包，然后查看StringBuilder和StringBuffer的源码。 顺便也提一下String的存储方式，String是采用final型的char数组，所以对String的修改操作均返回一个新的String对象，而StringBuilder和StringBuffer使用链式编程风格。 private final char value[]; StringBuilder为jdk5.0时诞生，而StringBuffer则是在jdk1.0时就存在了。两者均是继承实现了AbstractionStringBuilder。 StringBuilder.append(char)，length()，toString()：12345678910111213141516171819202122232425/** * A cache of the last value returned by toString. Cleared * whenever the StringBuffer is modified. */private transient char[] toStringCache;@Overridepublic synchronized StringBuffer append(char c) &#123; toStringCache = null; super.append(c); return this;&#125;@Overridepublic synchronized int length() &#123; return count;&#125;@Overridepublic synchronized String toString() &#123; if (toStringCache == null) &#123; toStringCache = Arrays.copyOfRange(value, 0, count); &#125; return new String(toStringCache, true);&#125; StringBuffer.append(char)，length()，toString()：12345678910111213@Overridepublic StringBuilder append(char c) &#123; super.append(c); return this;&#125;@Overridepublic String toString() &#123; // Create a copy, don't share the array return new String(value, 0, count);&#125;length()方法为父类AbstractStringBuilder.length()。 AbstractStringBuilder.append(char)，length()，toString()：1234567891011121314151617181920212223242526272829303132/*** The value is used for character storage.*/char[] value;/*** The count is the number of characters used.*/int count;@Overridepublic AbstractStringBuilder append(char c) &#123; ensureCapacityInternal(count + 1); value[count++] = c; return this;&#125;private void ensureCapacityInternal(int minimumCapacity) &#123; // overflow-conscious code if (minimumCapacity - value.length &gt; 0) &#123; value = Arrays.copyOf(value, newCapacity(minimumCapacity)); &#125;&#125;@Overridepublic int length() &#123; return count;&#125;@Overridepublic abstract String toString(); 由源码可以看到：1、StringBuffer采用了一个toStringCache，在调用toString()方法时将已有数据复制到toStringCache，而后再使用toStringCache创建一个String对象，而StringBuilder则是直接使用了new String(value, 0, count)。如果StringBuilder被多个线程修改时，那么value和count是不确定的，所以创建String对象时会存在问题。而StringBuffer则有效避免了这个问题。2、StringBuffer中大部分方法都使用了synchronized关键字，来确保同一时刻只有一个进程执行代码块，确保了线程安全，但同时也降低了运行效率。3、问题主要出在append方法，会出现value[count++] = c的覆盖问题。 补充说明可以对执行StringBuilder的部分代码进行局部加锁，可以兼顾线程安全和执行性能。比如：123synchronized(lock)&#123; sb.append(c);&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[琥哥的Java笔记]]></title>
    <url>%2F2016%2F09%2F03-huge-java-note%2F</url>
    <content type="text"><![CDATA[琥哥的Java笔记这篇Java的笔记真不错，总结了Java的虚拟机和类加载机制，也讲了一下Spring中AOP，事务，以及数据库的隔离级别等。附上原博客的地址。另一篇Java的前生今世和知识简概写的也不错。 JVM1.1. 内存模型1.1.1 内存分几部分 （1）程序计数器 可看作当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 在线程创建时创建。执行本地方法时，PC的值为null。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，线程私有。 （2）Java虚拟机栈 线程私有，生命周期同线程。每个方法在执行同时，创建栈帧。用于存储局部变量表、操作数栈、动态链接、方法出口等信息。栈中的局部变量表主要存放一些基本类型的变量（int, short, long, byte, float,double, boolean, char）和对象句柄。 栈中有局部变量表，包含参数和局部变量。 此外，java中没有寄存器，因此所有的参数传递依靠操作数栈。 栈上分配，小对象(一般几十个bytes)，在没有逃逸的情况下，可以直接分配在栈上。(没有逃逸是指，对象只能给当前线程使用，如果多个线程都要用，则不可以，因为栈是线程私有的。)直接分配在栈上，可以自动回收，减轻GC压力。因为栈本身比较小，大对象也不可以分配，会影响性能。 -XX:+DoEscapeAnalysis 启用逃逸分析，若非逃逸则可栈上分配。 （3）本地方法栈 线程私有，与Java虚拟机栈非常相似，区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的 Native 方法（非java语言实现，比如C）服务。Hotspot 直接把本地方法栈和虚拟机栈合二为一。 （4）Java堆 线程共有（可能划分出多个线程私有的分配缓冲区，Thread Local Allow），Java虚拟机管理内存中最大的一块，此区域唯一目的就是存放对象实例，几乎所有对象实例在此区分配，线程共享内存。可细分为新生代和老年代，方便GC。主流虚拟机都是按可扩展实现（通过-Xmx 和 -Xms 控制）。 注意：Java堆是Java代码可及的内存，是留给开发人员使用的；非堆（Non-Heap）就是JVM留给 自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法的代码都在非堆内存中。 关于TLAB Sun Hotspot JVM为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间TLAB（Thread Local Allocation Buffer），其大小由JVM根据运行的情况计算而得，在TLAB上分配对象时不需要加锁，因此JVM在给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配 TLAB仅作用于新生代的Eden Space，因此在编写Java程序时，通常多个小的对象比大的对象分配起来更加高效。详见 Java堆：在虚拟机启动时创建 （5）方法区 线程共有，用于存储已被虚拟机加载的类信息、常量池、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但它却有一个别名Non-Heap（非堆），目的是与Java堆区分开。 注意，通常和永久区(Perm)关联在一起。但也不一定，JDK6时，String等常量信息保存于方法区，JDK7时，移动到了堆。永久代和方法区不是一个概念，但是有的虚拟机用永久代来实现方法区，可以用永久代GC来管理方法区，省去专门写的功夫。 （6）运行时常量池 方法区的一部分，存放编译期生成的各种字面量和符号引用。 （7）直接内存 并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，也可能导致 OOM 异常（内存区域综合&gt;物理内存时）。NIO类，可以使用Native 函数库直接分配堆外内存，然后通过一个存储在Java 堆里面的 DirectByteBuffer 对象作为这块内存的引用进行操作。 类加载时 方法信息保存在一块称为方法区的内存中， 并不随你创建对象而随对象保存于堆中。可参考《深入java虚拟机》前几章。 另参考（他人文章）： 如果instance method也随着instance增加而增加的话，那内存消耗也太大了，为了做到共用一小段内存，Java 是根据this关键字做到的，比如：instance1.instanceMethod(); instance2.instanceMethod(); 在传递给对象参数的时候，Java 编译器自动先加上了一个this参数，它表示传递的是这个对象引用，虽然他们两个对象共用一个方法，但是他们的方法中所产生的数据是私有的，这是因为参数被传进来变成call stack内的entry，而各个对象都有不同call stack，所以不会混淆。其实调用每个非static方法时，Java 编译器都会自动的先加上当前调用此方法对象的参数，有时候在一个方法调用另一个方法，这时可以不用在前面加上this的，因为要传递的对象参数就是当前执行这个方法的对象。 详见 1.1.2 堆溢出、栈溢出原因及实例，线上如何排查（1）栈溢出 递归，容易引起栈溢出stackoverflow；因为方法循环调用，方法调用会不断创建栈帧。 造成栈溢出的几种情况： 1）递归过深 2）数组、List、map数据过大 3 ) 创建过多线程 对于Java虚拟机栈和本地方法栈，Java虚拟机规范规定了两种异常状况： 线程请求深度 &gt; 虚拟机所允许的深度，将抛出StackOverFlowError（SOF）异常；如果虚拟机可动态扩展，且扩展时无法申请到足够的内存，就会抛出OutOfMemoryError（OOM）异常。 （2）堆溢出 如果在堆中没有内存完成实例分配，且堆无法扩展时，将抛出OOM异常。 在方法区也会抛出 OOM 异常。 （3）实例 可使用以下代码造成堆栈溢出： 12345678910111213141516171819202122232425262728package overflow;import java.util.ArrayList;/ Created by hupo.wh on 2016/7/7. /public class MyTest &#123; public void testHeap()&#123; for(;;)&#123; ArrayList list = new ArrayList (2000); &#125; &#125; int num=1; public void testStack()&#123; num++; this.testStack(); &#125; public static void main(String[] args)&#123; MyTest t = new MyTest(); t.testHeap(); //t.testStack(); &#125;&#125; 如下代码会造成OOM堆溢出：123456789101112131415161718192021222324package OOM;import java.util.ArrayList;import java.util.List;/ Created by hupo.wh on 2016/7/15. /public class App1 &#123; static class OOMClass &#123; long[] num = new long[10240]; &#125; public static void main(String[] args) &#123; List&lt;OOMClass&gt; list = new ArrayList&lt;&gt;(); while (true) &#123; list.add(new OOMClass()); &#125; &#125;&#125; 另外，Java虚拟机的堆大小如何设置： 命令行java –Xms128m //JVM占用最小内存–Xmx512m //JVM占用最大内存–XX:PermSize=64m //最小堆大小–XX:MaxPermSize=128m //最大堆大小 1.2. 类加载机制基本上所有的类加载器都是 java.lang.ClassLoader类的一个实例。下面详细介绍这个 Java 类。 1.2.1 java.lang.ClassLoader类介绍java.lang.ClassLoader类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 Java 类，即 java.lang.Class类的一个实例。除此之外，ClassLoader还负责加载 Java 应用所需的资源，如图像文件和配置文件等。 1.2.2 类加载器的树状组织结构Java 中的类加载器大致可以分成两类：一类是系统提供的，另外一类则是由 Java 应用开发人员编写的。系统提供的类加载器主要有下面三个： （1）引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。 BootStrapClassLoader 负责jdk_home/jre/lib目录下的核心 api或 -Xbootclasspath选项指定的jar包加载进来。 （2）扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。 ExtClassLoader 负责jdk_home/jre/lib/ext目录下的jar包或 -Djava.ext.dirs指定目录下的jar包加载进来。 （3）系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。 AppClassLoader 负责java -classpath/-Djava.class.path所指的目录下的类与jar包加载进来,System.getClassLoader获取到的就是这个类加载器。 除了系统提供的类加载器以外，开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。 除了引导类加载器之外，所有的类加载器都有一个父类加载器。getParent()方法可以得到。对于系统提供的类加载器来说，系统类加载器的父类加载器是扩展类加载器，而扩展类加载器的父类加载器是引导类加载器；对于开发人员编写的类加载器来说，其父类加载器是加载此类加载器 Java 类的类加载器。因为类加载器 Java 类如同其它的 Java 类一样，也是要由类加载器来加载的。一般来说，开发人员编写的类加载器的父类加载器是系统类加载器。类加载器通过这种方式组织起来，形成树状结构。树的根节点就是引导类加载器。 1.2.3 双亲委派模型类加载器在尝试自己去查找某个类的字节代码并定义它时，会先代理给其父类加载器，由父类加载器先去尝试加载这个类，依次类推。 在介绍代理模式背后的动机之前，首先需要说明一下 Java 虚拟机是如何判定两个 Java 类是相同的。Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 ClassCastException。 所以才有双亲委派模型，这样的话，可保证加载的类（特别是Object和String这类基础类）是同一个。 1234567891011package classloaderstring;/ Created by hupo.wh on 2016/7/7. /public class String &#123; public java.lang.String toString() &#123; return "这是我自定义的String类的toString方法"; &#125;&#125; 1234567891011121314151617181920212223242526272829package classloaderstring;import java.lang.*;import java.lang.reflect.Method;/ Created by hupo.wh on 2016/7/7. /public class TestString &#123; public static void main(java.lang.String args[]) throws Exception &#123; java.lang.String classDataRootPath = "D:\xiaohua\WhTest\out\production\WhTest\classloader\Sample"; FileSystemClassLoader fscl1 = new FileSystemClassLoader(classDataRootPath); Class&lt;?&gt; class1 = fscl1.loadClass("classloaderstring.String"); Object obj1 = class1.newInstance(); System.out.println(java.lang.String.class.getClassLoader()); System.out.println(class1.getClassLoader()); System.out.println(java.lang.String.class); System.out.println(class1); Method setSampleMethod = class1.getMethod("toString"); System.out.println(setSampleMethod.invoke(obj1)); &#125;&#125; 输出： nullsun.misc.Launcher$AppClassLoader@42a57993class java.lang.Stringclass classloaderstring.String这是我自定义的String类的toString方法 这两个类并不是一个String类，要包名类名+loader一致是不可能的，所以双亲委派模型从外界无法破坏。 注意: 若加载的类能被系统加载器加载到（Sample类在classpath下），则无异常。因为defining class loader都是AppClassLoader 若加载的类不能被系统加载器加载到，则抛异常。此时的 defining class loader 才是自定义的 FileSystemClassLoader 1.2.4 defining loader 和 initiating loader前面提到过类加载器会首先代理给其它类加载器来尝试加载某个类。这就意味着真正完成类的加载工作的类加载器和启动这个加载过程的类加载器，有可能不是同一个。真正完成类的加载工作是通过调用 defineClass来实现的；而启动类的加载过程是通过调用 loadClass来实现的。前者称为一个类的定义加载器（defining loader），后者称为初始加载器（initiating loader）。在 Java 虚拟机判断两个类是否相同的时候，使用的是类的定义加载器。也就是说，哪个类加载器启动类的加载过程并不重要，重要的是最终定义这个类的加载器。两种类加载器的关联之处在于：一个类的定义加载器是它引用的其它类的初始加载器。如类 com.example.Outer引用了类 com.example.Inner，则由类 com.example.Outer的定义加载器负责启动类 com.example.Inner的加载过程。 方法 loadClass()抛出的是 java.lang.ClassNotFoundException异常；方法 defineClass()抛出的是 java.lang.NoClassDefFoundError异常。 类加载器在成功加载某个类之后，会把得到的 java.lang.Class类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载。也就是说，对于一个类加载器实例来说，相同全名的类只加载一次，即 loadClass方法不会被重复调用。 1.2.5 Class.forName 加载Class.forName是一个静态方法，同样可以用来加载类。该方法有两种形式： 1Class.forName(String name, boolean initialize, ClassLoader loader) 和1Class.forName(String className) 第一种形式的参数 name表示的是类的全名；initialize表示是否初始化类；loader表示加载时使用的类加载器。 第二种形式则相当于设置了参数 initialize的值为 true，loader的值为当前类的类加载器。Class.forName的一个很常见的用法是在加载数据库驱动的时候。如 Class.forName(“org.apache.derby.jdbc.EmbeddedDriver”).newInstance()用来加载 Apache Derby 数据库的驱动。 [详见](http://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html 1.2.6 类加载过程从类被加载到虚拟机内存中开始，到卸载出内存为止，类的生命周期包括加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。 参见 其中加载（除了自定义加载）+链接的过程是完全由jvm负责的，什么时候要对类进行初始化工作（加载+链接在此之前已经完成了），jvm有严格的规定（四种情况）： 1.遇到new，getstatic，putstatic，invokestatic这4条字节码指令时，加入类还没进行初始化，则马上对其进行初始化工作。其实就是3种情况：用new实例化一个类时、读取或者设置类的静态字段时（不包括被final修饰的静态字段，因为他们已经被塞进常量池了）、以及执行静态方法的时候。 2.使用java.lang.reflect.的方法对类进行反射调用的时候，如果类还没有进行过初始化，马上对其进行。 3.初始化一个类的时候，如果他的父亲还没有被初始化，则先去初始化其父亲。 4.当jvm启动时，用户需要指定一个要执行的主类（包含static void main(String[] args)的那个类），则jvm会先去初始化这个类。 以上4种预处理称为对一个类进行主动的引用，其余的其他情况，称为被动引用，都不会触发类的初始化。 加载： 在加载阶段，虚拟机主要完成三件事： 1.通过一个类的全限定名来获取定义此类的二进制字节流。 2.将这个字节流所代表的静态存储结构转化为方法区域的运行时数据结构。 3.在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区域数据的访问入口。 验证： 验证阶段作用是保证Class文件的字节流包含的信息符合JVM规范，不会给JVM造成危害。如果验证失败，就会抛出一个java.lang.VerifyError异常或其子类异常。验证过程分为四个阶段： 1.文件格式验证：验证字节流文件是否符合Class文件格式的规范，并且能被当前虚拟机正确的处理。 2.元数据验证：是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言的规范。 3.字节码验证：主要是进行数据流和控制流的分析，保证被校验类的方法在运行时不会危害虚拟机。 4.符号引用验证：符号引用验证发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在解析阶段中发生。 准备： 准备阶段为变量分配内存并设置类变量的初始化。在这个阶段分配的仅为类的变量（static修饰的变量），而不包括类的实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。对非final的变量，JVM会将其设置成“零值”，而不是其赋值语句的值： 1private static int size = 12; 那么在这个阶段，size的值为0，而不是12。 final修饰的类变量将会赋值成真实的值。 解析： 解析过程是将常量池内的符号引用替换成直接引用。主要包括四种类型引用的解析。类或接口的解析、字段解析、方法解析、接口方法解析。 初始化： 在准备阶段，类变量已经经过一次初始化了，在这个阶段，则是根据程序员通过程序制定的计划去初始化类的变量和其他资源。这些资源有static{}块，构造函数，父类的初始化等。 至于使用和卸载阶段阶段，这里不再过多说明，使用过程就是根据程序定义的行为执行，卸载由GC完成 1.3. 垃圾回收 GC1.3.1 引用计数法目前主流的虚拟机都没有使用引用计数法，主要原因就是它很难解决对象之间互相循环引用的问题。 1.3.2 可达性分析算法思想： 通过一系列称为 GC Roots 的对象作为起始点，从这些点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链连接（用图论的话来说，就是从GC Roots到这个对象不可达），证明此对象不可用。 Java语言中，可作为GC Roots的对象包括： （1）虚拟机栈（栈帧中的本地变量表）中引用的对象 （2）方法区中类静态属性引用的对象 （3）方法区中常量引用的对象 （4）本地方法栈中JNI ( 即一般说的Native方法)引用的对象 1.3.3 再谈引用在JDK 1.2之后 ,Java对引用的概念进行了扩充,将引用分为强引用(Strong Reference )、软引用(Soft Reference )、弱引用(Weak Reference )、虚引用(Phantom Reference) 4种 , 引用强度依次逐渐减弱。 强引用 指在程序代码之中普遍存在的,类似“Object obj=new Object ( ) ”这类的引用 ,只要强引用还存在,垃圾收集器永远不会回收掉被引用的对象。 软引用 用来描述一些还有用但并非必需的对象。对于软引用关联着的对象,在系统将要发生内存溢出异常之前,将会把这些对象列进回收范围之中进行二次回收。如果这次回收还没有足够的内存,才会拋出内存溢出异常。在JDK 1.2之后,提供了SoftReference类来实现软引用。 弱引用 也是用来描述非必需对象的,但是它的强度比软引用更弱一些,被弱引用关联的对象只能生存到下一次垃圾收集发生之前。在JDK1.2之后,提供了PhantomReference类来实现虚引用。 虚引用 也称为幽灵引用或者幻影引用,它是最弱的一种引用关系。一个对象是否有虚引用的存在,完全不会对其生存时间构成影响,也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后,提供了PhantomReference类来实现虚引用。 1.3.4 对象回收过程即使在可达性分析算法中不可达的对象,也并非是“非死不可”的 ,这时候它们暂时处于“缓刑” 阶段 ,要真正宣告一个对象死亡 ,至少要经历两次标记过程 如果这个对象被判定为有必要执行finalize() 方法,那么这个对象将会放置在一个叫做 F-Queue的队列之中,并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。 1.3.5 对于方法区（Hotspot虚拟机的永久代）的回收判定一个常量是否是“废弃常量”比较简单,而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”: （1）该类所有的实例都已经被回收,也就是Java堆中不存在该类的任何实例 （2）加载该类的ClassLoader已经被回收 （3）该类对应的java.lang.Class对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法 详情参考：深入理解Java虚拟机第三章 对象存活判定算法 1.3.6 垃圾收集算法1.3.6.1 标记-清除算法 顾名思义，算法分为“标记”和“清除”两个阶段： 首先标记出所有需要回收的对象,在标记完成后统一回收所有被标记的对象,它的标记过程如前 它的主要不足有两个: （1）效率问题,标记和清除两个过程的效率都不高; （2）空间问题,标记清除之后会产生大量不连续的内存碎片,空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时,无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 1.3.6.2 复制算法 将可用内存按容量划分为大小相等的两块,每次只使用其中的一块。当这一块的内存用完了,就将还存活着的对象复制到另外一块上面,然后再把已使用过的内存空间一次清理掉。 适用于对象存活率低的场景（新生代） 这样使得每次都是对整个半区进行内存回收,内存分配时也就不用考虑内存碎片等复杂情况,只要移动堆顶指针 ,按顺序分配内存即可,实现简单,运行高效。只是这种算法的代价是将内存缩小为了原来的一半,未免太高了一点。 将内存分为一块较大的Eden空间和两块较小的Survivor空间 ,每次使用Eden和其中一块Survivor。当回收时,将Eden和Survivor中还存活着的对象一次地复制到另外一块Survivor空间上,最 后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是 8:1,也就是每次新生代中可用内存空间为整个新生代容量的90% ( 80%+10% ) ,只有10% 的内存会被 “浪费”。当然,98%的对象可回收只是一般场景下的数据,我们没有办法保证每次回收都只有不多于10%的对象存活,当Survivor空间不够用时,需要依赖其他内存(这里指老年代)进行分配担保( Handle Promotion ) 。 1.3.6.3 标记-整理算法 适用于对象存活率高的场景（老年代） 复制收集算法在对象存活率较高时就要进行较多的复制操作,效率将会变低。更关键的是 ,如果不想浪费50%的空间,就需要有额外的空间进行分配担保,以应对被使用的内存中所有对象都100%存活的极端情况,所以在老年代一般不能直接选用这种算法。 标记过程类似“标记-清除”算法,但后续步骤不是直接对可回收对象进行清理,而是让所有存活的对象都向一端移动,然后直接清理掉端边界以外的内存，类似于磁盘整理的过程 总的分类如下图： 1.3.7 内存申请过程内存由Perm和Heap组成。其中Heap = {Old + NEW = { Eden , from, to } }。perm用来存放常量等。 heap中分为年轻代(young)和年老代(old)。年轻代又分为Eden,Survivor(幸存区)。Survivor又分为from,to，也可以不只是这两块，切from和to没有先后顺序。其中，old和young区比例可手动分配。 当OLD区空间不够时，JVM会在OLD区进行完全的垃圾收集。完全垃圾收集后，若Survivor及OLD区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现”out of memory”Error。 好文请见 1.4. JVM启动过程JVM工作原理和特点主要是指操作系统装入JVM是通过jdk中Java.exe来完成,通过下面4步来完成JVM环境. 1.创建JVM装载环境和配置 2.装载JVM.dll 3.初始化JVM.dll并挂界到JNIENV(JNI调用接口)实例 4.调用JNIEnv实例装载并处理class类。 [详见](http://blog.csdn.net/ning109314/article/details/10411495 1.5. Class文件结构Class文件的总体结构如下： Class文件 { 文件描述 常量池 类概述 字段表 方法表 扩展信息表} 1.5.1 文件描述（1）magic位、class文件版本号。Magic位很容易记住，数值是0xCAFEBABE。 （2）常量池 存储一组常量，供class文件中其它元素引用。常量池中顺序存储着一组常量，常量在池中的位置称为索引。Class文件中其它结构通过索引来引用常量。常量最主要是被指令引用。编译器将源码编译成指令和常量，图形表示如下： （3）类概述 存储了当前类的总体信息，包括当前类名、所继承的父类、所实现的接口。 （4）字段表 存储了一组字段结构，类中每个字段对应一个字段结构。 字段结构存储了字段的信息，包括字段名、字段修饰符、字段指向的类型等。 （5）方法表 存储了一组方法结构，类中每个方法对应一个方法结构。 方法结构比较复杂，它内部最重要的结构是Code结构。每个非抽象方法的方法结构下有一个Code结构，存储了方法的字节码。 （6）扩展信息表 存储了类级别的可选信息，例如类级别的annotation。（方法、字段级别的annotation分别存储在方法结构、字段结构中） 1.5.2 栈结构我们对于站结构的内部构造，大部分则了解甚少。字节码的执行依赖栈结构，理解栈结构是理解字节码的基础。 栈由帧组成，一个帧对应一个方法调用。一个方法被调用时，一个帧被创建，方法返回时，对应的帧被销毁。 帧存储了方法执行期间的数据，包括变量数据和计算的中间结果。帧由两部分组成，变量表和操作栈。这两个结构是字节码执行期间直接依赖的两个结构 操作栈 顾名思义，操作栈是一个栈结构，即LIFO结构。操作栈位于帧内部，用于存储方法执行期间的中间结果。操作栈在JVM中的角色，类似于寄存器在实体机中的角色。 字节码中绝大多数指令，都是围绕着操作栈执行的。它们或是从其他地方读数据，压入操作栈；或是从操作栈弹数据进行处理；还有的先弹数据，再处理，最会将结果压入操作。 在JVM中，要对数据进行处理，首先要把数据读进操作栈。 int变量求和 要对两个int变量求和，我们先通过iload指令量两个变量压入操作栈，然后执行iadd指令。iadd从操作栈弹出两个int值，求和，然后将结果压入操作栈。 调用方法对象 调用对象方法时，我们需要将被调用对象，调用参数依次压入操作栈，然后执行invokevirtual指令。该指令从操作栈弹出调用参数，被调用对象，执行方法调用。 变量表 变量表用于存储变量数据。 变量表由一组槽组成。一个槽能够存储一个除long、double外其他类型的数据。两个槽能够存储一个long型或double型数据。变量所在的槽在变量表中位置称为变量索引，对于long和double类型，变量索引是第一个槽的位置。 变量在表量表中的顺序是： this、方法参数（从左向右）、其它变量 如果是static方法，则this没有。 示例： 有如下方法：1234void test(int a,int b)&#123; int c=0; long d=0;&#125; 其对应的变量表为： Java基础2.1. 什么是接口 什么是抽象类 区别是什么2.1.1 接口在软件工程中，接口泛指供别人调用的方法或者函数。从这里，我们可以体会到Java语言设计者的初衷，它是对行为的抽象。 接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误），而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。 可以看出，允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。 2.1.2 抽象类抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。抽象方法的声明格式为：1abstract void fun(); 抽象方法必须用abstract关键字进行修饰。如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用abstract关键字修饰。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。 下面要注意一个问题：在《JAVA编程思想》一书中，将抽象类定义为“包含抽象方法的类”，但是后面发现如果一个类不包含抽象方法，只是用abstract修饰的话也是抽象类。也就是说抽象类不一定必须含有抽象方法。个人觉得这个属于钻牛角尖的问题吧，因为如果一个抽象类不包含任何抽象方法，为何还要设计为抽象类？所以暂且记住这个概念吧，不必去深究为什么。 1234567891011/** Created by hupo.wh on 2016/7/7. /public abstract class AbstractClass &#123; public void ab() &#123; System.out.println("Hello"); &#125;&#125; 从这里可以看出，抽象类就是为了继承而存在的，如果你定义了一个抽象类，却不去继承它，那么等于白白创建了这个抽象类，因为你不能用它来做任何事情。对于一个父类，如果它的某个方法在父类中实现出来没有任何意义，必须根据子类的实际需求来进行不同的实现，那么就可以将这个方法声明为abstract方法，此时这个类也就成为abstract类了。 包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法。注意，抽象类和普通类的主要有三点区别： 1）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。 2）抽象类不能用来创建对象； 3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。 在其他方面，抽象类和普通的类并没有区别。 2.1.3 区别2.1.3.1 语法层面上的区别 1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法； 2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的； 3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法； 4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。 2.1.3.2 设计层面上的区别 1）抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。 2）设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。 什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。 详见好文 2.2. 什么是序列化2.2.1 概念序列化，序列化是可以把对象转换成字节流在网络上传输。将一个java对象变成字节流的形式传出去或者从一个字节流中恢复成一个java对象。 个人认为，序列化就是一种思想，能够完成转换，能够转换回来，效率越高越好 序列化(Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。之后可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。 java中的序列化(serialization)机制能够将一个实例对象的状态信息写入到一个字节流中，使其可以通过socket进行传输、或者持久化存储到数据库或文件系统中；然后在需要的时候，可以根据字节流中的信息来重构一个相同的对象。序列化机制在java中有着广泛的应用，EJB、RMI等技术都是以此为基础的。 一般而言，要使得一个类可以序列化，只需简单实现java.io.Serializable接口即可（还要实现无参数的构造方法）。该接口是一个标记式接口，它本身不包含任何内容，实现了该接口则表示这个类准备支持序列化的功能。 2.2.2 序列化与反序列化例程序列化一般有三种形式：默认形式、xml、json格式 默认格式如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package serializable;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;/** Created by hupo.wh on 2016/7/3. /public class SerializeToFlatFile &#123; public static void main(String[] args) &#123; SerializeToFlatFile ser = new SerializeToFlatFile(); ser.savePerson(); ser.restorePerson(); &#125; public void savePerson()&#123; Person myPerson = new Person("Jay", 24); try&#123; FileOutputStream fos = new FileOutputStream("d:\person.txt"); ObjectOutputStream oos = new ObjectOutputStream(fos); System.out.println("Person--Jay,24---Written"); oos.writeObject(myPerson); oos.flush(); oos.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; //@SuppressWarnings("resource") public void restorePerson()&#123; try&#123; FileInputStream fls = new FileInputStream("d:\person.txt"); ObjectInputStream ois = new ObjectInputStream(fls); Person myPerson = (Person)ois.readObject(); System.out.println("\n---------------------\n"); System.out.println("Person --read:"); System.out.println("Name is:"+myPerson.getName()); System.out.println("Age is :"+myPerson.getAge()); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 另两种大同小异 2.2.3 应用场景序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流 [详见](http://blog.csdn.net/scythe666/article/details/51718784 三种情况下需要进行序列化 1、把对象持久化到文件或数据中 2、在网络上传输 3、进行RMI传输对象时 RPC和RMI都是远程调用，属于中间件技术。RMI是针对于java语言的，它使用的是JRMP协议通信，而RPC是更大众化的，使用http协议传输。 其版本号id，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。 常用序列化技术有3种：java seriaizable,hessian,hessian2，以及protobuf 工具有很多，网上有个对比： [详见](http://kb.cnblogs.com/page/515982/ 2.3. 网络通信过程及实践2.3.1 TCP三次握手和四次挥手明显三次握手是建立连接，四次挥手是断开连接，总图如下： 2.3.1.1 握手 （1）首先，Client端发送连接请求报文（SYN=1，seq=client_isn） （2）Server段接受连接后回复ACK报文，并为这次连接分配资源。（SYN=1，seq=client_isn，ack = client_isn+1） （3）Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。（SYN=0，seq=client_isn+1，ack = server_isn+1） 三次握手过程如下图所示： 2.3.1.2 挥手(分手) 注意： 中断连接端可以是Client端，也可以是Server端。 （1）假设Client端发起中断连接请求，也就是发送FIN报文。 （2） Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以 Server 端会先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。 这个时候Client端就进入 FIN_WAIT 状态，继续等待Server端的FIN报文。 （3）当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。 （4）Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送 ACK 后进入 TIME_WAIT 状态，如果 Server 端没有收到 ACK 则可以重传“，Server端收到ACK后，”就知道可以断开连接了”。 Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！ 注意： （1）2个wait状态，FIN_WAIT和TIME_WAIT （2）如果是Server端发起，过程反过来，因为在挥手的时候c和s在对等位置。 2.3.1.3 握手挥手状态图 Client端所经历的状态如下： Server端所经历的过程如下： 2.3.1.4 注意问题 1、在TIME_WAIT状态中，如果TCP client端最后一次发送的ACK丢失了，它将重新发送。TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。 2、为什么连接的时候是三次握手，关闭的时候却是四次握手？ 答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 3、为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。 2.3.1.5 附：报文详解 TCP报文中的SYN,FIN,ACK,PSH,RST,URG TCP的三次握手是怎么进行的：发送端发送一个SYN=1，ACK=0标志的数据包给接收端，请求进行连接，这是第一次握手；接收端收到请求并且允许连接的话，就会发送一个SYN=1，ACK=1标志的数据包给发送端，告诉它，可以通讯了，并且让发送端发送一个确认数据包，这是第二次握手；最后，发送端发送一个SYN=0，ACK=1的数据包给接收端，告诉它连接已被确认，这就是第三次握手。之后，一个TCP连接建立，开始通讯。 SYN：同步标志 同步序列编号(Synchronize Sequence Numbers)栏有效。该标志仅在三次握手建立TCP连接时有效。它提示TCP连接的服务端检查序列编号，该序列编号为TCP连接初始端(一般是客户端)的初始序列编号。在这里，可以把 TCP序列编号看作是一个范围从0到4，294，967，295的32位计数器。通过TCP连接交换的数据中每一个字节都经过序列编号。在TCP报头中的序列编号栏包括了TCP分段中第一个字节的序列编号。 ACK：确认标志 确认编号(Acknowledgement Number)栏有效。大多数情况下该标志位是置位的。TCP报头内的确认编号栏内包含的确认编号(w+1，Figure-1)为下一个预期的序列编号，同时提示远端系统已经成功接收所有数据。 RST：复位标志 复位标志有效。用于复位相应的TCP连接。 URG：紧急标志 紧急(The urgent pointer) 标志有效。紧急标志置位 PSH：推标志 该标志置位时，接收端不将该数据进行队列处理，而是尽可能快将数据转由应用处理。在处理 telnet 或 rlogin 等交互模式的连接时，该标志总是置位的。 FIN：结束标志 带有该标志置位的数据包用来结束一个TCP回话，但对应端口仍处于开放状态，准备接收后续数据。 TCP的几个状态对于我们分析所起的作用 在TCP层，有个FLAGS字段，这个字段有以下几个标识：SYN, FIN, ACK, PSH, RST, URG.其中，对于我们日常的分析有用的就是前面的五个字段。它们的含义是：SYN表示建立连接，FIN表示关闭连接，ACK表示响应，PSH表示有 DATA数据传输，RST表示连接重置。其中，ACK是可能与SYN，FIN等同时使用的，比如SYN和ACK可能同时为1，它表示的就是建立连接之后的响应，如果只是单个的一个SYN，它表示的只是建立连接。 TCP的几次握手就是通过这样的ACK表现出来的。但SYN与FIN是不会同时为1的，因为前者表示的是建立连接，而后者表示的是断开连接。RST一般是在FIN之后才会出现为1的情况，表示的是连接重置。一般地，当出现FIN包或RST包时，我们便认为客户端与服务器端断开了连接；而当出现SYN和SYN＋ACK包时，我们认为客户端与服务器建立了一个连接。PSH为1的情况，一般只出现在 DATA内容不为0的包中，也就是说PSH为1表示的是有真正的TCP数据包内容被传递。TCP的连接建立和连接关闭，都是通过请求－响应的模式完成的。 [详见](http://blog.csdn.net/scythe666/article/details/50967632 tcp的状态 http://www.cnblogs.com/qlee/archive/2011/07/12/2104089.html http://www.2cto.com/net/201209/157585.html 2.3.2 Socket通信套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。 套接字对是一个四元组，（local ip, local port, remote ip, remote port），通过这一四元组，唯一确定了网络通信的两端（两个进程或线程），ip地址确定主机，端口确定进程。 经典的在同一台主机上两个进程或线程之间的通信通过以下三种方法 管道通信（Pipes） 消息队列（Message queues） 共享内存通信（Shared memory） 这里有许多其他的方法，但是上面三中是非常经典的进程间通信。 [详见](http://blog.csdn.net/violet_echo_0908/article/details/49539593 socket编程实例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/////TalkClient .javapackage socket;import java.io.*;import java.net.*;/** Created by hupo.wh on 2016/7/8. /public class TalkClient &#123; public static void main(String args[]) &#123; try &#123; Socket socket = new Socket("10.63.37.140", 4700); //向本机的4700端口发出客户请求 BufferedReader sin = new BufferedReader(new InputStreamReader(System.in)); //由系统标准输入设备构造BufferedReader对象 PrintWriter os = new PrintWriter(socket.getOutputStream()); //由Socket对象得到输出流，并构造PrintWriter对象 BufferedReader is = new BufferedReader(new InputStreamReader(socket.getInputStream())); //由Socket对象得到输入流，并构造相应的BufferedReader对象 String readline; readline = sin.readLine(); //从系统标准输入读入一字符串 while (!readline.equals("bye")) &#123; //若从标准输入读入的字符串为 "bye"则停止循环 os.println(readline); //将从系统标准输入读入的字符串输出到Server os.flush(); //刷新输出流，使Server马上收到该字符串 System.out.println("Client:" + readline); //在系统标准输出上打印读入的字符串 System.out.println("Server:" + is.readLine()); //从Server读入一字符串，并打印到标准输出上 readline = sin.readLine(); //从系统标准输入读入一字符串 &#125; //继续循环 os.close(); //关闭Socket输出流 is.close(); //关闭Socket输入流 socket.close(); //关闭Socket &#125; catch (Exception e) &#123; System.out.println("Error" + e); //出错，则打印出错信息 &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/////TalkServer.javapackage socket;/** Created by hupo.wh on 2016/7/8. /import java.io.;import java.net.;public class TalkServer&#123; public static void main(String args[]) &#123; try&#123; ServerSocket server=null; try&#123; server=new ServerSocket(4700); //创建一个ServerSocket在端口4700监听客户请求 &#125;catch(Exception e) &#123; System.out.println("can not listen to:"+e); //出错，打印出错信息 &#125; Socket socket=null; try&#123; socket=server.accept(); //使用accept()阻塞等待客户请求，有客户 //请求到来则产生一个Socket对象，并继续执行 System.out.println("客户端成功连接..."); &#125;catch(Exception e) &#123; System.out.println("Error."+e); //出错，打印出错信息 &#125; String line; BufferedReader is=new BufferedReader(new InputStreamReader(socket.getInputStream())); //由Socket对象得到输入流，并构造相应的BufferedReader对象 PrintWriter os = new PrintWriter(socket.getOutputStream()); //由Socket对象得到输出流，并构造PrintWriter对象 BufferedReader sin=new BufferedReader(new InputStreamReader(System.in)); //由系统标准输入设备构造BufferedReader对象 System.out.println("Client:"+is.readLine()); //在标准输出上打印从客户端读入的字符串 line=sin.readLine(); //从标准输入读入一字符串 while(!line.equals("bye"))&#123; //如果该字符串为 "bye"，则停止循环 os.println(line); //向客户端输出该字符串 os.flush(); //刷新输出流，使Client马上收到该字符串 System.out.println("Server:"+line); //在系统标准输出上打印读入的字符串 System.out.println("Client:"+is.readLine()); //从Client读入一字符串，并打印到标准输出上 line=sin.readLine(); //从系统标准输入读入一字符串 &#125; //继续循环 os.close(); //关闭Socket输出流 is.close(); //关闭Socket输入流 socket.close(); //关闭Socket server.close(); //关闭ServerSocket &#125;catch(Exception e)&#123; System.out.println("Error:"+e); //出错，打印出错信息 &#125; &#125; &#125;&#125; [详见](http://www.cnblogs.com/linzheng/archive/2011/01/23/1942328.html 2.3.3 HttpHTTP协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系，对http服务器来说，它并不知道这两个请求来自同一个客户端。 为了解决这个问题， Web程序引入了Cookie机制来维护状态. Http响应 在接收和解释请求消息后，服务器返回一个HTTP响应消息。 HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文 1、状态行格式如下： HTTP-Version Status-Code Reason-Phrase CRLF其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：1xx：指示信息–表示请求已接收，继续处理2xx：成功–表示请求已被成功接收、理解、接受3xx：重定向–要完成请求必须进行更进一步的操作4xx：客户端错误–请求有语法错误或请求无法实现5xx：服务器端错误–服务器未能实现合法的请求常见状态代码、状态描述、说明：200 OK //客户端请求成功400 Bad Request //客户端请求有语法错误，不能被服务器所理解401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用403 Forbidden //服务器收到请求，但是拒绝提供服务404 Not Found //请求资源不存在，eg：输入了错误的URL500 Internal Server Error //服务器发生不可预期的错误503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常eg：HTTP/1.1 200 OK （CRLF） 2、响应报头 3、响应正文就是服务器返回的资源的内容 [详见]（1）http://www.cnblogs.com/li0803/archive/2008/11/03/1324746.html （2）http://kb.cnblogs.com/page/130970/#statelesshttp （3）http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386832653051fd44e44e4f9e4ed08f3e5a5ab550358d000 2.4. 什么是线程 java线程池运行过程及实践（Executors）一个进程包括多个线程，但是这些线程是共同享有进程占有的资源和地址空间的。 进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位。 进程可能包括多个线程。 好文：http://www.oschina.net/question/565065_86540 2.4.1 Volatile线程的工作内存中保存了被该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量（包括volatile的底层实现）。 这里的主内存、工作内存和Java堆栈、方法区不是一个层次内存划分，基本上没有关系。 如果要勉强对应：主内存对应Java堆中对象实例数据部分，工作内存对应于虚拟机栈中部分区域。 从更低层次来说，主内存就直接对应物理硬件内存，而为了优化，工作内存优先储存于寄存器和高速缓存中。 volatile可以说是Java虚拟机提供的最轻量级的同步机制。 当一个变量定义为volatile以后，它将具备两种属性： （1）保证此变量对所有线程的可见性 123456789101112131415161718192021222324252627282930313233343536373839404142volatile的错误用法：package MultiThread;/** Created by hupo.wh on 2016/7/8. /public class VolatileTest &#123; private static final int THREAD_NUM =20; public static volatile int race= 0; public static void increase()&#123; race++ ; &#125; public static void main(String[] args) &#123; Thread[] threads = new Thread[THREAD_NUM]; for (int i = 0; i &lt; THREAD_NUM; i++) &#123; threads[i] = new Thread(new Runnable() &#123; @Override public void run() &#123; for(int i=0;i&lt;10000;i++)&#123; //System.out.println("race == "+race); increase(); &#125; &#125; &#125;); threads[i].start(); &#125; while(Thread.activeCount()&gt;2)&#123; Thread.yield(); &#125; System.out.println(race); &#125;&#125; 输出的正确答案应该是200000，但是每次输出都小于200000，并发失败的问题在于increase()方法。用javap发编译看一下发现就increase()方法在Class中文件有四条字节码组成。 volatile变量只能保证可见性，当不符合一下规则是还是使用synchronized或java.util.concurrent中的原子类。 1.运算结果并不依赖变量的当前值，或者能够确保单一的线程修改变量的 2.变量不需要与其他的状态变量共同参与不变约束。 正确用法： 123456789101112131415161718192021222324package MultiThread;/** Created by hupo.wh on 2016/7/8. /public class VolatileShutdown &#123; volatile boolean shutdownRequested; public void shutdown() &#123; shutdownRequested = true; &#125; public void doWork() &#123; while (!shutdownRequested) &#123; //do stuff &#125; &#125;&#125; （2）使用volatile变量的第二个语义是禁止指令重排序优化 2.4.2 原子性、可见性与有序性（1）原子性 保证read、load、assign、use、store和write操作是原子的 （2）可见性 当一个线程修改了共享变量的值，其他线程可以立即得知这个修改 （3）有序性 本线程观察，所有的操作都是有序的，如果在一个线程中观察另一个线程，所有操作都是无序的（指令重排序和工作内存与主内存同步延迟）。 2.4.3 Lock vs SynchronizedSynchronized关键字经过编译以后，会在同步块前后分别形成monitorenter和monitorexit这两个字节码指令。Synchronized 使用[详见](http://blog.csdn.net/luoweifu/article/details/46613015 主要相同点:lock能完成synchronized所实现的所有功能 主要不同点:lock有比synchronized更精确的线程语义和更好的性能.synchronized会自动释放锁,而Lock一定要求程序员手工释放,并且必须在finally从句中释放. 1、ReentrantLock 拥有Synchronized相同的并发性和内存语义，此外还多了 锁投票，定时锁等候和中断锁等候 线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定， 如果使用 synchronized ，如果A不释放，B将一直等下去，不能被中断 如果 使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情 ReentrantLock获取锁定与三种方式：a) lock(), 如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁b) tryLock(), 如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false；c)tryLock(long timeout,TimeUnit unit)， 如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；d) lockInterruptibly:如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程被别的线程中断 2、synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定，但是使用Lock则不行，lock是通过代码实现的，要保证锁定一定会被释放，就必须将unLock()放到finally{}中 3、在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态； 2.4.4 threadlocalThreadLocal 不是用于解决共享变量的问题的，不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制，理解这点对正确使用ThreadLocal至关重要。 我们先看一个简单的例子： 123456789101112131415161718192021222324252627282930313233public class ThreadLocalTest &#123; //创建一个Integer型的线程本地变量 public static final ThreadLocal&lt;Integer&gt; local = new ThreadLocal&lt;Integer&gt;() &#123; @Override protected Integer initialValue() &#123; return 0; &#125; &#125;; public static void main(String[] args) throws InterruptedException &#123; Thread[] threads = new Thread[5]; for (int j = 0; j &lt; 5; j++) &#123; threads[j] = new Thread(new Runnable() &#123; @Override public void run() &#123; //获取当前线程的本地变量，然后累加5次 int num = local.get(); for (int i = 0; i &lt; 5; i++) &#123; num++; &#125; //重新设置累加后的本地变量 local.set(num); System.out.println(Thread.currentThread().getName() + " : "+ local.get()); &#125; &#125;, "Thread-" + j); &#125; for (Thread thread : threads) &#123; thread.start(); &#125; &#125;&#125; 运行后结果： Thread-0 : 5 Thread-4 : 5 Thread-2 : 5 Thread-1 : 5 Thread-3 : 5 我们看到，每个线程累加后的结果都是5，各个线程处理自己的本地变量值，线程之间互不影响。 [详见](http://my.oschina.net/clopopo/blog/149368 2.4.5 java线程池 Executor框架要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在Executors类里面提供了一些静态工厂，生成一些常用的线程池。 （1）newSingleThreadExecutor 创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 123456789101112131415MyThread.javapackage threadpool;/** Created by hupo.wh on 2016/7/2. /public class WhThread extends Thread&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + "正在执行..."); &#125;&#125; TestSingleThreadExecutor.java12345678910111213141516171819202122232425262728293031323334package threadpool;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** Created by hupo.wh on 2016/7/3. /public class TestSingleThreadExecutor &#123; public static void main(String[] args) &#123; //创建一个可重用固定线程数的线程池 ExecutorService pool = Executors. newSingleThreadExecutor(); //创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口 Thread t1 = new WhThread(); Thread t2 = new WhThread(); Thread t3 = new WhThread(); Thread t4 = new WhThread(); Thread t5 = new WhThread(); //将线程放入池中进行执行 pool.execute(t1); pool.execute(t2); pool.execute(t3); pool.execute(t4); pool.execute(t5); //关闭线程池 pool.shutdown(); &#125;&#125; 输出结果： pool-1-thread-1正在执行… pool-1-thread-1正在执行… pool-1-thread-1正在执行… pool-1-thread-1正在执行… pool-1-thread-1正在执行… （2）newFixedThreadPool 创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 12//创建一个可重用固定线程数的线程池ExecutorService pool = Executors.newFixedThreadPool(2); （3）newCachedThreadPool 创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程， 那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 12//创建一个可重用固定线程数的线程池ExecutorService pool = Executors.newCachedThreadPool(); （4）newScheduledThreadPool 创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。 123456789101112131415161718192021222324252627282930313233package threadpool;import java.util.concurrent.ScheduledThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** Created by hupo.wh on 2016/7/3. /public class TestSingleThreadExecutor &#123; public static void main(String[] args) &#123; ScheduledThreadPoolExecutor exec = new ScheduledThreadPoolExecutor(1); exec.scheduleAtFixedRate(new Runnable() &#123;//每隔一段时间就触发异常 @Override public void run() &#123; System.out.println("================"); throw new RuntimeException(); &#125; &#125;, 1000, 5000, TimeUnit.MILLISECONDS); exec.scheduleAtFixedRate(new Runnable() &#123;//每隔一段时间打印系统时间，证明两者是互不影响的 @Override public void run() &#123; System.out.println(System.nanoTime()); &#125; &#125;, 1000, 2000, TimeUnit.MILLISECONDS); &#125;&#125; 2.5. ThreadPoolExecutor构造函数jvm本身提供的concurrent并发包，提供了高性能稳定方便的线程池，可以直接使用。 ThreadPoolExecutor是核心类，都是由它与3种Queue结合衍生出来的。 BlockingQueue + LinkedBlockingQueue + SynchronousQueue ThreadPoolExecutor的完整构造方法的签名是： 1ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler); corePoolSize - 池中所保存的线程数，包括空闲线程。 maximumPoolSize-池中允许的最大线程数。 keepAliveTime - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。 unit - keepAliveTime 参数的时间单位。 workQueue - 执行前用于保持任务的队列。此队列仅保持由 execute方法提交的 Runnable任务。 threadFactory - 执行程序创建新线程时使用的工厂。 handler - 由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序。 ThreadPoolExecutor是Executors类的底层实现。 在JDK帮助文档中，有如此一段话： “强烈建议程序员使用较为方便的Executors工厂方法Executors.newCachedThreadPool()（无界线程池，可以进行自动线程回收）、Executors.newFixedThreadPool(int)（固定大小线程池）Executors.newSingleThreadExecutor()（单个后台线程） 2.6. 线程池实现原理先从 BlockingQueue workQueue 这个入参开始说起。在JDK中，其实已经说得很清楚了，一共有三种类型的queue。 所有BlockingQueue 都可用于传输和保持提交的任务。可以使用此队列与池大小进行交互： （1）如果运行的线程少于 corePoolSize，则 Executor始终首选添加新的线程，而不进行排队。（如果当前运行的线程小于corePoolSize，则任务根本不会存放，添加到queue中，而是直接抄家伙（thread）开始运行） （2）如果运行的线程等于或多于 corePoolSize，则 Executor始终首选将请求加入队列，而不添加新的线程。 （3）如果无法将请求加入队列，则创建新的线程，除非创建此线程超出maximumPoolSize，在这种情况下，任务将被拒绝。 线程的状态有 new、runnable、running、waiting、timed_waiting、blocked、dead 一旦线程调用了start 方法，线程就转到Runnable 状态，注意，如果线程处于Runnable状态，它也有可能不在运行，这是因为还有优先级和调度问题。 2.7. 排队策略排队有三种通用策略： （1）直接提交。工作队列的默认选项是 SynchronousQueue，ExecutorService newCachedThreadPool()：无界线程池，可以进行自动线程回收，所以我们可以发现maximumPoolSize为big big。 （2）无界队列。使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。 （3）有界队列。当使用有限的 maximumPoolSizes时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。 keepAliveTime jdk中的解释是：当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。 有点拗口，其实这个不难理解，在使用了“池”的应用中，大多都有类似的参数需要配置。比如数据库连接池，DBCP中的maxIdle，minIdle参数。 什么意思？接着上面的解释，后来向老板派来的工人始终是“借来的”，俗话说“有借就有还”，但这里的问题就是什么时候还了，如果借来的工人刚完成一个任务就还回去，后来发现任务还有，那岂不是又要去借？这一来一往，老板肯定头也大死了。 合理的策略：既然借了，那就多借一会儿。直到“某一段”时间后，发现再也用不到这些工人时，便可以还回去了。这里的某一段时间便是keepAliveTime的含义，TimeUnit为keepAliveTime值的度量。 详参:http://www.oschina.net/question/565065_86540 2.8. java反射机制实践[详见](http://blog.csdn.net/scythe666/article/details/51704809 反射可以拿到一个类所有的方法和属性，包括父类和接口。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package classloader;import java.lang.reflect.Method;/** Created by hupo.wh on 2016/7/7. /public class App3 &#123; private final static int size = 12; public static void main(String args[]) throws ClassNotFoundException &#123; //System.out.println(size); Class clazz = Class.forName("classloader.Child"); Method[] methods = clazz.getMethods(); for (int i=0;i&lt;methods.length;++i) &#123; System.out.println(methods[i]); &#125; &#125;&#125;interface Test&#123; int te = 0; public void te();&#125;abstract class Parent &#123; int pa; public void pa() &#123; System.out.println("this is parent"); &#125;&#125;class Child extends Parent implements Test&#123; int ch; public void ch() &#123; System.out.println("this is child"); &#125; @Override public void te() &#123; &#125;&#125; 输出： public void classloader.Child.ch()public void classloader.Child.te()public void classloader.Parent.pa()public final void java.lang.Object.wait() throws java.lang.InterruptedExceptionpublic final void java.lang.Object.wait(long,int) throws java.lang.InterruptedExceptionpublic final native void java.lang.Object.wait(long) throws java.lang.InterruptedExceptionpublic boolean java.lang.Object.equals(java.lang.Object)public java.lang.String java.lang.Object.toString()public native int java.lang.Object.hashCode()public final native java.lang.Class java.lang.Object.getClass()public final native void java.lang.Object.notify()public final native void java.lang.Object.notifyAll() 设计模式3.1. 单例模式123456789101112//懒汉式单例类.在第一次调用的时候实例化自己 public class Singleton &#123; private Singleton() &#123;&#125; private static Singleton single=null; //静态工厂方法 public static Singleton getInstance() &#123; if (single == null) &#123; single = new Singleton(); &#125; return single; &#125;&#125; 线程安全+懒加载实现： 123456789public class TestSingleton &#123; private TestSingleton() &#123;&#125; private static class SingletonHolder &#123; static TestSingleton testSingleton = new TestSingleton(); &#125; public TestSingleton getInstance() &#123; return SingletonHolder.testSingleton; &#125;&#125; [详见](http://blog.csdn.net/jason0539/article/details/23297037 3.2. 原型模式类图： 原型模式主要用于对象的复制，它的核心是就是类图中的原型类Prototype。Prototype类需要具备以下两个条件： （1）实现Cloneable接口。在java语言有一个Cloneable接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用clone方法。在java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出CloneNotSupportedException异常。 （2）重写Object类中的clone方法。Java中，所有类的父类都是Object类，Object类中有一个clone方法，作用是返回对象的一个拷贝，但是其作用域protected类型的，一般的类无法调用，因此，Prototype类需要将clone方法的作用域修改为public类型。 原型模式是一种比较简单的模式，也非常容易理解，实现一个接口，重写一个方法即完成了原型模式。在实际应用中，原型模式很少单独出现。经常与其他模式混用，他的原型类Prototype也常用抽象类来替代。 123456789101112131415161718192021222324252627class Prototype implements Cloneable &#123; public Prototype clone()&#123; Prototype prototype = null; try&#123; prototype = (Prototype)super.clone(); &#125;catch(CloneNotSupportedException e)&#123; e.printStackTrace(); &#125; return prototype; &#125;&#125;class ConcretePrototype extends Prototype&#123; public void show()&#123; System.out.println("原型模式实现类"); &#125;&#125;public class Client &#123; public static void main(String[] args)&#123; ConcretePrototype cp = new ConcretePrototype(); for(int i=0; i&lt; 10; i++)&#123; ConcretePrototype clonecp = (ConcretePrototype)cp.clone(); clonecp.show(); &#125; &#125;&#125; [详见](http://blog.csdn.net/jason0539/article/details/23158081 3.3. 动态代理模式一般的设计模式中的代理模式指的是静态代理，但是Java实现了动态代理 静态代理的每一个代理类只能为一个或一组接口服务，这样一来程序开发中必然会产生过多的代理，而且，所有的代理操作除了调用的方法不一样之外，其他的操作都一样，则此时肯定是重复代码。解决这一问题最好的做法是可以通过一个代理类完成全部的代理功能，那么此时就必须使用动态代理完成。 来看一下动态代理： JDK动态代理中包含一个类和一个接口： InvocationHandler接口：123public interface InvocationHandler &#123; public Object invoke(Object proxy,Method method,Object[] args) throws Throwable;&#125; 参数说明：123Object proxy：指被代理的对象。Method method：要调用的方法Object[] args：方法调用时所需要的参数 可以将InvocationHandler接口的子类想象成一个代理的最终操作类，替换掉ProxySubject。 Proxy类： Proxy类是专门完成代理的操作类，可以通过此类为一个或多个接口动态地生成实现类，此类提供了如下的操作方法：12public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h) throws IllegalArgumentException 参数说明： 123ClassLoader loader：类加载器Class&lt;?&gt;[] interfaces：得到全部的接口InvocationHandler h：得到InvocationHandler接口的子类实例 Ps:类加载器 在Proxy类中的newProxyInstance（）方法中需要一个ClassLoader类的实例，ClassLoader实际上对应的是类加载器，在Java中主要有一下三种类加载器; Booststrap ClassLoader：此加载器采用C++编写，一般开发中是看不到的； Extendsion ClassLoader：用来进行扩展类的加载，一般对应的是jre\lib\ext目录中的类; AppClassLoader：(默认)加载classpath指定的类，是最常使用的是一种加载器。 动态代理 与静态代理类对照的是动态代理类，动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写它的源代码。动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java 反射机制可以生成任意类型的动态代理类。java.lang.reflect 包中的Proxy类和InvocationHandler 接口提供了生成动态代理类的能力。 1234567891011121314151617181920212223242526272829303132/////BookFacade.javapackage jdkproxy;/** Created by hupo.wh on 2016/7/4. /public interface BookFacade &#123; public void addBook(); public void sayHello();&#125;/////BookFacadeImpl.javapackage jdkproxy;/** Created by hupo.wh on 2016/7/4. /public class BookFacadeImpl implements BookFacade &#123; @Override public void addBook() &#123; System.out.println("增加图书方法..."); &#125; public void sayHello()&#123; System.out.println("Hello"); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142/////BookFacadeProxy.javapackage jdkproxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** jdk动态代理类 Created by hupo.wh on 2016/7/4. /public class BookFacadeProxy implements InvocationHandler &#123; private Object target; / 绑定委托对象并返回一个代理类 @param target @return / public Object bind(Object target) &#123; this.target = target; //取得代理对象 return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); //要绑定接口(这是一个缺陷，cglib弥补了这一缺陷) &#125; @Override / 调用方法，自动调用 / public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result=null; System.out.println("事物开始"); //执行方法 result=method.invoke(target, args); System.out.println("事物结束"); return result; &#125;&#125; 1234567891011121314151617/////App1.javapackage jdkproxy;/ Created by hupo.wh on 2016/7/4. /public class App1 &#123; public static void main(String[] args) &#123; BookFacadeProxy proxy = new BookFacadeProxy(); BookFacade bookProxy = (BookFacade) proxy.bind(new BookFacadeImpl()); bookProxy.addBook(); bookProxy.sayHello(); &#125;&#125; 但是，JDK的动态代理依靠接口实现，如果有些类并没有实现接口，则不能使用JDK代理，这就要使用cglib动态代理了。 Cglib动态代理 JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。 [详见](http://www.cnblogs.com/jqyp/archive/2010/08/20/1805041.html Spring4.1. 什么是IOCIOC（inverse of controll）控制反转（控制权反转），就是把创建对象（bean），和维护对象（bean）的关系和权力从程序中转移到spring的容器（applicationContext.xml），而程序本身不再关心、维护对象创建和关系 4.2. 什么是AOPaop( aspect oriented programming ) 面向切面(方面)编程,是对所有对象或者是一类对象编程,核心是( 在不增加代码的基础上， 还增加新功能 )，aop实现原理是代理。 面向切面 spring( -&gt;aop) 面向n多对象编程，面向一批对象编程 交叉点，交叉功能放入的过程叫做织入 使用比较底层的ProxyFactoryBean编程说明: 步骤: 定义接口 编写对象(被代理对象=目标对象) 编写通知（前置通知目标方法调用前调用） 在beans.xml文件配置 4.1 配置 被代理对象=目标对象 4.2 配置通知 4.3 配置代理对象 是 ProxyFactoryBean的对象实例 4.3.1 代理接口集 4.3.2 织入通知 4.3.3 配置被代理对象 1.切面(aspect):要实现的交叉功能，是系统模块化的一个切面或领域。如日志记录。 2.连接点:应用程序执行过程中插入切面的地点，可以是方法调用，异常抛出，或者要修改的 字段。 3.通知:切面的实际实现，他通知系统新的行为。如在日志通知包含了实 现日志功能的代码，如向日志文件写日志。通知在连接点插入到应用系统中。 4.切入点:定义了通知应该应用在哪些连接点，通知可以应用到AOP框架支持的任何连接点。 5.引入:为类添加新方法和属性。 6.目标对象:被通知的对象。既可以是你编写的类也可以是第三方类。 7.代理:将通知应用到目标对象后创建的对象，应用系统的其他部分不用为了支持代理对象而 改变。 8.织入:将切面应用到目标对象从而创建一个新代理对象的过程。织入发生在目标 对象生命周期的多个点上： 编译期：切面在目标对象编译时织入.这需要一个特殊的编译器. 类装载期：切面在目标对象被载入JVM时织入.这需要一个特殊的类载入器. 运行期：切面在应用系统运行时织入. 提问: 说spring的aop中，当你通过代理对象去实现aop的时候，获取的ProxyFactoryBean是什么类型？ 答: 返回的是一个代理对象,如果目标对象实现了接口，则spring使用jdk 动态代理技术,如果目标对象没有实现接口，则spring使用CGLIB技术. [详见](http://blog.csdn.net/scythe666/article/details/51727234 4.3. spring事务管理事务指的是逻辑上的一组操作，这组操作要么全部成功，要么全部失败。 一般的事务指的都是数据库事务，但是广义事务的定义不局限于数据库事务。 事务有4大特性，即 ACID。 ACID，指数据库事务正确执行的四个基本要素的缩写。包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。一个支持事务（Transaction）的数据库，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性，交易过程极可能达不到交易方的要求。 4.3.1. 原子性事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 4.3.2. 一致性事务前后数据的完整性必须保证一致 比如还是刚刚A给B转账的例子，那么A给B转账结束后，总金额不变。 4.3.3. 隔离性多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要互相隔离。 隔离性非常重要，如果不考虑隔离性，就可能发生：脏读、不可重复读、幻读的问题 4.3.3.1. 脏读 一个事务读取了另一个事务改写但还未提交的数据，如果这些数据被回滚，则读到的数据无效。 4.3.3.2. 不可重复读在同一事务中，多次读取同一数据返回的结果不同。 4.3.3.3. 幻读 一个事务读取了几行记录后，另一个事务插入一些记录。后来的查询中，第一个事务就会发现有些原来没有的记录。 当然，这些问题是有办法避免的，有隔离级别来限制，后面做解释。 4.3.4. 持久性一个事务一旦提交，它对数据库中的数据的改变就是永久性的，即使数据库发生故障也不应该对其有任何影响 4.3.5. 事务的隔离级别（4种）事务的隔离级别是为了防止脏读、不可重复读、幻读问题的发生，具体分成四种，如下： Spring有一个default隔离级别，底层数据库用的哪个隔离级别，spring就用什么隔离级别 MySQL用的是repeatable_read Oracle用的是read_committed 有一个更加直观的表格如下： spring中的事务隔离级别配置如下： 4.3.6. 模板事务跟标注事务的区别及运理原理4.3.6.1. 编程式事务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354applicationContext.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 引入 外部属性文件--&gt; &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; &lt;!-- 配置c3p0连接池 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;" /&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/bean&gt; &lt;!-- 配置业务层类 --&gt; &lt;bean id="accountService" class="com.wanghubill.AccountServiceImpl"&gt; &lt;property name="accoutDao" ref="accountDao" /&gt; &lt;!-- 注入事务管理的模板 --&gt; &lt;property name="transactionTemplate" ref="transactionTemplate" /&gt; &lt;/bean&gt; &lt;!-- 配置DAO类 --&gt; &lt;bean id="accountDao" class="com.wanghubill.AccoutDaoImpl"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 配置事务管理类 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 配置事务管理的模板：spring为了简化事务管理的代码而提供的类 --&gt; &lt;bean id="transactionTemplate" class="org.springframework.transaction.support.TransactionTemplate" &gt; &lt;property name="transactionManager" ref="transactionManager" /&gt; &lt;/bean&gt;&lt;/beans&gt; 12345678910111213141516171819AccountService.javapackage com.wanghubill;/ @author hupo.wh /public interface AccountService &#123; /** @param out @param in @param money / public void transfer(String out, String in, Double money);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849AccountServiceImpl.javapackage com.wanghubill;import org.springframework.transaction.TransactionStatus;import org.springframework.transaction.support.TransactionCallback;import org.springframework.transaction.support.TransactionCallbackWithoutResult;import org.springframework.transaction.support.TransactionTemplate;/ @author hupo.wh */public class AccountServiceImpl implements AccountService &#123; private AccountDao accoutDao; public void setTransactionTemplate(TransactionTemplate transactionTemplate) &#123; this.transactionTemplate = transactionTemplate; &#125; //注入事务管理的模板 private TransactionTemplate transactionTemplate; public void setAccoutDao(AccountDao accoutDao) &#123; this.accoutDao = accoutDao; &#125; public void transfer(final String out, final String in, final Double money) &#123; System.out.println(&quot;enter transfer()&quot;);// accoutDao.outMoney(out, money);// //int i=1/0;// accoutDao.inMoney(in, money); transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123; protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) &#123; accoutDao.outMoney(out, money); int i=1/0; accoutDao.inMoney(in, money); &#125; &#125;); &#125;&#125; 12345678910111213141516AccountDao.javapackage com.wanghubill;/ @author hupo.wh /public interface AccountDao &#123; void outMoney(String out, Double money); void inMoney(String in, Double money);&#125; 123456789101112131415161718192021AccoutDaoImpl.javapackage com.wanghubill;import org.springframework.jdbc.core.support.JdbcDaoSupport;public class AccoutDaoImpl extends JdbcDaoSupport implements AccountDao &#123; public void outMoney(String out, Double money) &#123; String sql = "update account set money = money - ? where name = ?"; this.getJdbcTemplate().update(sql,money,out); &#125; public void inMoney(String in, Double money) &#123; String sql = "update account set money = money + ? where name = ?"; this.getJdbcTemplate().update(sql,money,in); &#125;&#125; 4.3.6.2. 声明式事务1：基于TransactionProxyFactoryBean的方式 因为声明式事务管理都是非侵入性的（不用修改原代码），只用配置，所以就不帖源代码了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 引入 外部属性文件--&gt; &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; &lt;!-- 配置c3p0连接池 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;" /&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/bean&gt; &lt;!-- 配置业务层类 --&gt; &lt;bean id="accountService" class="com.wanghubill.xml1tfb.AccountServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao" /&gt; &lt;/bean&gt; &lt;!-- 配置DAO类 --&gt; &lt;bean id="accountDao" class="com.wanghubill.xml1tfb.AccoutDaoImpl"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 配置事务管理类 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 配置业务层代理 --&gt; &lt;bean id="accountServiceProxy" class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean" &gt; &lt;!-- 配置目标对象（增强对象） --&gt; &lt;property name="target" ref="accountService" /&gt; &lt;!-- 注入事务管理器 --&gt; &lt;property name="transactionManager" ref="transactionManager" /&gt; &lt;!-- 注入事务属性 --&gt; &lt;property name="transactionAttributes" &gt; &lt;props&gt; &lt;prop key="transfer"&gt;PROPAGATION_REQUIRED&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 4.3.6.3. 声明式事务2：基于AspectJ的XML方式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 引入 外部属性文件--&gt; &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; &lt;!-- 配置c3p0连接池 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;" /&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/bean&gt; &lt;!-- 配置业务层类 --&gt; &lt;bean id="accountService" class="com.wanghubill.xml2aspectj.AccountServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao" /&gt; &lt;/bean&gt; &lt;!-- 配置DAO类 --&gt; &lt;bean id="accountDao" class="com.wanghubill.xml2aspectj.AccoutDaoImpl"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 配置事务管理类 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 配置事务的通知（事务的增强） --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;!-- 哪些方法需要执行事务，怎么执行 --&gt; &lt;tx:attributes&gt; &lt;tx:method name="transfer" propagation="REQUIRED"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置切面 --&gt; &lt;aop:config&gt; &lt;!-- 配置切入点 --&gt; &lt;!-- execution( com.wanghubill.xml2aspectjaspectj.AccountService+.(..)) --&gt; &lt;!-- execution(任意返回值 代理类+子类.任意方法(..任意参数)) --&gt; &lt;aop:pointcut id="pointcut1" expression="execution( com.wanghubill.xml2aspectj.AccountService+.(..))" /&gt; &lt;!-- 配置切面 --&gt; &lt;!-- 对pointcut1配置txAdvice增强 --&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pointcut1" /&gt; &lt;/aop:config&gt;&lt;/beans&gt; 4.3.6.4. 声明式事务3：基于注解的方式 基于注解的方式，配置十分简单，只需在业务层需要事务的类上面打上注解 12345678910111213141516171819202122232425262728293031/////AccountServiceImpl.javapackage com.wanghubill.xml3notation;import org.springframework.transaction.annotation.Transactional;/* @author hupo.wh /@Transactionalpublic class AccountServiceImpl implements AccountService &#123; private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; public void transfer(final String out, final String in, final Double money) &#123; System.out.println("enter transfer()"); accountDao.outMoney(out, money); //int i=1/0; accountDao.inMoney(in, money); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 引入 外部属性文件--&gt; &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; &lt;!-- 配置c3p0连接池 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;" /&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/bean&gt; &lt;!-- 配置业务层类 --&gt; &lt;bean id="accountService" class="com.wanghubill.xml3notation.AccountServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao" /&gt; &lt;/bean&gt; &lt;!-- 配置DAO类 --&gt; &lt;bean id="accountDao" class="com.wanghubill.xml3notation.AccoutDaoImpl"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 配置事务管理类 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 开启注解事务 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager" /&gt;&lt;/beans&gt; 4.3.6.5. 小结 注解和声明对比： 注解简单 声明是非侵入式 感悟：但是本质都是告诉框架，哪些类需要被代理来执行事务。 4.3.7. 什么是事务的传播机制首先要清楚的是：事务是因为有业务需求，才产生的一种机制。 所以事务的配置应该安放在业务层 比如转钱的例子： 如果aaa()和 bbb()方法需要用事务来解决，应该如何处理他们之间的关系呢？ 这就需要用事务的传播行为来定义了 事务的传播行为详见下表： 其实这7种行为看起来很多，但是实则可以就分为3类： （1）第一类 required：在当前事务中解决问题 （2）第二类 requires_new：挂起当前事务，简单来说就是隔离 思考： 为什么取流水号和打印日志需要用requires_new？ 这主要有两个原因： 为了取号速度，取号是事务的第一步，因为如果不新建一个事务，取号需要加锁，如果这个事务比较长，就需要一直占着锁，这样就很慢。 既然是隔离，就是说取号和真正的事务处理不发生影响。这个原因也造成了一个结果，流水号有“作废”机制，也就是说万一发生异常，这个流水号也生成了，后面的会跳号。事务间就没有依赖关系了，会产生四种情况 （3）第三类 nested：嵌套事务 也就是说： Required 操作在同一个事务里面 New aaa() 和 bbb() 不在一个事务中 spring的事务传播配置如下： [详见](http://blog.csdn.net/scythe666/article/details/51790655 Spring的事务真正处理事务的是事务管理器。 数据库5.1. 锁机制5.1.1 锁的作用是什么数据库是一个多用户的共享资源。当多个用户并发的存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库一致性。 加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。 基本锁类型包括行级锁和表级锁。 表级：直接锁定整张表，在你锁定期间，其它进程无法对该表进行写操作。如果你是写锁，则其它进程则读也不允许 行级：仅对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。 页级：表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。 5.1.2 什么是乐观锁，什么是悲观锁，怎么实现乐观锁 相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。如一个金融系统，当某个操作员读取用户的数据，并在读出的用户数据的基础上进行修改时（如更改用户帐户余额），如果采用悲观锁机制，也就意味着整个操作过程中（从操作员读出数据、开始修改直至提交修改结果的全过程，甚至还包括操作 员中途去煮咖啡的时间），数据库记录始终处于加锁状态，可以想见，如果面对几百上千个并发，这样的情况将导致怎样的后果。乐观锁机制在一定程度上解决了这个问题。乐观锁大多是基于数据版本 （Version）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个“version”字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。 悲观锁 正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定 状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。比如在使用select字句的时候加上for update，那么直到字句的事务结束为止，任何应用都无修改select出来的记录。 5.1.3 关于信号量 Semaphorehttp://iaspecwang.iteye.com/blog/1931031 补充：信号量初始化为1（binary semaphore），而不用lock jdk文档有如下一段话： A semaphore initialized to one, and which is used such that it only has at most one permit available, can serve as a mutual exclusion lock. This is more commonly known as a binary semaphore, because it only has two states: one permit available, or zero permits available. When used in this way, the binary semaphore has the property (unlike many Lock implementations), that the “lock” can be released by a thread other than the owner (as semaphores have no notion of ownership). This can be useful in some specialized contexts, such as deadlock recovery. 将信号量初始化为1，使得它在使用时最多只有一个可用的许可，从而可用作一个相互排斥的锁。这通常也称为二进制信号量，因为它只能有两种状态：一个可用的许可，或零个可用的许可。按此方式使用时，二进制信号量具有某种属性（与很多 Lock 实现不同），即可以由线程释放“锁”，而不是由所有者（因为信号量没有所有权的概念）。在某些专门的上下文（如死锁恢复）中这会很有用。 5.2. 索引MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构。 聚集索引： InnoDB使用B+Tree作为索引结构，主索引的叶节点包含了完整的数据记录。这种索引叫做聚集索引。InnoDB的辅助索引data域存储相应记录主键的值。换句话说，InnoDB的所有辅助索引都引用主键作为data域。 非聚集索引： MyISAM也采用B+Tree作为索引结构，但其data域保存数据记录的地址，因此，MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。 5.2.1 联合索引联合索引又叫复合索引。对于复合索引：Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index （a,b,c）。 可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c进行查找。当最左侧字段是常量引用时，索引就十分有效。两个或更多个列上的索引被称作复合索引。 利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引 不同于使用两个单独的索引。复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。如果您知 道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不姓，电话簿将没有用处。所以说创建复合索引时，应该仔细考虑列的顺序。对索引中的所有列执行搜索或仅对前几列执行搜索时，复合索引非常有用；仅对后面的任意列执行搜索时，复合索引则没有用处。 参考 5.2.2 SQL执行计划一个SQL语句表示你所想要得到的但是并没有告诉Server如何去做。 例如, 利用一个SQL语句, 你可能要Server取出所有住在Prague的客户。 当Server收到的这条SQL的时候, 第一件事情并不是解析它。 如果这条SQL没有语法错误, Server才会继续工作。 Server会决定最好的计算方式。 Server会选择, 是读整个客户表好呢, 还是利用索引会比较快些。 Server会比较所有可能方法所耗费的资源。 最终SQL语句被物理性执行的方法被称做执行计划或者是查询计划。 一个执行计划右若干基本操作组成。 例如, 遍历整张表, 利用索引, 执行一个嵌套循环或Hash连接等等。 我们将在这一系列的文章里详细讨论。 所有的基本操作都有一个输出: 结果集。 有些, 象嵌套循环, 有一个输入。 其他的, 象Hash连接, 有两个输入。 每个输入应与其它基本操作的的输出想连接。 这也就是为什么一个执行可以被看做是一个数的原因: 信息从树叶流向树根。 在文章的下面部分有很多诸如此类的例子。 负责处理或计算最优的执行计划的DB Server组件叫优化器。 优化器是建立在其所在的DB资源的基础上而进行工作的。 说白了就是数据库服务器在执行sql语句之前会制定几套执行计划，看那个机会消耗的系统资源少，就是用那套计划。 参考资料[1] 《深入理解Java虚拟机》周志明 著. 机械工业出版社[2] 文中提到的博客和链接]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>转载</tag>
        <tag>学习</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java前世今生和知识简概]]></title>
    <url>%2F2016%2F08%2F22-java-development-history%2F</url>
    <content type="text"><![CDATA[Java前世今生和知识简概看到一篇很强大的博客，转载一下。包括Java的发展历史，Java ME,Java SE,Java EE的基本知识，也包括了Java虚拟机和类加载的一些知识。Markdown整理起来挺复杂，正好也一条条看过去，可惜不能直接插入图片。 Java不仅仅是一门编程语言，还是一个由一系列计算机软件和规范形成的技术体系，这个技术体系提供了完整的用于软件开发和跨平台部署的支持环境，并广泛应用于嵌入式系统、移动终端、企业服务器、大型机等各种场合。时至今日，Java技术体系已经吸引了900多万软件开发者，这是全球最大的软件开发团队。使用Java的设备多达几十亿台，其中包括11亿多台个人计算机、30亿部移动电话及其他手持设备、数量众多的智能卡，以及大量机顶盒、导航系统和其他设备。 Java能获得如此广泛的认可，除了它拥有一门结构严谨、面向对象的编程语言之外，还有许多不可忽视的优点：它摆脱了硬件平台的束缚，实现了“一次编写，到处运行”的理想；它提供了一个相对安全的内存管理和访问机制，避免了绝大部分的内存泄露和指针越界问题；它实现了热点代码检测和运行时编译及优化，这使得Java应用能随着运行时间的增加而获得更高的性能；它有一套完善的应用程序接口，还有无数来自商业机构和开源社区的第三方类库来帮助它实现各种各样的功能。Java所带来的这些好处使程序的开发效率得到了很大的提升。 1. 什么是Java1.1. Java是一种咖啡Sun公司开发了一种称为Oak的面向对象语言。但是在申请注册商标时，发现Oak已经被人使用了，当时他们正在咖啡馆喝着Java咖啡，有一个人灵机一动说就叫Java怎样，这个提议得到了其他人的赞同。最终Oak语言改名为Java。 1.2. Java是一门编程语言 Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。 Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等。 20世纪90年代，硬件领域出现了单片式计算机系统，这种价格低廉的系统一出现就立即引起了自动控制领域人员的注意，因为使用它可以大幅度提升消费类电子产品（如电视机顶盒、面包烤箱、移动电话等）的智能化程度。Sun公司为了抢占市场先机，在1991年成立了一个称为Green的项目小组，帕特里克、詹姆斯·高斯林、麦克·舍林丹和其他几个工程师一起组成的工作小组在加利福尼亚州门洛帕克市沙丘路的一个小工作室里面研究开发新技术，专攻计算机在家电产品上的嵌入式应用。 由于C++所具有的优势，该项目组的研究人员首先考虑采用C++来编写程序。但对于硬件资源极其匮乏的单片式系统来说，C++程序过于复杂和庞大。另外由于消费电子产品所采用的嵌入式处理器芯片的种类繁杂，如何让编写的程序跨平台运行也是个难题。为了解决困难，他们首先着眼于语言的开发，假设了一种结构简单、符合嵌入式应用需要的硬件平台体系结构并为其制定了相应的规范，其中就定义了这种硬件平台的二进制机器码指令系统（即后来成为“字节码”的指令系统），以待语言开发成功后，能有半导体芯片生产商开发和生产这种硬件平台。对于新语言的设计，Sun公司研发人员并没有开发一种全新的语言，而是根据嵌入式软件的要求，对C++进行了改造，去除了留在C++的一些不太实用及影响安全的成分，并结合嵌入式系统的实时性要求，开发了一种称为Oak的面向对象语言。 由于在开发Oak语言时，尚且不存在运行字节码的硬件平台，所以为了在开发时可以对这种语言进行实验研究，他们就在已有的硬件和软件平台基础上，按照自己所指定的规范，用软件建设了一个运行平台，整个系统除了比C++更加简单之外，没有什么大的区别。1992年的夏天，当Oak语言开发成功后，研究者们向硬件生产商进行演示了Green操作系统、Oak的程序设计语言、类库和其硬件，以说服他们使用Oak语言生产硬件芯片，但是，硬件生产商并未对此产生极大的热情。因为他们认为，在所有人对Oak语言还一无所知的情况下，就生产硬件产品的风险实在太大了，所以Oak语言也就因为缺乏硬件的支持而无法进入市场，从而被搁置了下来。 1994年6、7月间，在经历了一场历时三天的讨论之后，团队决定再一次改变了努力的目标，这次他们决定将该技术应用于万维网。他们认为随着Mosaic浏览器的到来，因特网正在向同样的高度互动的远景演变，而这一远景正是他们在有线电视网中看到的。作为原型，帕特里克·诺顿写了一个小型万维网浏览器WebRunner。 1995年，互联网的蓬勃发展给了Oak机会。业界为了使死板、单调的静态网页能够“灵活”起来，急需一种软件技术来开发一种程序，这种程序可以通过网络传播并且能够跨平台运行。于是，世界各大IT企业为此纷纷投入了大量的人力、物力和财力。这个时候，Sun公司想起了那个被搁置起来很久的Oak，并且重新审视了那个用软件编写的试验平台，由于它是按照嵌入式系统硬件平台体系结构进行编写的，所以非常小，特别适用于网络上的传输系统，而Oak也是一种精简的语言，程序非常小，适合在网络上传输。Sun公司首先推出了可以嵌入网页并且可以随同网页在网络上传输的Applet（Applet是一种将小程序嵌入到网页中进行执行的技术），并将Oak更名为Java（在申请注册商标时，发现Oak已经被人使用了，再想了一系列名字之后，最终，使用了提议者在喝一杯Java咖啡时无意提到的Java词语）。5月23日，Sun公司在Sun world会议上正式发布Java和HotJava浏览器。IBM、Apple、DEC、Adobe、HP、Oracle、Netscape和微软等各大公司都纷纷停止了自己的相关开发项目，竞相购买了Java使用许可证，并为自己的产品开发了相应的Java平台。 1.3. Java是一套技术体系从广义上讲，Clojure、JRuby、Groovy等运行于Java虚拟机上的语言及其相关的程序都属于Java技术体系中的一员。如果仅从传统意义上来看，Sun官方所定义的Java技术体系包括以下几个组成部分： Java程序设计语言各种硬件平台上的Java虚拟机Class文件格式Java API类库来自商业机构和开源社区的第三方Java类库 我们可以把Java程序设计语言、Java虚拟机、Java API类库这三部分统称为JDK（Java Development Kit）JDK是用于支持Java程序开发的最小环境，在后面的内容中，为了讲解方便，有一些地方会以JDK来代替整个Java技术体系。另外，可以把Java API类库中的Java SE API子集和Java虚拟机这两部分统称为JRE（Java Runtime Environment）JRE是支持Java程序运行的标准环境。 以上是根据各个组成部分的功能来进行划分的，如果按照技术所服务的领域来划分，或者说按照Java技术关注的重点业务领域来划分，Java技术体系可以分为4个平台，分别为： Java Card：支持一些Java小程序（Applets）运行在小内存设备（如智能卡）上的平台。Java ME（Java Platform， Micro Edition Embedded）：支持Java程序运行在移动终端（手机、PDA）上的平台，对Java API有所精简，并加入了针对移动终端的支持，这个版本以前称为J2ME。Java SE（Java Platform， Standard Edition）：支持面向桌面级应用（如Windows下的应用程序）的Java平台，提供了完整的Java核心API，这个版本以前称为J2SE。Java EE（Java Platform， Enterprise Edition）：支持使用多层架构的企业应用（如ERP、CRM应用）的Java平台，除了提供Java SE API外，还对其做了大量的扩充并提供了相关的部署支持，这个版本以前称为J2EE。 其中，Java SE是标准版本，其他版本则是在此版本上进行了增强或精简。 还有Java TV（面向电视领域）、Java Embedded（面向物联网领域）等平台，但是没有什么影响力。后面将会按照业务领域来介绍。 1.4. Java发展史1991年，Java语言前身Oak项目开始启动，1995年5月23日。Java 1.0版本正式在SunWorld大会上发布。Java语言第一次提出了“Write Once，Run Anywhere”的口号。 目前，JDK已经发展到了1.8版。这么多年还诞生了无数和Java相关的产品、技术和标准。 现在让我们走入时间隧道，从孕育Java语言的时代开始，再来回顾一下Java的发展轨迹和历史变迁。 在Java的四个主要平台，Java SE是发展最好也是最迅速的。 1991年4月，由James Gosling博士领导的绿色计划（Green Project）开始启动，此计划的目的是开发一种能够在各种消费性电子产品（如机顶盒、冰箱、收音机等）上运行的程序架构。这个计划的产品就是Java语言的前身：Oak（橡树）。Oak当时在消费品市场上并不算成功，但随着1995年互联网潮流的兴起，Oak迅速找到了最适合自己发展的市场定位并蜕变成为Java语言。 1992年3月，由于Oak已被用作另一种已存在的编程语言名称，因此必须选一个新的名字——它就是Java，灵感来源于咖啡。 1993年2月，电视机顶盒，FirstPerson试图从时代华纳获得一个电视机顶盒交互系统的一揽子订单。在那时，由于绿色计划不是很成功，随即失去了时代华纳的订单。于是开发的重心从家庭消费电子产品转到了电视盒机顶盒的相关平台上。 1995年5月23日，Oak语言改名为Java，并且在SunWorld大会上正式发布Java 1.0版本。Java语言第一次提出了“Write Once，Run Anywhere”的口号。 1996年1月23日，JDK 1.0发布，Java语言有了第一个正式版本的运行环境。JDK 1.0提供了一个纯解释执行的Java虚拟机实现（Sun Classic VM）。JDK 1.0版本的代表技术包括：Java虚拟机、Applet、AWT等。 1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入Java技术。同年9月，已有大约8.3万个网页应用了Java技术来制作。在1996年5月底，Sun公司于美国旧金山举行了首届JavaOne大会，从此JavaOne成为全世界数百万Java语言开发者每年一度的技术盛会。 1997年2月19日，Sun公司发布了JDK 1.1，Java技术的一些最基础的支撑点（如JDBC等）都是在JDK 1.1版本中发布的，JDK 1.1版的技术代表有：JAR文件格式、JDBC、JavaBeans、RMI。Java语法也有了一定的发展，如内部类（Inner Class）和反射（Reflection）都是在这个时候出现的。 直到1999年4月8日，JDK 1.1一共发布了1.1.0～1.1.8九个版本。从1.1.4之后，每个JDK版本都有一个自己的名字（工程代号），分别为：JDK 1.1.4 - Sparkler（宝石）、JDK 1.1.5 - Pumpkin（南瓜）、JDK 1.1.6 - Abigail（阿比盖尔，女子名）、JDK 1.1.7 - Brutus（布鲁图，古罗马政治家和将军）和JDK 1.1.8 – Chelsea（切尔西，城市名）。 1998年12月4日，JDK迎来了一个里程碑式的版本JDK 1.2，工程代号为Playground（竞技场），Sun在这个版本中把Java技术体系拆分为3个方向，分别是面向桌面应用开发的J2SE（Java 2 Platform， Standard Edition）、面向企业级开发的J2EE（Java 2 Platform， Enterprise Edition）和面向手机等移动终端开发的J2ME（Java 2 Platform， Micro Edition）。在这个版本中出现的代表性技术非常多，如EJB、Java Plug-in、Java IDL、Swing等，并且这个版本中Java虚拟机第一次内置了JIT（Just In Time）编译器（JDK 1.2中曾并存过3个虚拟机，Classic VM、HotSpot VM和Exact VM，其中Exact VM只在Solaris平台出现过；后面两个虚拟机都是内置JIT编译器的，而之前版本所带的Classic VM只能以外挂的形式使用JIT编译器）。在语言和API级别上，Java添加了strictfp关键字与现在Java编码之中极为常用的一系列Collections集合类。 在1999年3月和7月，分别有JDK 1.2.1和JDK 1.2.2两个小版本发布。 1999年4月27日，HotSpot虚拟机发布，HotSpot最初由一家名为“Longview Technologies”的小公司开发，因为HotSpot的优异表现，这家公司在1997年被Sun公司收购了。HotSpot虚拟机发布时是作为JDK 1.2的附加程序提供的，后来它成为了JDK 1.3及之后所有版本的Sun JDK的默认虚拟机。 2000年5月8日，工程代号为Kestrel（美洲红隼）的JDK 1.3发布，JDK 1.3相对于JDK 1.2的改进主要表现在一些类库上（如数学运算和新的Timer API等），JNDI服务从JDK 1.3开始被作为一项平台级服务提供（以前JNDI仅仅是一项扩展），使用CORBA IIOP来实现RMI的通信协议，等等。这个版本还对Java 2D做了很多改进，提供了大量新的Java 2D API，并且新添加了JavaSound类库。JDK 1.3有1个修正版本JDK 1.3.1，工程代号为Ladybird（瓢虫），于2001年5月17日发布。 自从JDK 1.3开始，Sun维持了一个习惯：大约每隔两年发布一个JDK的主版本，以动物命名，期间发布的各个修正版本则以昆虫作为工程名称。 2002年2月13日，JDK 1.4发布，工程代号为Merlin（灰背隼）。JDK 1.4是Java真正走向成熟的一个版本，Compaq、Fujitsu、SAS、Symbian、IBM等著名公司都有参与甚至实现自己独立的JDK 1.4。哪怕是在十多年后的今天，仍然有许多主流应用（spring、hibernate、Struts等）能直接运行在JDK 1.4之上，或者继续发布能运行在JDK 1.4上的版本。JDK 1.4同样发布了很多新的技术特性，如正则表达式、异常链、NIO、日志类、XML解析器和XSLT转换器等。 JDK 1.4有两个后续修正版： 2002年9月16日发布的工程代号为Grasshopper（蚱蜢）的JDK 1.4.1 2003年6月26日发布的工程代号为Mantis（螳螂）的JDK 1.4.2。 2002年前后还发生了一件与Java没有直接关系，但事实上对Java的发展进程影响很大的事件，那就是微软公司的.NET Framework发布了。这个无论是技术实现上还是目标用户上都与Java有很多相近之处的技术平台给Java带来了很多讨论、比较和竞争，.NET平台和Java平台之间声势浩大的孰优孰劣的论战到目前为止都在继续。 2004年9月30日，JDK 1.5发布，工程代号Tiger（老虎）。从JDK 1.2以来，Java在语法层面上的变换一直很小，而JDK 1.5在Java语法易用性上做出了非常大的改进。例如，自动装箱、泛型、动态注解、枚举、可变长参数、遍历循环（foreach循环）等语法特性都是在JDK 1.5中加入的。在虚拟机和API层面上，这个版本改进了Java的内存模型（Java Memory Model，JMM）、提供了java.util.concurrent并发包等。另外，JDK 1.5是官方声明可以支持Windows 9x平台的最后一个JDK版本。 2006年12月11日，JDK 1.6发布，工程代号Mustang（野马）。在这个版本中，Sun终结了从JDK 1.2开始已经有8年历史的J2EE、J2SE、J2ME的命名方式，启用Java SE 6、Java EE 6、Java ME 6的命名方式。JDK 1.6的改进包括：提供动态语言支持（通过内置Mozilla Java Rhino引擎实现）、提供编译API和微型HTTP服务器API等。同时，这个版本对Java虚拟机内部做了大量改进，包括锁与同步、垃圾收集、类加载等方面的算法都有相当多的改动。 在2006年11月13日的JavaOne大会上，Sun公司宣布最终会将Java开源，并在随后的一年多时间内，陆续将JDK的各个部分在GPL v2（GNU General Public License v2）协议下公开了源码，并建立了OpenJDK组织对这些源码进行独立管理。除了极少量的产权代码（Encumbered Code，这部分代码大多是Sun本身也无权限进行开源处理的）外，OpenJDK几乎包括了Sun JDK的全部代码，OpenJDK的质量主管曾经表示，在JDK 1.7中，Sun JDK和OpenJDK除了代码文件头的版权注释之外，代码基本上完全一样，所以OpenJDK 7与Sun JDK 1.7本质上就是同一套代码库开发的产品。 JDK 1.6发布以后，由于代码复杂性的增加、JDK开源、开发JavaFX、经济危机及Sun收购案等原因，Sun在JDK发展以外的事情上耗费了很多资源，JDK的更新没有再维持两年发布一个主版本的发展速度。JDK 1.6到目前为止一共发布了37个Update版本，最新的版本为java se 6 Update 37，于2012年10月16日发布。 2009年2月19日，工程代号为Dolphin（海豚）的JDK 1.7完成了其第一个里程碑版本。根据JDK 1.7的功能规划，一共设置了10个里程碑。最后一个里程碑版本原计划于2010年9月9日结束，但由于各种原因，JDK 1.7最终无法按计划完成。 从JDK 1.7最开始的功能规划来看，它本应是一个包含许多重要改进的JDK版本，其中的Lambda项目（Lambda表达式、函数式编程）、Jigsaw项目（虚拟机模块化支持）、动态语言支持、GarbageFirst收集器和Coin项目（语言细节进化）等子项目对于Java业界都会产生深远的影响。在JDK 1.7开发期间，Sun公司由于相继在技术竞争和商业竞争中都陷入泥潭，公司的股票市值跌至仅有高峰时期的3%，已无力推动JDK 1.7的研发工作按正常计划进行。为了尽快结束JDK 1.7长期“跳票”的问题，Oracle公司收购Sun公司后不久便宣布将实行“B计划”，大幅裁剪了JDK 1.7预定目标，以便保证JDK 1.7的正式版能够于2011年7月28日准时发布。“B计划”把不能按时完成的Lambda项目、Jigsaw项目和Coin项目的部分改进延迟到JDK 1.8之中。最终，JDK 1.7的主要改进包括：提供新的G1收集器（G1在发布时依然处于Experimental状态，直至2012年4月的Update 4中才正式“转正”）、加强对非Java语言的调用支持（JSR-292，这项特性到目前为止依然没有完全实现定型）、升级类加载架构等。 到目前为止，JDK 1.7已经发布了9个Update版本，最新的Java SE 7 Update 9于2012年10月16日发布。从Java SE 7 Update 4起，oracle开始支持Mac OS X操作系统，并在Update 6中达到完全支持的程度，同时，在Update 6中还对ARM指令集架构提供了支持。至此，官方提供的JDK可以运行于Windows（不含Windows 9x）、Linux、Solaris和Mac OS平台上，支持ARM、x86、x64和Sparc指令集架构类型。 2009年4月20日，Oracle公司宣布正式以74亿美元的价格收购Sun公司，Java商标从此正式归Oracle所有（Java语言本身并不属于哪间公司所有，它由JCP组织进行管理，尽管JCP主要是由Sun公司或者说Oracle公司所领导的）。由于此前Oracle公司已经收购了另外一家大型的中间件企业BEA公司，在完成对Sun公司的收购之后，Oracle公司分别从BEA和Sun中取得了目前三大商业虚拟机的其中两个：JRockit和HotSpot，Oracle公司宣布在未来1～2年的时间内，将把这两个优秀的虚拟机互相取长补短，最终合二为一。可以预见在不久的将来，Java虚拟机技术将会产生相当巨大的变化。 2011年7月28日，Oracle公司发布Java SE 1.7 2014年3月18日，Oracle公司发表Java SE 1.8 Java语言有下面一些特点: 简单、面向对象、分布式、解释执行、鲁棒、安全、体系结构中立、可移植、高性能、多线程以及动态性。 版本 描述 1991年1月 Sun公司成立了Green项目小组，专攻智能家电的嵌入式控制系统 1991年2月 放弃C++，开发新语言，命名为“Oak” 1991年6月 JamesGosling开发了Oak的解释器 1992年1月 Green完成了Green操作系统、Oak语言、类库等开发 1992年11月 Green计划转化成“FirstPerson”，一个Sun公司的全资母公司 1993年2月 获得时代华纳的电视机顶盒交互系统的订单，于是开发的重心从家庭消费电子产品转到了电视盒机顶盒的相关平台上。 1994年6月 FirstPerson公司倒闭，员工都合并到Sun公司。Liveoak计划启动了，目标是使用Oak语言设计出一个操作系统。 1994年7月 第一个Java语言的Web浏览器WebRunner（后来改名为HotJava），Oak更名为Java。 1994年10月 VanHoff编写的Java编译器用于Java语言 1995年3月 在SunWorld大会，Sun公司正式介绍了Java和HotJava。 1996年1月 JDK1.0发布 1997年2月 J2SE1.1发布 1998年12月 J2SE1.2发布 1999年6月 发布Java的三个版本：J2SE、J2EE、J2ME 2000年5月 J2SE1.3发布 2001年9月 J2EE1.3发布 2002年2月 J2SE1.4发布 2004年9月 J2SE1.5发布，将J2SE1.5改名JavaSE5.0 2005年6月 JavaSE6.0发布，J2EE更名为JavaEE，J2SE更名为JavaSE，J2ME更名为JavaME 2006年12月 JRE6.0发布 2006年12月 JavaSE6发布 2009年12月 JavaEE6发布 2009年4月 Oracle收购Sun 2011年7月 JavaSE7发布 2014年3月 JavaSE8发布 大部分的JDK历史版本（JDK 1.1.6之后的版本），以及JDK所附带的各种工具的历史版本，都可以从Oracle公司的网站上下载到。 1.5. Java虚拟机发展史 Java虚拟机（Java Virtual Machine 简称JVM）是运行所有Java程序的抽象计算机，是Java语言的运行环境，它是Java 最具吸引力的特性之一。 Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。 一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。 Java虚拟机是Java语言底层实现的基础。这有助于理解Java语言的一些性质，也有助于使用Java语言。对于要在特定平台上实现Java虚拟机的软件人员，Java语言的编译器作者以及要用硬件芯片实现Java虚拟机的人来说，则必须深刻理解Java虚拟机的规范。另外，如果你想扩展Java语言，或是把其它语言编译成Java语言的字节码，你也需要深入地了解Java虚拟机。 从1996年初Sun公司发布的JDK 1.0中所包含的Sun Classic VM到今天，曾经涌现、湮灭过许多或经典或优秀或有特色的虚拟机实现，在这一节中，我们先暂且把代码与技术放下，一起来回顾一下Java虚拟机家族的发展轨迹和历史变迁。 Sun Classic/Exact VM 以今天的视角来看，Sun Classic VM的技术可能很原始，这款虚拟机的使命也早已终结。但仅凭它“世界上第一款商用Java虚拟机”的头衔，就足够有让历史记住它的理由。 1996年1月23日，Sun公司发布JDK 1.0，Java语言首次拥有了商用的正式运行环境，这个JDK中所带的虚拟机就是Classic VM。这款虚拟机只能使用纯解释器方式来执行Java代码，如果要使用JIT编译器，就必须进行外挂。但是假如外挂了JIT编译器，JIT编译器就完全接管了虚拟机的执行系统，解释器便不再工作了。用户在这款虚拟机上执行java-version命令，将会看到类似下面这行输出： java version”1.2.2”Classic VM（build JDK-1.2.2-001，green threads，sunwjit） 其中的“sunwjit”就是Sun提供的外挂编译器，其他类似的外挂编译器还有Symantec JIT和shuJIT等。由于解释器和编译器不能配合工作，这就意味着如果要使用编译器执行，编译器就不得不对每一个方法、每一行代码都进行编译，而无论它们执行的频率是否具有编译的价值。基于程序响应时间的压力，这些编译器根本不敢应用编译耗时稍高的优化技术，因此这个阶段的虚拟机即使用了JIT编译器输出本地代码，执行效率也和传统的C/C++程序有很大差距，“Java语言很慢”的形象就是在这时候开始在用户心中树立起来的。 Sun的虚拟机团队努力去解决Classic VM所面临的各种问题，提升运行效率。在JDK 1.2时，曾在Solaris平台上发布过一款名为Exact VM的虚拟机，它的执行系统已经具备现代高性能虚拟机的雏形：如两级即时编译器、编译器与解释器混合工作模式等。Exact VM因它使用准确式内存管理（Exact Memory Management，也可以叫Non-Conservative/Accurate Memory Management）而得名，即虚拟机可以知道内存中某个位置的数据具体是什么类型。譬如内存中有一个32位的整数123456，它到底是一个reference类型指向123456的内存地址还是一个值为123456的整数，虚拟机将有能力分辨出来，这样才能在GC（垃圾收集）的时候准确判断堆上的数据是否还可能被使用。由于使用了准确式内存管理，Exact VM可以抛弃以前Classic VM基于handler的对象查找方式（原因是进行GC后对象将可能会被移动位置，如果将地址为123456的对象移动到654321，在没有明确信息表明内存中哪些数据是reference的前提下，虚拟机是不敢把内存中所有为123456的值改成654321的，所以要使用句柄来保持reference值的稳定），这样每次定位对象都少了一次间接查找的开销，提升执行性能。 虽然Exact VM的技术相对Classic VM来说先进了许多，但是在商业应用上只存在了很短暂的时间就被更为优秀的HotSpot VM所取代，甚至还没有来得及发布Windows和Linux平台下的商用版本。而Classic VM的生命周期则相对长了许多，它在JDK 1.2之前是Sun JDK中唯一的虚拟机，在JDK 1.2时，它与HotSpot VM并存，但默认使用的是Classic VM（用户可用java-hotspot参数切换至HotSpot VM），而在JDK 1.3时，HotSpot VM成为默认虚拟机，但Classic VM仍作为虚拟机的“备用选择”发布（使用java-classic参数切换），直到JDK 1.4的时候，Classic VM才完全退出商用虚拟机的历史舞台，与Exact VM一起进入了Sun Labs Research VM之中。 Sun HotSpot VM提起HotSpot VM，相信所有Java程序员都知道，它是Sun JDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机。但不一定所有人都知道的是，这个目前看起来“血统纯正”的虚拟机在最初并非由Sun公司开发，而是由一家名为“Longview Technologies”的小公司设计的；甚至这个虚拟机最初并非是为Java语言而开发的，它来源于Strongtalk VM，而这款虚拟机中相当多的技术又是来源于一款支持Self语言实现“达到C语言50%以上的执行效率”的目标而设计的虚拟机，Sun公司注意到了这款虚拟机在JIT编译上有许多优秀的理念和实际效果，在1997年收购了Longview Technologies公司，从而获得了HotSpot VM。 HotSpot VM既继承了Sun之前两款商用虚拟机的优点（如前面提到的准确式内存管理），也有许多自己新的技术优势，如它名称中的HotSpot指的就是它的热点代码探测技术（其实两个VM基本上是同时期的独立产品，HotSpot还稍早一些，HotSpot一开始就是准确式GC，而Exact VM之中也有与HotSpot几乎一样的热点探测。为了Exact VM和HotSpot VM哪个成为Sun主要支持的VM产品，在Sun公司内部还有过争论，HotSpot打败Exact并不能算技术上的胜利），HotSpot VM的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知JIT编译器以方法为单位进行编译。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发标准编译和OSR（栈上替换）编译动作。通过编译器与解释器恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无须等待本地代码输出才能执行程序，即时编译的时间压力也相对减小，这样有助于引入更多的代码优化技术，输出质量更高的本地代码。 在2006年的JavaOne大会上，Sun公司宣布最终会把Java开源，并在随后的一年，陆续将JDK的各个部分（其中当然也包括了HotSpot VM）在GPL协议下公开了源码，并在此基础上建立了OpenJDK。这样，HotSpot VM便成为了Sun JDK和OpenJDK两个实现极度接近的JDK项目的共同虚拟机。 在2008年和2009年，Oracle公司分别收购了BEA公司和Sun公司，这样Oracle就同时拥有了两款优秀的Java虚拟机：JRockit VM和HotSpot VM。Oracle公司宣布在不久的将来（大约应在发布JDK 8的时候）会完成这两款虚拟机的整合工作，使之优势互补。整合的方式大致上是在HotSpot的基础上，移植JRockit的优秀特性，譬如使用JRockit的垃圾回收器与MissionControl服务，使用HotSpot的JIT编译器与混合的运行时系统。 Sun Mobile-Embedded VM/Meta-Circular VM Sun公司所研发的虚拟机可不仅有前面介绍的服务器、桌面领域的商用虚拟机，除此之外，Sun公司面对移动和嵌入式市场，也发布过虚拟机产品，另外还有一类虚拟机，在设计之初就没抱有商用的目的，仅仅是用于研究、验证某种技术和观点，又或者是作为一些规范的标准实现。这些虚拟机对于大部分不从事相关领域开发的Java程序员来说可能比较陌生。Sun公司发布的其他Java虚拟机有： （1）KVM KVM中的K是“Kilobyte”的意思，它强调简单、轻量、高度可移植，但是运行速度比较慢。在Android、iOS等智能手机操作系统出现前曾经在手机平台上得到非常广泛的应用。 （2）CDC/CLDC HotSpot Implementation CDC/CLDC全称是Connected（Limited）Device Configuration，在JSR-139/JSR-218规范中进行定义，它希望在手机、电子书、PDA等设备上建立统一的Java编程接口，而CDC-HI VM和CLDC-HI VM则是它们的一组参考实现。CDC/CLDC是整个Java ME的重要支柱，但从目前Android和iOS二分天下的移动数字设备市场看来，在这个领域中，Sun的虚拟机所面临的局面远不如服务器和桌面领域乐观。 （3）Squawk VM Squawk VM由Sun公司开发，运行于Sun SPOT（Sun Small Programmable ObjectTechnology，一种手持的WiFi设备），也曾经运用于Java Card。这是一个Java代码比重很高的嵌入式虚拟机实现，其中诸如类加载器、字节码验证器、垃圾收集器、解释器、编译器和线程调度都是Java语言本身完成的，仅仅靠C语言来编写设备I/O和必要的本地代码。 （4）JavaInJava JavaInJava是Sun公司于1997年～1998年间研发的一个实验室性质的虚拟机，从名字就可以看出，它试图以Java语言来实现Java语言本身的运行环境，既所谓的“元循环”（Meta-Circular，是指使用语言自身来实现其运行环境）。它必须运行在另外一个宿主虚拟机之上，内部没有JIT编译器，代码只能以解释模式执行。在20世纪末主流Java虚拟机都未能很好解决性能问题的时代，开发这种项目，其执行速度可想而知。 （5）Maxine VM Maxine VM和上面的JavaInJava非常相似，它也是一个几乎全部以Java代码实现（只有用于启动JVM的加载器使用C语言编写）的元循环Java虚拟机。这个项目于2005年开始，到现在仍然在发展之中，比起JavaInJava，Maxine VM就显得“靠谱”很多，它有先进的JIT编译器和垃圾收集器（但没有解释器），可在宿主模式或独立模式下执行，其执行效率已经接近了HotSpot Client VM的水平。 BEA JRockit/IBM J9 VM 前面介绍了Sun公司的各种虚拟机，除了Sun公司以外，其他组织、公司也研发过不少虚拟机实现，其中规模最大、最著名的就是BEA和IBM公司了。 JRockit VM曾经号称“世界上速度最快的Java虚拟机”（广告词，貌似J9 VM也这样说过），它是BEA公司在2002年从Appeal Virtual Machines公司收购的虚拟机。BEA公司将其展为一款专门为服务器硬件和服务器端应用场景高度优化的虚拟机，由于专注于服务器端应用，它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。除此之外，JRockit的垃圾收集器和MissionControl服务套件等部分的实现，在众多Java虚拟机中也一直处于领先水平。 IBM J9 VM并不是IBM公司唯一的Java虚拟机，不过是目前其主力发展的Java虚拟机。IBM J9 VM原本是内部开发代号，正式名称是“IBM Technology for Java Virtual Machine”，简称IT4J，只是这个名字太拗口了一点，普及程度不如J9。J9 VM最初是由IBM Ottawa实验室一个名为SmallTalk的虚拟机扩展而来的，当时这个虚拟机有一个bug是由8k值定义错误引起的，工程师花了很长时间终于发现并解决了这个错误，此后这个版本的虚拟机就称为K8了，后来扩展出支持Java的虚拟机就被称为J9了。与BEA JRockit专注于服务器端应用不同，IBMJ9的市场定位与Sun HotSpot比较接近，它是一款设计上从服务器端到桌面应用再到嵌入式都全面考虑的多用途虚拟机，J9的开发目的是作为IBM公司各种Java产品的执行平台，它的主要市场是和IBM产品（如IBM WebSphere等）搭配以及在IBM AIX和z/OS这些平台上部署Java应用。 Azul VM/BEA Liquid VM 我们平时所提及的“高性能Java虚拟机”一般是指HotSpot、JRockit、J9这类在通用平台上运行的商用虚拟机，但其实Azul VM和BEA Liquid VM这类特定硬件平台专有的虚拟机才是“高性能”的武器。 Azul VM是Azul Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的Java虚拟机，每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、为专有硬件优化的线程调度等优秀特性。在2010年，Azul Systems公司开始从硬件转向软件，发布了自己的Zing JVM，可以在通用x86平台上提供接近于Vega系统的特性。 Liquid VM即是现在的JRockit VE（Virtual Edition），它是BEA公司开发的，可以直接运行在自家Hypervisor系统上的JRockit VM的虚拟化版本，Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如文件系统、网络支持等。由虚拟机越过通用操作系统直接控制硬件可以获得很多好处，如在线程调度时，不需要再进行内核态/用户态的切换等，这样可以最大限度地发挥硬件的能力，提升Java程序的执行性能。 Apache Harmony/Google Android Dalvik VM 这节介绍的Harmony VM和Dalvik VM只能称做“虚拟机”，而不能称做“Java虚拟机”，但是这两款虚拟机（以及所代表的技术体系）对最近几年的Java世界产生了非常大的影响和挑战，甚至有些悲观的评论家认为成熟的Java生态系统有崩溃的可能。 Apache Harmony是一个Apache软件基金会旗下以Apache License协议开源的实际兼容于JDK 1.5和JDK 1.6的Java程序运行平台，这个介绍相当拗口。它包含自己的虚拟机和Java库，用户可以在上面运行Eclipse、Tomcat、Maven等常见的Java程序，但是它没有通过TCK认证，所以我们不得不用那么一长串拗口的语言来介绍它，而不能用一句“Apache的JDK”来说明。如果一个公司要宣布自己的运行平台“兼容于Java语言”，那就必须要通过TCK（Technology Compatibility Kit）的兼容性测试。Apache基金会曾要求Sun公司提供TCK的使用授权，但是一直遭到拒绝，直到Oracle公司收购了Sun公司之后，双方关系越闹越僵，最终导致Apache愤然退出JCP（Java Community Process）组织，这是目前为止Java社区最严重的一次“分裂”。 在Sun将JDK开源形成OpenJDK之后，Apache Harmony开源的优势被极大地削弱，甚至连Harmony项目的最大参与者IBM公司也宣布辞去Harmony项目管理主席的职位，并参与OpenJDK项目的开发。虽然Harmony没有经过真正大规模的商业运用，但是它的许多代码（基本上是Java库部分的代码）被吸纳进IBM的JDK 7实现及Google Android SDK之中，尤其是对Android的发展起到了很大的推动作用。 说到Android，这个时下最热门的移动数码设备平台在最近几年间的发展过程中所取得的成果已经远远超越了Java ME在过去十多年所获得的成果，Android让Java语言真正走进了移动数码设备领域，只是走的并非Sun公司原本想象的那一条路。 Dalvik VM是Android平台的核心组成部分之一，它的名字来源于冰岛一个名为Dalvik的小渔村。Dalvik VM并不是一个Java虚拟机，它没有遵循Java虚拟机规范，不能直接执行Java的Class文件，使用的是寄存器架构而不是JVM中常见的栈架构。但是它与Java又有着千丝万缕的联系，它执行的dex（Dalvik Executable）文件可以通过Class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。目前Dalvik VM随着Android一起处于迅猛发展阶段，在Android 2.2中已提供即时编译器实现，在执行性能上有了很大的提高。 Microsoft JVM及其他 在十几年的Java虚拟机发展过程中，除去上面介绍的那些被大规模商业应用过的Java虚拟机外，还有许多虚拟机是不为人知的或者曾经“绚丽”过但最终湮灭的。我们以其中微软公司的JVM为例来介绍一下。 也许Java程序员听起来可能会觉得惊讶，微软公司曾经是Java技术的铁杆支持者（也必须承认，与Sun公司争夺Java的控制权，令Java从跨平台技术变为绑定在Windows上的技术是微软公司的主要目的）。在Java语言诞生的初期（1996年～1998年，以JDK 1.2发布为分界），它的主要应用之一是在浏览器中运行Java Applets程序，微软公司为了在IE3中支持Java Applets应用而开发了自己的Java虚拟机，虽然这款虚拟机只有Windows平台的版本，却是当时Windows下性能最好的Java虚拟机，它在1997年和1998年连续两年获得了《PCMagazine》杂志的“编辑选择奖”。但好景不长，在1997年10月，Sun公司正式以侵犯商标、不正当竞争等罪名控告微软公司，在随后对微软公司的垄断调查之中，这款虚拟机也曾作为证据之一被呈送法庭。这场官司的结果是微软公司赔偿2000万美金给Sun公司（最终微软公司因垄断赔偿给Sun公司的总金额高达10亿美元），承诺终止其Java虚拟机的发展，并逐步在产品中移除Java虚拟机相关功能。具有讽刺意味的是，到最后在Windows XP SP3中Java虚拟机被完全抹去的时候，Sun公司却又到处登报希望微软公司不要这样做 [1] 。Windows XP高级产品经理Jim Cullinan称：“我们花费了3年的时间和Sun打官司，当时他们试图阻止我们在Windows中支持Java，现在我们这样做了，可他们又在抱怨，这太具有讽刺意味了。” 我们试想一下，如果当年Sun公司没有起诉微软公司，微软公司继续保持着对Java技术的热情，那Java的世界会变得怎么样呢？.NET技术是否会发展起来？但历史是没有假设的。 其他在本节中没有介绍到的Java虚拟机还有： JamVM.cacaovm.SableVM.Kaffe.Jelatine JVM.NanoVM.MRP.Moxie JVM.Jikes RVM. 1.6. Java相关组织Sun：1980年代初期由斯坦福大学三位年轻学生创立的公司。Java的发明，使得Sun真正有机会在软件的历史天空中放射出太阳的光芒。Sun发明了Java，并且在长达十年的时间里始终走在Java大潮的最前端。Sun是Java的老家，是Java慈爱的母亲，这一切任何人都改变不了。虽然Sun似乎没能够从Java中获得应有的金钱回报，但这丝毫没有挫伤Sun对于Java的母爱，还有对于Java大潮的舍我其谁的领导气概。 所有人都迷恋富有的感觉，但是也迟早会意识到钱不是世上最宝贵的东西。这个世界并不缺少会赚钱的公司，但是能够靠着创新型技术推动整个世界进步的公司却是凤毛麟角。Sun应该感到骄傲，他们将因为Java而在历史的天空里发射出太阳的光芒。 IBM : Java经济的最大受益人 。Sun公司是Java的发明人，但IBM却是Java最大的受益者。 BEA : 用WebLogic Server证明了Java有着大型企业级应用的强悍功能。 Oracle：为Java提供数据库支持，并在后来收购了Sun公司。 Apache：开源软件的品牌保证。Apache这个名字在Java的世界中实在太出名了，以至于“Apache”这六个字母成为开源项目品质保证的代名词。 JBoss：职业开源软件组织。 JCP：Java世界的联合国。JCP（Java Community Process）在1998年由Sun发起成立，目标是通过一个开放、合作和鼓励参与的非盈利组织来发展和推进Java和相关的技术。正是由于JCP计划的推出可以让所有对Java感兴趣的软硬件厂商，个人和组织都能参与到技术规范的制定和发展过程中，协调各方的兴趣和利益、集思广益，才可以让Java在短短的几年内异军突起，成为可以和微软开发平台抗衡的一个主流开发语言。JCP计划既然是一个组织，自然也有一定的架构。JCP组织架构主要包括PMO(Program Management Office)、JCP成员、EC、EG。事实上，JCP的架构就好像一个Java世界的联合国。虽然也有不少人批评JCP成为各派利益的角力场，因而效率低下；但是，它毕竟为Java的顺利发展很好地掌握了方向。 JavaOne：Sun公司举办的Java开发者大会。 SpringOne：作为非常成熟的Java框架，Spring一直有拥有大规模的用户。Spring每年也会举办开发者大会。 Eclipse基金会：这个开源组织拥有众多项目，其中就包含了最为出名的Java IDE Eclipse。 2. Java SE介绍Java SE 是Java平台标准版的简称（Java Platform， Standard Edition），用于开发和部署桌面、服务器以及嵌入设备和实时环境中的Java应用程序。同时，Java SE为Java EE和Java ME提供了基础。 Oracle有两款产品可以用来实现Java SE 8：Java SE Development Kit (JDK) 8 和Java SE Runtime Environment (JRE) 8。 JDK 8是JRE 8的超集，包含JRE 8的一切，加上必要的用于开发程序的编译器和调试器。JRE 8提供库、Java虚拟机和运行Java程序需要的组件。注意，JRE包含不是由Java SE规格要求的组件，包括标准和非标准的Java 组件。 Java LanguageTools &amp; Tool APIsjavajavacjavadocjarjavapJPDAJConsoleJava VisualVMJava DBSecurityInternationalizationRMIIDLDeployMonitoringTroubleshootScriptingJVM TIWeb ServiceseploymentJava Web StartApplet / Java Plug-inUser Interface ToolkitsJavaFXAWTSwingJava 2DAccessibilityDrag and DropInput MethodsImage I/OPrint ServiceSoundIntegration LibrariesIDLJDBCJNDIRMIRMI-IIOPScriptingOther Base LibrariesBeansInt’l SupportInput/OutputJMXJNIMathNetworkingOverride MechanismSecuritySerializationExtension MechanismXML JAXPlang and util Base Librarieslang and utilCollectionsConcurrency UtilitiesJARLoggingManagementPreferences APIRef ObjectsReflectionRegular ExpressionsVersioningZipInstrumentationJava Virtual MachineJava Hotspot Client and Server VM JDK包含上面所有的部分。 JRE包含以下的部分。DeploymentUser Interface ToolkitsIntegration LibrariesOther Base Librarieslang and util Base LibrariesJava Virtual Machine Java SE API包含以下的部分。User Interface Toolkits except JavaFXIntegration LibrariesOther Base Librarieslang and util Base Libraries 紧凑型API包含以下部分。Integration LibrariesOther Base Librarieslang and util Base Libraries 下面依次介绍。 2.1. Java Language Java语言Java语言的学习可以看《Think In Java》这本书。这本书介绍了Java的语法。在此书中将Java语言的学习分为了以下22个部分。 对象导论一切都是对象操作符控制执行流程初始化与清理访问权限控制复用类多态接口内部类持有对象通过异常处理错误字符串类型信息泛型数组容器深入研究Java I/O系统枚举类型注解并发图形化用户界面 对象导论 万物皆为对象。程序是对象的集合，它们通过发送消息来告知彼此所要做的。每个对象都有自己的由其他对象所构成的存储。每个对象都拥有其类型。某一特定类型的所有对象都可以接收同样的消息。 一切都是对象 在Java中用引用操纵对象。 创建一个String对象的引用s。String s; 初始化引用s。s=new String(“abc”); Java中的对象存储在”堆”里，但是基本类型需要特殊对待，直接存储基本类型的“值”到“堆栈”中。 Java__确定每种基本类型所占存储空间的大小。它们的大小并不像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性__是Java程序比用其他大多数语言编写的程序更具有可移植性的原因之一。 基本类型 大小 最小值 最大值 包装器类型 默认值 boolean - - - Boolean false char 16-bit Unicode 0 Unicode 2^16-1 Character ‘\u0000’(null) byte 8 bits -128 +127 Byte (byte)0 short 16 bits -2^15 +2^15-1 Short (short)0 int 32 bits -2^31 +2^31-1 Integer 0 long 64 bits -2^63 +2^63-1 Long 0L float 32 bits IEEE754 IEEE754 Float 0.0f double 64 bits IEEE754 IEEE754 Double 0.0d void - - - Void - 所有数值类型都有正负号，所以不要去寻找无符号的数值类型。 boolean类型所占存储空间的大小没有明确指定，仅定义为能够取字面值true或false。 基本类型具有的包装器类，使得可以在堆中创建一个非基本类型对象，用来表示对应的基本类型。 对于高精度计算，Java提供了两个用于高精度计算的类：BigInteger和BigDecimal。虽然它们大体上属于“包装器类”的范畴，但二者都没有对应的基本类型。 不过这两个类包含的方法，提供的操作与对基本类型所能执行的操作类似。也就是说，能作用于int或float的操作，也同样能作用于BigInteger或BigDecimal。只不过必须以方法调用方式取代运算符方式来实现。由于这么做复杂了许多，所以运算速度会比较慢。在这里，以速度换取了高精度。这两个类支持任意精度的数值进行数学计算，不会丢失任何信息。 如果类的某个成员是基本数据类型，即使没有进行初始化，Java也会确保它获得一个默认值。 当变量作为类的成员使用时，Java才确保给定其默认值，以确保那些是基本类型的成员变量得到初始化（C++没有此功能），防止产生程序错误。但是，这些初始值对你的程序来说，可能是不正确的，甚至是不合法的。所以最好明确地对变量进行初始化。 然而上述确保初始化的方法并不适用于“局部”变量（即并非某个类的字段）。因此，如果在某个方法定义中有： int x; 那么变量x得到的可能是任意值（与C和C++中一样），而不会被自动初始化为零。所以在使用x前，应先对其赋一个适当的值。如果忘记了这么做，Java会在编译时返回一个错误，告诉你此变量没有初始化。 操作符 在最底层，Java中的数据是通过使用操作符来操作的，和大多数编程语言一样。 控制执行流程 就像有知觉的生物一样，程序必须在执行过程中控制它的世界，并做出选择。在Java中，你要使用执行控制语句来做出选择。所有条件语句都利用条件表达式的真或假来决定执行路径。 if-elsewhile、do-while、for、foreachreturn、break、continueswitch 初始化与清理 随着计算机革命的发展，“不安全”的变成方式已逐渐成为编程代价高昂的主因之一。 Java中可以使用构造方法来对类中的成员变量进行初始化。清理则由Java虚拟机中的垃圾回收器在适当的时候回收不会再被使用到的对象，也有可能永远不会被清理到。 访问权限控制 修饰符 类内部 package内 子类 其他 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × 复用类 复用类有三种方式，继承，组合，代理。 多态 多态通过分离做什么和怎么做，从另一角度将接口和实现分离开来。多态不但能够改善代码的组织结构和可读性，还能够创建可扩展的程序。 使用向上转型和向下转型可以在基类和子类之间进行转换。 接口 在接口中的任何成员变量都自动是static和final的。在接口中的方法都是抽象方法。 内部类 可以将一个类的定义放在另一个类的定义内部，这就是内部类。 通过内部类提供闭包的功能是优良的解决方案，它比指针更灵活、更安全。 持有对象 Java提供了大量持有对象的方式，说人话，就是Java有很多集合类。 通过异常处理错误 Java的基本理念是“结构不佳的代码不能运行”。 发现错误的理想时机是在编译阶段，也就是在你试图运行程序之前。然而，编译期间并不能找出所有的错误，余下的问题必须在运行期间解决。Java中的异常处理的目的在于通过使用少于目前数量的代码来简化大型、可靠的程序的生成，并且通过这种方式可以使你更加自信：你的应用中没有未处理(未检查)的错误。 throwsthrow new Exception(“”);try{}catch(){}finally{} 字符串 字符串操作是计算机程序设计中最常见的行为。 String对象是不可变的，对String的加删等操作会导致新的String对象，可以使用StringBuffer,StringBuilder链式操作。 正则表达式是一种强大而灵活的文本处理工具。可以构造复杂的文本模式来匹配字符串。 类型信息 运行时类型信息使得你可以在程序运行时发现和使用类型信息。 Java在运行时识别对象和类的信息有两种方式：一种是“传统的”RTTI，它假定我们在编译时已经知道了所有的类型；另一种是“反射”机制，它允许我们在运行时发现和使用类的信息。 ==equals()instanceofisInstance() Class类与java.lang.reflect类库一起对反射的概念进行了支持，该类库包含了Field、Method以及Constructor类。这样你就可以使用Constructor创建新的对象，用get()和set()方法读取和修改与Field对象关联的字段，用invoke()方法调用与Method对象关联的方法。另外，还可以调用getFields()、getMethods()和getConstructors()等很便利的方法，以返回表示字段、方法以及构造器的对象的数组。 泛型 泛型实现了参数化类型的概念，使代码可以应用于多种类型。为了更方便的创造容器类，Java中也出现了泛型。尽管是基于装箱拆箱实现,擦除的。 数组 优先使用容器而不是数组。只有当切换到数组对性能有所帮助时，才需要用数组。 容器深入研究 Java I/O系统 对程序语言的设计者来说，创建一个好的输入/输出（I/O）系统是一项艰难的任务。 不仅存在各种I/O源端和想要与之通信的接收端（文件、控制台、网络链接等），而且还需要以多种不同的方式与它们进行通信（顺序、随机存取、缓冲、二进制、按字符、按行、按字等）。 File-InputStream-Reader 枚举类型 调用enum的values()方法，可以遍历enum实例。 注解 注解在一定程度上是在把元数据(用于描述数据的数据)与源代码文件结合在一起，而不是保存在外部文档中这一大的趋势之下所催生的。通过使用注解，我们可以将这些元数据保存在Java源代码中，并利用annotation API为自己的注解构造处理工具，同时，注解的优点还包括：更加干净易读的代码以及编译期类型检查等。虽然Java SE预先定义了一些元数据，但一般来说，主要还是需要程序员自己添加新的注解，并且按自己的方式使用它们。 Java内置了三种标准注解和四种元注解。标准注解可以直接使用，元注解专职负责注解其他的注解。 三种标准注解。@Override，表示当前的方法定义将覆盖超类中的方法。如果你不小心拼写错误，或者方法签名对不上被覆盖的方法，编译器就会发出错误提示。@Deprecated，如果程序员为它的元素使用了注解，那么编译器会发出警告信息。@SuppressWarnings，关闭不当的编译器警告信息。 四种元注解。 大多数时候，程序员主要是定义自己的注解，并编写自己的处理器来处理它们，就像SpringMVC那样。 并发 并发的实质是一个物理CPU(也可以多个物理CPU) 在若干道程序之间多路复用，并发性是对有限物理资源强制行使多用户共享以提高效率。 并行性指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，并行性使多个程序同一时刻可在不同CPU上同时执行。 并发，是在同一个cpu上同时（不是真正的同时，而是看来是同时，因为cpu要在多个程序间切换）运行多个程序。并行，是每个cpu运行一个程序。 打个比方。并发，就像一个人（cpu）喂2个孩子（程序），轮换着每人喂一口，表面上两个孩子都在吃饭。并行，就是2个人喂2个孩子，两个孩子也同时在吃饭。 图形化用户界面 Java提供了AWT和Swing库来实现图形用户界面,Java8提供了JavaFX库。 2.2. Tools &amp; Tool APIs 工具及工具APIJava提供了一些帮助开发人员的工具。这些工具在JDK安装目录的bin目录下都可以找到。并且，在Java中也提供了相应的API直接调用，不用新开一个进程去处理。下面依次介绍。 java java命令可以用来启动一个Java应用程序。 详细用法参考这里) javac javac是Java语言的编译器，读入Java语言源码文件，编译成字节码文件。 详细用法参考这里) javadoc Javadoc是一个转换工具，可以将源码中的声明信息，文档注释信息转换.html)页面来描述类、接口、构造方法、方法和成员变量。 详细用法参考这里) jar JAR（Java Archive）是一种将许多文件聚集成一个文件的与平台无关的文件格式。 如何打包生成JAR文件的详细用法参考这里) javap javap命令可以反编译类文件。将类文件反编译成容易阅读的代码。默认输出包，protected和public修饰的成员变量、方法。 详细用法参考这里) jdeps Java类依赖分析器。 详细用法参考这里) Scripting Tools Java还提供了脚本工具方便Java代码与脚本代码之间交互。Java SE 8中提供了两个脚本工具jjs和jrunscript。 jjs被推荐使用，jjs运行时将调用Nashorn引擎。 详细用法可以参考以下两个链接。1)2 Security Tools Java提供了一些安全工具，方便为程序设置安全策略。 keytool：可以生成密钥和证书。参考[这里]jarsigner：可以为JAR文件生成签名并验证。参考[这里]policytool：用于管理策略文件带界面的工具。参考[这里] kinit：用于获取Kerberos v5凭证的工具。参考[这里]klist：用于列出凭证缓存中的条目。参考[这里]ktab：用于帮助用户管理凭证键表中的条目。参考[这里] Monitoring Tools Java提供了一些监控JVM性能统计数据的工具。 jps：JVM进程状态工具，列出运行中的HotSpot JVM进程。参考[这里]jstat：JVM统计监控工具。参考[这里]jstatd：jstat工具的守护工具，确保远程监控工具可以连接到JVM。参考[这里] jconsole 一个图形界面工具，可以监控和管理运行的Java程序。 使用方法可以参考这里 Java VisualVM Java VisualVM是一个工具，可以提供一个用户界面，监控运行在JVM上的Java程序的详细信息，帮助分析并排除程序中的问题。 使用方法可以参考这里 Java Mission Control Java Mission Control也是一个性能分析工具。 用法参考这里 Java Flight Recorder Java Flight Recorder集成在Java Mission Control工具中。也是用来监控Java程序运行状态的。 用法参考这里 JPDA JPDA（Java Platform Debugger Architecture）是Java平台调试体系结构的缩写。由3个规范组成，分别是JVM TI(JVM Tool Interface)，JDWP(Java Debug Wire Protocol)，JDI(Java Debug Interface) 。 既然是规范，当然就有实现。Sun公司自己在jdk中提供了一套实现，比如java调试工具jdb，就是sun公司提供的JDI实现 。 其他厂商也可以提供自己的实现。目前，大多数的JDI实现都是通过Java语言编写的。比如，eclipse IDE，它的两个插件org.eclipse.jdt.debug.ui和org.eclipse.jdt.debug与其强大的调试功能密切相关，其中前者是eclipse调试工具界面的实现，而后者则是JDI的一个完整实现 。 想要了解更多可以参考这里 2 JVM TI JVM Tool Interface (JVM TI)是一个给监控工具使用的编程接口。它可以控制正在JVM中运行的程序。 详细使用可以参考这里 Java IDL and RMI-IIOP Tools Java IDL（Interface Definition Language）可实现网络上不同平台上的对象相互之间的交互，该技术基于通用对象请求代理体系结构CORBA规范说明。IDL是不依赖于语言的接口定义语言，所有支持CORBA的语言都有IDL到该语言的映射。就像其名字所表示的那样，Java IDL支持到Java语言的映射。CORBA规范说明和IDL映射是由OMG（Object Management Group）定义的。OMG由700多个成员组成，Sun公司是其成员之一，它在定义IDL到Java映射的工作中起了主要作用。 包含四个工具tnameserv、idlj、orbd和servertool，已经超出我的认知范围了，想要了解更多，直接看这里#idl Remote Method Invocation (RMI) Tools Java RMI 指的是远程方法调用 (Remote Method Invocation)。它是一种机制，能够让在某个 Java 虚拟机上的对象调用另一个 Java 虚拟机中的对象上的方法。可以用此方法调用的任何对象必须实现该远程接口。 Java RMI不是什么新技术（在Java1.1的时代都有了），但却是是非常重要的底层技术。大名鼎鼎的EJB都是建立在RMI基础之上的，现在还有一些开源的远程调用组件，其底层技术也是RMI。 RMI工具有四个，rmic、rmiregistry、rmid和serialver。想了解更多直接看这里 Java DB Java DB是一个基于Java语言和SQL的关系型数据库管理系统。Java DB是Apache Derby项目的Oracle版本。Java DB包含在JDK中。 了解更多参考这里 Java Deployment Tools 部署Java应用程序和applet相关的工具。提供了三个工具。 javapackager：执行打包应用程序和签名Java和JavaFx应用程序相关的工作。 pack200：使用Java的gzip压缩器将一个JAR文件转换为一个压缩的pack200文件。压缩之后的打包文件是高压缩率的JAR文件，可以直接被部署，节省宽带，减少下载时间。 unpack200：将一个用pack200打包的文件转为一个JAR文件 Internationalization Tools 这个工具帮助创建本地化程序。利用native2ascii工具可以将文本转为Unicode Latin-1编码。 Java Web Services Tools 提供与Web Service相关的工具。有四个，schemagen、wsgen、wsimport和xjc。不想多说Web Service，想了解更多的看这里#webservices) Troubleshooting Tools Java提供了一些故障排除的工具。 Jinfo：Java的配置信息。打印给定进程或者核心文件或者一个远程调试服务器的配置信息。Jhat：堆栈转储浏览器。在堆栈转储文件上启动一个web服务器（例如，jmap -dump），允许堆栈被浏览。Jmap：Java的内存映射。打印共享的对象内存映射或者给定进程、核心文件和远程调试服务器的堆栈内存细节。Jsadebugd：Java的代理调试守护进程。附加到一个进程、核心文件或者作为一个调试服务器。Jstack：Java堆栈跟踪。打印一个给定的进程中一个线程、核心文件或者远程调试服务器的堆栈。 2.3. Deployment 部署使用部署工具可以轻松地发布自己编写的程序。里面包含Java Web Start，和Applet / Java Plug-in两个部分，为什么这东西还要放在JDK中。 一般都可以通过IDE导出可部署的程序，喜欢手动生成的直接看这里)吧。 2.4. User Interface Toolkits 用户界面工具集用户界面工具集提供了构建图形用户界面所需要的工具。提供了JavaFX、Swing、Java 2D、AWT、Accessibility、Drag and Drop、Input Methods、Image I/O、Print Service、Sound。 下面依次介绍。 JavaFX JavaFX是用于构建富互联网应用程序的Java库。 使用此库编写的应用程序可以跨多个平台一致运行。使用JavaFX开发的应用程序可以在各种设备上运行，如台式计算机，手机，电视，平板电脑等。 要使用Java编程语言开发GUI应用程序，程序员依赖于诸如AWT和Swings之类的库。在JavaFX出现之后，这些Java程序开发就可以有效地利用丰富的类库来开发GUI应用程序。 这是继Applet之后Java又折腾出来的一个东西，用来和Adobe Flash、Microsoft Silverlight竞争RIA（Rich Internet Applications）市场。但是很明显，这些东西.html)5的普及下不堪一击，都走进历史的尘埃中。 AWT AWT(Abstract Window Toolkit)：抽象窗口工具包，早期编写图形界面应用程序的包。 Swing 为解决 AWT 存在的问题而新开发的图形界面包。Swing是对AWT的改良和扩展。 Java 2D Java 2D API可以创建和操作图形和图像。 Accessibility 方便残疾人使用Java应用程序的一组API。 Drag and Drop 拖放API方便程序内或程序间通过拖放传递数据。 Input Methods 用来和输入法交互的一组API。 Image I/O Java提供了一些处理图像的API。 Print Service Java提供的和打印机交互的一组API。 Sound Java提供的和声音处理相关的API。 2.5. Integration Libraries 集成库IDL Java IDL（Interface Definition Language）可实现网络上不同平台上的对象相互之间的交互，该技术基于通用对象请求代理体系结构CORBA（Common Object Request Broker Architecture，公共对象请求代理体系结构）规范说明。 JDBC Java JDBC API可以方便地在Java语言中操作各大数据库。 JNDI JNDI(Java Naming and Directory Interface)是一个应用程序设计的API，为开发人员提供了查找和访问各种命名和目录服务的通用、统一的接口，类似JDBC都是构建在抽象层上。现在JNDI已经成为J2EE的标准之一，所有的J2EE容器都必须提供一个JNDI的服务。 RMI Java Remote Method Invocation (Java RMI) ，Java远程方法调用API方便程序员创建分布式的Java程序，在不同Java虚拟机之间相互调用方法。 RMI-IIOP RMI以Java为核心，可与采用本机方法与现有系统相连接。IIOP，Internet Inter-ORB Protocol(互联网内部对象请求代理协议)，它是一个用于CORBA 2.0及兼容平台上的协议。通过支持IIOP协议，Java EE应用程序就可以使用RMI-IIOP来访问CORBA服务。 Scripting 方便Java语言与脚本语言交互的一组API。 2.6. Other Base Packages 其它基本包I/O 用于程序输入输出。 Object Serialization 用于对象序列化和反序列化。 Networking 提供网络相关的功能。 Security 提供安全相关的功能。 Internationalization 提供国际化相关的功能。 JavaBeans Component API JavaBeans是Java中一种特殊的类，可以将多个对象封装到一个对象中。特点是可序列化，提供无参构造器，提供getter方法和setter方法访问对象的属性。 Java Management Extensions (JMX) The Java Management Extensions (JMX) API是一套API来管理和监控程序、设备、服务、虚拟机的资源。是为应用程序植入管理功能的框架。 XML (JAXP) Java提供了XML处理的API。 Java Native Interface (JNI) JNI是Java Native Interface的缩写，它提供了若干的API实现了Java和其他语言的通信（主要是C&amp;C++）。从Java1.1开始，JNI标准成为java平台的一部分，它允许Java代码和其他语言写的代码进行交互。JNI一开始是为了本地已编译语言，尤其是C和C++而设计的，但是它并不妨碍你使用其他编程语言，只要调用约定受支持就可以了。使用java与本地已编译的代码交互，通常会丧失平台可移植性。但是，有些情况下这样做是可以接受的，甚至是必须的。例如，使用一些旧的库，与硬件、操作系统进行交互，或者为了提高程序的性能。JNI标准至少要保证本地代码能工作在任何Java 虚拟机环境。 Extension Mechanism 假设你将Google的Guava库作为Extension来扩展Java平台，那么你便可以像使用Java Collections Framework一样使用Google Guava Collections，看上去GGC就好像变成了Java平台的一部分。 此功能已被废弃，将来会移除。 Endorsed Standards Override Mechanism Java标准覆盖机制。此功能已被废弃，将来会移除。 2.7. lang and util Base Libraries 语言和工具基本库提供基本的语言和工具类。 Math 提供数学运算相关的API。 Monitoring and Management 综合监控管理平台包括监测和管理的Java API。 Package Version Identification 包版本功能可以实现包级别的版本控制，以便程序能在运行时识别一个特定的Java运行环境版本。 Reference Objects 引用对象支持与垃圾收集器的有限程度的交互。 Reflection 反射使Java代码可以获取加载类的成员变量、方法和构造方法。 Collections Framework Java提供了大量的集合类方便处理数据。 Concurrency Utilities Java提供了并发相关的API来构建更强大的程序。 Java Archive (JAR) Files JAR是平台独立的打包格式。 Logging Java也提供了日志API。 Preferences Preferences API类似于Windows注册表，可以将一些偏好设置保存在本地。 2.8. Java Virtual Machine Java虚拟机JDK提供了多个Java虚拟机的实现。当运行客户端程序时，JDK使用Java HotSpot Client VM，这个版本JVM会降低启动时间和内存占用。当在所有平台上运行程序时，JDK使用Java HotSpot Server VM，这个版本JVM会最大化程序_执行_速度。 2.9. Compact Profiles 紧凑型配置文件JRE精简版，该特性定义了Java SE平台规范的一些子集，使Java应用程序不需要整个JRE平台即可部署和运行在小型设备上。开发人员可以基于目标硬件的可用资源选择一个合适的JRE运行环境。 好处 更小的Java环境需要更少的计算资源。一个较小的运行时环境可以更好的优化性能和启动时间。消除未使用的代码从安全的角度总是好的。这些打包的应用程序可以下载速度更快。 紧凑的JRE分3种，分别是compact1、compact2、compact3，他们的关系是compact1&lt;compact2&lt;compact3&lt;Full Java SE，他们包含的API如下图所示。 编译后compact大致的占用空间 3. Java Card介绍Java Card技术主要是让智慧卡或与智慧卡相近的装置上，以具有安全防护性的方式来执行小型的Java Applet，此技术也被广泛运用在SIM卡、提款卡上。 3.1. Java Card架构智能卡就长这样。 Java Card也是一套技术规范，由三部分组成：• Java Card 虚拟机规范，定义了用于智能卡的 Java 程序语言的一个子集和虚拟机。• Java Card 运行时环境规范，进一步定义了用于基于 Java 的智能卡的运行期行为。• Java Card 应用编程接口规范，定义了用于智能卡应用程序核心框架和扩展 Java 程序包和类。 Java Card运行原理图。 （1）最底层是硬件（芯片），然后会提供硬件的接口（底层驱动）。（2）网上是卡片的操作系统，是定制的微型操作系统，不是你想的Linux。（3）操作系统往上才是虚拟机，也就是说虚拟机必须依赖于操作系统！虚拟机不是操作系统！！（4）虚拟机往上是Java卡框架和API接口。（5）最顶层就是Applet。 中间也可以有其他的一些层级，比如虚拟机和Applet之间还可以有个Applet组件。 下层为上层提供API接口（例如import的包里面的函数），上层调用下层的API接口进行编程，接口可以是C/C++的接口，也可以是java的接口。无论是C/C++，最终都是要转化成汇编/机器码执行的，所以只要编译器支持，java和C/C++混合着写都行。所以最高难度的就是在这，例如操作系统这块，虚拟机这块，都是开发难度极大的，所以估计一遍都是直接使用官方（如Sun）提供好的OS/虚拟机。 Java Card与Java SE不同，Java Card虚拟机（Java Card Virtual Machine，也可简称为Java Card VM或JCVM）它是原有Java 虚拟机的子集合，负责对Java Applet进行程式直译、执行及结果回应，也因此JCVM的空间占量不能太大，必须能小到放入智慧卡内。此外，Java Card的Java Applet也必须比一般Java Applet更小型，要求JCVM与Java Card Applet都更小化，对日后的进一步撰写开发与程式移植等有帮助。 既然有容量取向的要求，那也就必须对Java的功效机能进行部分权衡取舍，即便可以用多种方式让应用程式的体积占量突破容量限制，例如将应用程式的程式码划分到Package（Java程式语言中，用来将类以性质、用途等不同取向等而集中放置的地方，即称为Package）内，但是每个Package也被限制不能超过64KB的容量。 3.2. 完整的 Java Card 应用程序完整的 Java Card 应用程序由一个后端应用程序和系统、一个主机（卡外）应用程序、一个接口设备（读卡器）和卡上小应用程序、用户证书和支持软件组成。所有的这些元素共同组成一个安全的端到端应用程序： 一个典型的 Java Card 应用程序不是孤立的，而是包含卡端、读取端和后端元素。让我们更详细的讲述一下每个元素。 后端应用程序和系统 后端应用程序提供了支持卡上 Java 小应用程序的服务。 例如，一个后端应用程序可以提供到安全系统和卡上的证书的连接，提供强大的安全性。在一个电子付款系统中，后端应用程序可以提供到信用卡及其他付款信息的访问。 读取端主应用程序 主应用程序存在于一个例如个人计算机这样的台式机或者终端、电子付款终端、手机或者一个安全子系统中。主应用程序处理用户、Java Card 小应用程序和供应商的后端应用程序之间的通讯。传统的读取端应用程序是使用 C 编写的。近来 Java ME 技术的广泛普及有望使用 Java 实现主应用程序；例如，它可以在一台支持 MIDP 和安全信赖服务应用编程接口（Security and Trust Services API）手机上运行。智能卡供应商一般不仅提供开发工具箱，而且提供支持读取端应用程序和Java Card小应用程序的应用程序编程接口。例如 OpenCard Framework，就是一个基于Java的应用程序编程接口集，隐藏了来自不同供应商的读取器的一些细节，并且提供了Java Card远程方法调用分布式对象模型和安全信任服务应用编程接口（SATSA）。 读取端卡片接受设备 卡片接受设备（CAD）是处于主应用程序和 Java Card 设备之间的接口设备。一个 CAD 为卡片提供电力，以及与之进行电子或者射频通信。一个 CAD 可能是一个使用串行端口附于台式计算机的读卡器，或者可能被整合到终端内，例如饭店或者加油站内的电子付款终端。接口设备从主应用程序到卡片转送应用程序协议数据单元( Application Protocol Data Unit，简称 APDU）命令（在后面讨论），并且从卡片向主应用程序转送响应。一些 CAD 有用于输入个人识别号码的键盘，有的可能还有显示屏。 卡片端小应用程序和环境 Java Card 平台是一个多应用程序环境。在图４中我们可以看到，卡片上可能存在一个或多个Java Card 小应用程序，还有支持软件–卡片的操作系统和 Java Card 运行时环境（JCRE）一起。JCRE 由 Java Card 虚拟机、Java Card Framework 和应用程序编程接口以及一些扩展应用程序编程接口组成。所有的 Java Card 小应用程序扩展 Applet 基本类，并且必须实现 install()和 process()方法；JCRE 在安装小应用程序的时候调用 install()，并且在每次有一个进入的用于小应用程序的APDU 的时候调用 process()。Java Card 小应用程序在被装载的时候实例化，并且在断电的时候保持运行。Java Card 小应用程序起一个服务器的作用，并且是无源的。在一张卡片被加电以后，每个小应用程序都保持非运行的状态直到它被选择，在此时可能会做初始化。小应用程序只有在一个 APDU 被发送给它以后才被激活。一个小应用程序如何激活（被选择）在”一个 Java Card 小应用程序的生命周期”一节中描述。 与 Java Card 小应用程序通讯（访问智能卡）你可以使用两种模型中的任何一种来在一个主应用程序和一个 Java Card 小应用程序之间通信。第一个模型是基本消息传送模型，第二种是基于 Java Card 远程方法调用（JCRMI），这是J2SE RMI 分布式对象模型的一个子集。此外，SATSA 通过一个基于更加抽象的应用编程接口的普通连接框架（Generic Connection Framework，简称 GCF）应用编程接口，让你要么使用消息传递要么使用 JCRMI 来访问智能卡。 3.3. 虚拟机Java Card 虚拟机(JCVM)规范定义了 Java 程序设计语言的一个子集和一个用于智能卡的兼容Java 的虚拟机，包括二进制数据表示和文件格式，以及 JCVM 指令集。 用于 Java Card 平台的虚拟机是两部分实现，一部分在卡外，一部分运行在卡本身。卡上的Java Card 虚拟机解释字节码、管理类和对象等等。外部 Java 虚拟机部分是一个开发工具，一般称为 Java Card 转换工具，装载、检验和进一步地准备卡片小应用程序 Java 类，用于在卡上执行。转换工具输出的是一个 Converted Applet(CAP)文件，这是一个包含一个 Java 程序包中所有类的文件。转换程序检验类是否遵循 Java Card 规范。 JCVM 只支持 Java 程序设计语言的一个有限的子集，然而它保留了许多熟悉的特性，包括对象、继承、程序包、动态对象创建、虚拟方法、接口和异常。JCVM 规范放弃了对许多语言元素的支持，因为这些语言元素可能会用掉很多智能卡本来就很有限的内存。 JCVM 的生命周期与卡片本身的生命周期一致：在卡片制造并测试之后至发行到持卡人手中的一段时间内它就开始了生命周期，当卡片丢失或者毁坏的时候它的生命周期也就结束了。 卡片没有电力的时候 JCVM 也不会停止，因为它的状态被保存在卡片的非易失性存储器中。启动 JCVM 初始化 JCRE 并且创建所有的 JCRE 框架对象，这些在 JCVM 的整个生命周期都是运转着的。JCVM 启动之后，与卡片所有的相互作用原则上都是被卡片上的某个小应用程序控制。 当卡片没电的时候，保存在 RAM 中的任何数据都会丢失，但是保存在永久性存储器中的任何状态都被保留。当再次加电以后，虚拟机又再次激活，这时虚拟机和对象的状态被恢复，并且重新开始执行等待进一步地输入。 3.4. APIJava Card 应用编程接口规范定义了传统的 Java 程序设计语言应用编程接口的一个小的子集–甚至小于 J2ME 的 CLDC。不支持字符串也不支持多线程。没有象 Boolean 和 Integer 这样的包装类，也没有 Class 和 System 类。 除 Java 核心类的小子集以外，Java Card 框架还定义了它自己的特定支持 Java Card 应用程序的核心类。 3.5. Java Card与Java ME的区别 CDC 和 CLDC 配置以及它们相关的简表是 J2ME 平台的一部分，而 Java Card 是一个单独创建来用于智能卡环境的平台。 3.6. Java Card开发流程当创建一个 Java Card 应用程序的时候的典型的步骤是：1、编写 Java 源代码。2、编译你的源代码。3、把类文件改变为一个 Converted Applet（CAP）文件。4、检验这个 CAP 是否有效；这个步骤是可选的。5、安装这个 CAP 文件。 当用 Java 程序设计语言开发传统的程序的时候，头两个步骤是相同的：编写.java 文件并且把它们编译成.class 文件。可是，一旦你已经创建 Java Card 类文件，过程会变化的。 Java Card 虚拟机(JCVM)被分成卡外虚拟机和卡内虚拟机。这个分解移除了昂贵的卡外操作，并且考虑到了在卡本身上的小的内存空间，但是它导致在开发 Java Card 应用程序的时候的额外步骤。 在 Java Card 类可以被导入一个 Java Card 设备之前，他们必须被转化成标准的 CAP 文件格式，然后选择性地检验：（1）转化必然伴有把每个 Java 程序包变换到一个 CAP 文件中，在一个程序包中包含类和接口的联合二进制表示法。转化是一个卡外操作。（2）验证是一个可选择的过程，来确认 CAP 文件的结构、有效的字节码子集和程序包内依赖性。你可能想在你使用的第三方供应商程序包上进行验证，或者如果你的转换工具来自一个第三方供应商。验证一般来说是一个卡外操作，但是一些卡片产品可能包括一个机载的检验器。 一旦检验，CAP 文件就即将安装在 Java Card 设备上了。 想要对Java Card了解更多可以参考下面的博文 4. Java ME介绍Java ME是Java微型版的简称（Java Platform， MicroEdition），是一个技术和规范的集合，它为移动设备（包括消费类产品、嵌入式设备、高级移动设备等）提供了基于Java环境的开发与应用平台。Java ME目前分为两类配置，一类是面向小型移动设备的CLDC（Connected Limited Device Profile ），一类是面型功能更强大的移动设备如智能手机和及顶盒，称为CDC（Connected Device Profile CDC） 4.1. Java ME的体系结构Java ME由多种配置（Configuration）、简表（Profile）和可选包（Optional Package）组成。平台的实现者和应用程序的开发者可以从中选择并组合出一个完整的Java运行环境来满足特定范围内的设备需求，每种组合都应该使这一系列设备的内存、处理器和I/O能力达到最优化。Java ME专家组只所以采取这种灵活的设计结构，主要是为了满足市场上不同种类的嵌入式设备的需求，这些设备在软件和硬件特性上都存在巨大的差异，一种规范很难将它们统一起来。 Java ME的体系结构如下图所示。 配置由Java虚拟机和一系列的API集合组成，为某一范围内的嵌入式设备提供基本的功能，这些设备通常在硬件和软件上具有类似的特性。目前，Java ME主要包含两个配置：连接设备配置（Connected Device Configuration，CDC）和连接受限设备配置（Connected Limited Device Configuration，CLDC）。为了给目标设备提供完整的运行环境，配置必须和简表组合。 简表位于配置之上，为运行环境提供高层的API，例如，应用程序模型和图形用户界面等。目前，CLDC上采用最广泛的简表是移动信息设备简表（Mobile Information Device Profile，MIDP）。基于CLDC与MIDP的Java ME主要面对的目标设备是移动电话。 Java ME可以通过添加可选包（Optional Package）进行扩展，可选包是针对特殊技术的实现，因此它定位的是特定范围的设备，而不适合作为一项特性定义在MIDP中。比较常见的可选包有无线消息API（Wireless Messaging API，JSR120）、移动多媒体API（Mobile Media API，JSR 135）。随着移动终端设备内存的扩大和处理能力的提高，越来越多的可选包被添加到具体的Java ME上，这大大加强了Java ME的功能，第三方开发者可以使用这些可选API开发出功能更强大的应用程序。 4.2. Configuration 配置目前，Java ME主要包括两个配置，即CLDC和CDC。 CLDC是两个配置中较小的一个，为具有间断性联网能力、较慢的处理器和有限内存的设备设计的。这些设备包括移动电话、双工呼叫器和入门级的PDA，它们通常具有16位或32位的CPU、128KB~512KB可用于Java平台实现和相关应用程序的内存。运行在这一配置上的程序称为MIDlet ，在KVM上进行解释。 CDC是为处理能力较强、内存空间更大、联网能力更出色的设备设计的。这些设备包括电视机顶盒、车载娱乐系统、高端PDA等。CDC包含一个具有完备特性的Java虚拟机，比CLDC更大的Java SE的子集。CDC的目标设备通常具有32位或者64位的处理器，2MB以上的可用于Java平台实现和相关应用程序的内存空间。运行在这一配置上的程序称为Java ME Application，在CVM上进行解释。 移动信息设备的硬件发展速度远远超过了Java ME规范制定者的预计。因此，现在很难依照上面的标准来区分现在的移动电话是属于CLDC还是CDC范畴。 随着智能手机的流行，Android和iOS系统二分天下，Java ME也要淡出主流移动领域，在特定的嵌入式设备上继续发光发亮或者苟延残喘吧。 在 J2ME 中有两类虚拟机：CVM (Compact Virtual Machine，C虚拟机)与 KVM (Kernel-based Virtual Machine，K虚拟机)。KVM 和 CVM均可被看作是一种 Java 虚拟机，是 JVM 的子集，在功能上都是 JVM 的缩减版。这两类虚拟机的适用范围并不相同，简单地说，CVM 的功能比KVM 功能更为强大。 4.3. Profile 简表简表用来描述特定的设备，是支持特定设备（某类功能的设备）的API的集合，以Java类的形式提供。所以它是建立在特定的配置（Configration）之上的。 常用简表 MIDP (Mobile Information Devices Profile，移动信息设备简表)：定义了移动信息设备的类型和提供相关的API集合， MIDP 所定义的功能更加面向用户，而且比 CLDC 更高级。 IMP （Mobile Information Device Profile，信息模块简表）：定义了提供网络连接，但是显示方式比较单一的设备简表，例如告警器。 Foundation Profile(基础简表)：提供除了用户界面以外 Java SE 所能够提供的标准类库。 Personal Profile(个人简表)：针对那些资源相对有限，但是对网络访问要求很高，基于AWT图形界面的设备，例如Web-TV、汽车导航系统等。 KJava 包含一个特定于 Sun 的、运行在 Palm 操作系统上的 API。这个 KJava API 和 Java SE 抽象视窗工具包 (AWT) 有很多地方都是相同。然而，由于它不是一个标准的 Java ME 软件包，它的主软件包是 com.sun.kjava。它不作为一种完整的、功能齐全的简表，而是作为一种示范，示范简表如何与 CLDC 一起工作。 配置与简表的搭配 CLDC – MIDP、KjavaCDC – FP、PP、PFP 4.4. Optional Package 可选包在标准的API中，很多都是接口，这些就要求厂商在手机中提供真实的实现，而且很多本地方法也要求手机厂商进行实现。 但是随着手机功能的增强，SUN公司为了满足手机厂商的要求，又推出了很多套API，因为这些API不要求手机厂商必须支持，所以叫做可选包(Option Package)。例如常见的可选包有： MMA(Mobile Media API)——移动媒体API，实现对于多媒体编程更深入的支持WMA(Wireless Message API)——无线信息API，实现对于短信息编程的支持Location API——定位API，实现对于位置服务的支持M3G(Mobile 3D Graphics)——移动3D图形API，实现对于手机3D编程的支持 当然，还有很多其他的实现，这里就不再累述了。 最后，由于可选包越来越多，而且支持可选包的手机越来越多，SUN公司想统一手机对于CLDC、MIDP和一部分可选包的支持，所以又推出了JTWI(Java Technology for the Wireless Industry)来规范手机对于各种API的支持。 想要对Java ME了解更多，可以参考下面的博文 5. Java EE介绍5.1. 什么是Java EEJava EE（Java Platform，Enterprise Edition）是一系列技术标准所组成的平台，具体由各个厂商来实现。 与Java SE不同，Java EE是一个企业级应用的架构体系，而不是一门编程语言。Java EE作为一个架构体系，它定义了企业级应用的层次结构，旨在简化和规范企业应用系统的开发和部署。 Java EE提供了一个基于标准开发Web和企业应用程序的平台。这些应用程序通常被设计作为多层应用程序，用一个前端层组成的网络架构，一个中间层提供安全和交易，以及后端层提供连接到数据库或遗留系统。这些应用程序应该是反应迅速的， 能够扩展以适应用户需求的增长。 Java EE平台的API为这多层应用的每一层定义不同的组件，并且还提供了一些额外的服务，如命名，注射，和资源管理。这些组件被部署在提供运行时支持的容器中。Java EE应用程序组件不会直接与其他Java EE应用程序组件互动 。他们使用的协议和方法实现容器相互之间以及与平台服务进行交互。可以透明地注入由组件所需要的服务，例如声明事务管理，安全检查，资源池和状态管理。 Java EE 7发布2013年6月，并提供了一个简单，易于使用，建立Web和企业应用程序的技术堆栈。 架构图如下。 下面是完整的 14 个 JSRs 和 9 个 MRs (维护发行): JSRs: Java Platform， Enterprise Edition 7 (JSR 342)Concurrency Utilities for Java EE 1.0 (JSR 236) (新加入)Java Persistence 2.1 (JSR 338)JAX-RS: The Java API for RESTful Web Services 2.0 (JSR 339)Java Servlet 3.1 (JSR 340)Expression Language 3.0 (JSR 341)Java Message Service 2.0 (JSR 343)JavaServer Faces 2.2 (JSR 344)Enterprise JavaBeans 3.2 (JSR 345)Contexts and Dependency Injection for Java EE 1.1 (JSR 346)Bean Validation 1.1 (JSR 349)Batch Applications for the Java Platform 1.0 (JSR 352) (新加入)Java API for JSON Processing 1.0 (JSR 353) (新加入)Java API for WebSocket 1.0 (JSR 356) (新加入) MRs: Web Services for Java EE 1.4 (JSR 109)Java Authorization Service Provider Contract for Containers 1.5 (JACC 1.5) (JSR 115)Java Authentication Service Provider Interface for Containers 1.1 (JASPIC 1.1) (JSR 196)JavaServer Pages 2.3 (JSR 245)Common Annotations for the Java Platform 1.2 (JSR 250)Interceptors 1.2 (JSR 318)Java EE Connector Architecture 1.7 (JSR 322)Java Transaction API 1.2 (JSR 907)JavaMail 1.5 (JSR 919) 5.2. Java EE设计思想 Java EE将企业级应用分为两部分：实现基础支撑功能的容器和实现特定业务逻辑的组件。 容器 容器提供的底层基础功能被称为服务。这些服务主要用来实现企业级应用的共性需求，如事务、安全、可扩展性和远程连接等。组件通过调用容器提供的标准服务来与外界交互。为满足企业级应用灵活部署，组件与容器之间必须既松散耦合，又能够强有力地交互。为实现这一点，组件和容器都要遵循一个标准规范，这个标准规范就是Java EE。 容器由专门的厂商来生产，容器必须实现的基本接口和功能由 Java EE规范定义，但具体如何实现完全由容器厂商自己决定。常见的容器类型分为Web容器和EJB容器。 组件 组件一般由开发人员根据特定的业务需求编程实现。所有的 Java EE组件都是在容器的Java虚拟机中进行初始化的，组件通过调用容器提供的标准服务来与外界交互。容器提供的标准服务有:命名服务、数据库连接、持久化、Java消息服务、事务支持和安全服务等。因此在组件的开发过程中，完全可以不考虑复杂多变的企业应用运行环境，而专注于业务逻辑的实现，这样可大大提高组件开发的效率，降低开发企业级应用程序的难度。 容器与组件的交互 那么组件与容器之间是如何实现交互的呢？即容器如何知道要为组件提供何种服务、组件又是如何来获取容器提供的服务呢？ Java EE采用部署描述文件来解决这一难题。每个发布到服务器上的应用除了要包含自身实现的代码文件外，还要包括一个XML文件，称为部署描述文件。部署描述文件中详细地描述了应用中的组件所要调用的容器服务的名称、参数等。部署描述文件就像组件与容器间达成的一个“契约”，容器根据部署描述文件的内容为组件提供服务，组件根据部署文件中的内容来调用容器提供的服务。 从上面的介绍中我们可以发现，部署描述文件的配置是 Java EE开发中的一项重要而又烦琐的工作。值得庆幸的是，在 Java EE规范中，提供了一种注解机制来取代配置复杂的部署描述文件。所谓注解其实就是一个以“@”开头的特殊注释文本，但它比注释的作用要大得多。代码中的注释是帮助开发人员阅读和理解代码内容，而注解则是帮助容器来阅读和理解组件内容。我们可以把注解看成是贴在组件身上的标签，在将组件部署到容器中时，根据这些标签，容器便知道该如何为组件提供服务。注解的出现大大简化了 Java EE应用程序的开发和部署，是 Java EE规范的一项重大进步。 更值得一提的是，在最新的 Java EE规范中，还引入了一种“惯例优于配置”，也称为“仅异常才配置”的思想。通俗一点讲，就是对于 Java EE组件的一些属性和行为，容器将按照一些约定俗成的惯例来自动进行配置，此时开发人员甚至连注解都可以省略。只有当组件的属性和行为不同于惯例时，才需要进行配置。这种编程方式大大降低了程序人员的工作量，也是需要开发人员逐渐熟悉和适应的一种编程技巧。 5.3. Java 技术架构作为一个企业应用开发标准， Java EE最终由一系列的企业应用开发技术来实现。 Java EE技术框架可以分为四部分:组件技术、服务技术、通信技术和框架技术。 整个 Java EE技术框架体系如下图所示。 组件技术 组件是 Java EE应用的基本单元。 Java EE 6提供的组件主要包括三类:客户端组件、Web组件和业务组件。 1.客户端组件 用户通过客户端组件与企业应用进行交互。 Java EE客户端既可以是一个Web浏览器、一个Applet，也可以是一个应用程序。 (1)Web浏览器。 Web浏览器又称为瘦客户。它通常只进行简单的人机交互，不执行如查询数据库、业务逻辑计算等复杂操作。 (2) Applet。 Applet是一个用Java语言编写的小程序，运行在浏览器上的虚拟机里，通过HTTP等协议和服务器进行通信。 (3)应用程序客户端。 Java EE应用程序客户端运行在客户机上，它为用户处理任务提供了比标记语言丰富的接口。典型的 Java EE应用程序客户端拥有通过 Swing或 AWT API建立的图形用户界面。应用程序客户端直接访问在服务器EJB容器内的EJB组件。当然， Java EE客户应用程序也可以像 Applet客户那样通过HTTP连接与服务器的 Servlet通信。与 Applet不同的是，应用程序客户端一般需要在客户机进行安装，而Applet是通过Web下载，无需专门安装。 2.Web组件 Web组件对客户提交的Web请求进行动态响应。用户每次在浏览器上单击一个链接或图标，实际上是通过HTTP请求向服务器发出请求。Web容器负责将Web请求传递给Web组件。Web组件对这些请求进行处理后生成动态内容，再通过Web容器返回给客户端。 Java EE web组件包括 Servlet和JSF( Javaserver faces)组件。 Servlet是Web容器里的程序组件。 Servlet实质上是动态处理HTTP请求和生成网页的Java类。JSF组件是一种基于JSF框架的组件，它可以实现像桌面应用一样基于事件驱动Web应用。 3.业务组件 业务组件用来实现特定的业务逻辑操作，它们通常不直接与客户交互。业务组件包含EJB组件和Entity组件两大类。 EJB组件用于实现特定的业务逻辑，而不是像Web组件一样对客户端请求生成动态页面。EJB组件能够在容器的支持下完成诸如远程连接、消息驱动、分布式事务处理等复杂的业务逻辑，因此使用EJB组件编写的程序可大大降低开发难度，且具有良好的扩展性。 Java EE支持两种类型的EJB组件:Session Bean(会话Bean)和 Message-Driven Bean(消息驱动Bean)。 Entity组件主要用来完成应用数据的持久化操作。 服务技术 Java EE容器为组件提供了各种服务，这些服务是企业应用经常用到但开发人员难以实现的，例如服务、数据库连接、上下文和依赖注入、事务、安全和连接框架等。现在这些服务已经由容器实现，因此 Java EE组件只要调用这些服务就可以了。 1.命名服务 企业应用中通常包含大量的组件，为了完成功能需求，组件间通常要相互调用。JNDI(Java Naming and Directory Interface，Java命名和目录服务接口)简化了企业应用组件之间的查找调用。它提供了应用的命名环境(Naming Environment)。这就像一个公用电话簿，企业应用组件在命名环境注册登记，并且通过命名环境查找所需要的其他组件。 2.数据库连接服务 数据库访问几乎是任何企业应用都需要实现的。JDBC( Java DataBase Connectivity，Java数据库连接)API使 Java EE平台可以和各种关系数据库之间连接起来。JDBC技术提供Java程序和数据库服务器之间的连接服务，同时它能保证数据事务的正常进行。另外，JDBC提供了从Java程序内调用SQL数据检索语言的功能， Java EE 6平台使用JDBC 4.0 API以及JDBC 4.0拓展API，这些API提供了高级的数据连接功能。 3.Java事务服务 JTA( Java Transaction API，Java事务API)允许应用程序执行分布式事务处理——在两个或多个资源节点上访问并且更新数据。JTA用于保证数据读/写时不会出错。当程序进行数据库操作时，要么全部成功完成，要么一点也不改变数据库内容。最怕的是在数据更改过程中程序出错，那样整个系统的业务状态和业务逻辑就会陷入混乱。所以，数据事务有一个“不可分微粒”的概念，是指一次数据事务过程不能间断，JTA保证应用程序的数据读/写进程互不干扰。如果一个数据操作能整个完成，它就会被批准；否则，应用程序服务器就当什么都没做。应用程序开发者无需自己实现这些功能，这样数据操作就被简化了。数据事务技术使用JTA的API，它可以在EJB层或Web层实现。 4.安全服务 JAAS( Java Authentication Authorization Service，Java验证和授权服务)提供了灵活和可伸缩的机制来保证客户端或服务器端的Java程序。Java早期的安全框架强调的是通过验证代码的来源和作者，保护用户避免受到下载下来的代码的攻击JAS强调的是通过验证谁在运行代码以及他她的权限来保护系统免受用户的攻击。它使用户能够将一些标准的安全机制，例如 Solaris nis(网络信息服务)、Windows NT、LDAP(轻量目录存取协议)或 Kerberos等通过一种通用的可配置的方式集成到系统中。 5.Java连接框架 JCA( Java Connector Architecture，Java连接框架)是一组用于连接 Java EE平台到企业信息系统(EIS)的标准API。企业信息系统是一个广义的概念，它指企业处理和存储信息数据的程序系统，例如企业资源计划(ERP)、大型机数据事务处理以及数据库系统等。由于很多系统已经使用多年，这些现有的信息系统又称为遗产系统(Legacy system)，它们不一定是标准的数据库或Java程序，例如非关系数据库等系统。JCA定义了一套扩展性强、安全的数据交互机制，解决了现有企业信息系统与EJB容器和组件的集成。这使 Java EE企业应用程序能够和其他类型的系统进行通话。 6.上下文和依赖注入 上下文和依赖注入( Contexts and Dependency Injection，CDI)使得容器以类型安全的低耦合方式为EJB等组件提供一种上下文服务。它将EB等受控组件的生命周期交由容器来管理，降低了组件之间的耦合度，大大提高了组件的重用性和可移植性。 通信技术 Java EE通信技术提供了客户和服务器之间及在服务器之间及在服务器上不同组件之间的通信机制.Java平台支持几种典型的通信技术: Internet协议、RMI( Remote Method Invocation，远程方法调用)、消息技术( Messaging)和 JavaMail等。 1.Internet协议 Java EE平台能够采用通用的 Internet协议实现客户服务器和组件之间的远程网际通信。 TCP/IP( Transport Control Protocol over Internet Protocol，互联协议之上的传输控制协议)是 Interne在传输层和Web层的核心通信协议。 HTTP1.1是在互联网上传送超文本文件的协议。HTTP消息包括从客户端到服务器的请求和从服到客户端的响应，HTTP和Web浏览器称为 Internet最普及和最常用的功能。大多数Web机器都提供HTTP端口和互联网进行通信，在HTTP之上的SOAP( Simple Object Access Protocol)成为受到广泛关注的Web服务基础协议。 SSL3.0( Secure Socket Layer)是Web的安全协议。它在TCP/IP之上对客户和服务器之间的Web通信信息进行加密而不被窃听，它可以和HTTP共同使用(即HTPS)。服务器可以通过SSL对客户进行验证。 2.RMI RMI是Java的一组用于开发分布式应用程序的API。RMI使用Java语言接口定义了远程对象不同机器操作系统的程序对象)，它结合了Java序列化( Java serialization)和Java远程方法协议(Java Remote Method Protocol)。简单地说，这样使原先的程序在同一操作系统的方法调用，变成了不同操作系统之间程序的方法调用。由于 Java EE是分布式程序平台，它以RMI机制实现程序组件在不同操作系统之间的通信。比如，一个EJB可以通过RMI调用Web上另一台机器上的EJB远程方法。 3.Java消息技术 AJMS( Java Message Service，Java消息服务)API允许 Java EE应用程序访问企业消息系统，例如IBM MQ系列产品和 JBOSS的 JBOSS MQ。 4.邮件技术 Java邮件( Java Mail)API提供能进行电子邮件通信的一套抽象类和接口。它们支持多种电子邮件格式和传递方式。Java应用可以通过这些类和接口收发电子邮件，也可以对其进行扩充。 框架技术 框架方面的贡献是 Java EE 6规范的一项重大进步。在之前的Java EE规范中，主要从微观的角度来规范企业应用的开发，关注的重点是在组件级别上上如何处理组件与客户端的交互，及组件与容器之间的交互。但随着 Java EE的广泛应用，在 lava ee企业应用的构建过程中，一些架构层面上的共性问题，如页面导航、国际化、数据持久化、输入校验等渐渐浮出水面。这些问题是每个企业应用开发人员构建企业应用时几乎必然遇到的，但 Java EE规范并没有对此给出标准答案，因此，各种第三方架构如 Struts2、 Hibernate、 Spring、Seam等大行其道。这些众多的框架给开发人员带来很大压力，也给 Java EE服务器厂商带来更多的麻烦，限制了他们为 Java EE应用提供更高级的支持。因此，在Java EE 6规范中，吸收了目前流行的架构的优点，增加了架构方面的一些标准规范。 1.JSF JSF( Java Server Faces)是一种用于构建 Java EE Web应用表现层的框架标准。它提供了一种以组件为中心的事件驱动的用户界面构建方法，从而大大简化了 Java EE Web应用的开发。通过引入了基于组件和事件驱动的开发模式，使开发人员可以使用类似于处理传统界面的方式来开发Web应用程序。JSF还通过将模型-视图-控制器(MVC)设计模式集成到它的体系结构中，提供了行为与表达的清晰分离，确保了应用程序具有更高的可维护性。 Java EE 6规范中包含的JSF的版本为2.1。 2.JPA 数据持久化对于大部分企业应用来说都是至关重要的，因为企业应用中的大部分信息都需要持久化存储到关系数据库等永久介质中。尽管有不少选择可以用来构建应用程序的持久化层，但是并没有一个统一的标准可以用在 Java EE环境中。作为 Java EE 5规范中的一部分，JPA( Java Persistence API)规范了Java平台下的持久化实现，大大提高了应用的可移植性。 Java EE 6规范中包含的JPA的版本为2.0。 3.EJB 用通俗话说，EJB就是：”把你编写的软件中那些需要执行制定的任务的类，不放到客户端软件上了，而是给他打成包放到一个服务器上了”。是的，没错！EJB 就是将那些”类”放到一个服务器上，用C/S 形式的软件客户端对服务器上的”类”进行调用。 5.4. Java EE优点Java EE体系架构具有以下优点。 1.独立于硬件配置和操作系统。 Java EE应用运行在JVM( Java virtual machine，Java虚拟机)上，利用Java本身的跨平台特性，独立于硬件配置和操作系统。JRE几乎可以运行于所有的硬件/操作系统组合。因此 Java EE架构的企业应用使企业免于高昂的硬件设备和操作系统的再投资，保护已有的IT资源。 2.坚持面向对象的设计原则 作为一门完全面向对象的语言，Java几乎支持所有的面向对象的程序设计特征。面向对象和基于组件的设计原则构成了 Java EE应用编程模型的基础。 Java EE多层结构的每一层都有多种组件模型。因此开发人员所要做的就是为应用项目选择适当的组件模型组合，灵活地开发和装配组件，这样不仅有助于提高应用系统的可扩展性，还能有效地提高开发速度，缩短开发周期。 3.灵活性、可移植性和互操作性 利用Java的跨平台特性， Java EE组件可以很方便地移植到不同的应用服务器环境中。这意味着企业不必再拘泥于单一的开发平台。 Java EE的应用系统可以部署在不同的应用服务器上，在全异构环境下， Java EE组件仍可彼此协同工作。这一特征使得装配应用组件首次获得空前的互操作性。 4.轻松的企业信息系统集成 Java EE技术出台后不久，很快就将JDBC、JMS和JCA等一批标准归纳自身体系之下，这大大简化了企业信息系统整合的工作量，方便企业将诸如遗产系统、ERP和数据库等多个不同的信息系统进行无缝集成。 5.5. 经典Java EE与轻量级Java EE目前 Java EE应用的开发方式大致可分为两种： 一种以 Spring、 Hibernate等开源框架为基础这就是通常所说的轻量级 Java EE应用;另一种则以EJB3+JPA为基础，也就是经典 Java EE应用。 在EJB3出现以前，由于EJB学习曲线陡峭，使用时也有点困难，因此影响了EJB在实际项目中的使用。为此EJB3进行了大刀阔斧的改革，有人说EJB3中的 Session Bean就像 Spring容器中的Bean：只要一个接口和一个实现类即可一—其实这句话说反了，应该说Spring框架充分借鉴了早期的EJB规范，但对EJB规范进行了简化，比如它不要求Bean继承任何基类，而且 Spring对Bean的要求比较“温柔”：它只是建议面向接囗编程;而EJB规范则显得很“强硬”：EJB必须有一个接口和一个实现类。但最终殊途同归： Spring容器中的Bean通常由一个接口和一个实现类组成，EJB也由一个接口和一个实现类组成。到了EJB3时代，开发Session Bean不会比开发 Spring中的Bean更复杂，EJB3中的 Session Bean同样不需要继承任何基类，只要提供一个接口、一个实现类即可，也就是说，EJB3规范也吸收了 Spring框架简单、易用的特性。 Java EE 5的两个核心规范是EJB3和JPA，EJB3使 Java EE应用开发变得更加简单;而JPA规范则体现了Sun公司的良苦用心—Java开源领域中各种ORM框架层出不穷，而 Java EE开发者则疲于学习各种ORM框架： Hibernate是主流，但下一家公司可能选择其他ORM框架，于是开发者不得不重新学习……在这样的背景下，JPA规范诞生了，JPA本质上应属于一种ORM规范应用开发者只需要学习JPA规范、掌握 JPA API即可，不需要为使用 Hibernate学习一套API，为使用 Toplink又要重新学习一套API。开发者面向JPA规范编程，而底层则可以在不同ORM框架(可理解为JPA实现)之间自由切换。通常来说，应用服务器会负责为JPA规范提供ORM实现;如果开发者希望在 Java se应用程序中使用JPA，这也是允许的，只要开发者自行为JPA选择合适的ORM实现即可。事实证明，在应用程序中使用JPA作为持久化解决方案更方便，而且能在各种ORM框架之间自由切换，具有更好的可扩展性。 Java EE 5规范面世以来，大量开发者重新回归到EJB3+JPA旗下，采用EJB3+JPA开发的企业级应用也越来越多。除此之外，JSF作为一个前端MVC框架，能与EJB3+JPA完美整合，从而开发出具有高度可扩展性、高度可维护性的企业级应用。 在目前实际的 Java EE开发平台中，主要可分为两支： 一支以 Spring、 Hibernate两个框架为核心来构建，这类应用无须应用服务器支持，只要在 Tomcat、 Jetty之类的Web服务器上即可运行良好，这类 Java EE应用被称为轻量级 Java EE应用;另一支则以EJB3为核心来构建，这类应用需要EJB容器支持，通常需要在 JBOSS、 Weblogic、 Websphere服务器中运行，这类 Java EE应用是Sun公司官方推荐的 Java EE平台，称为经典 Java EE应用。无论是轻量级 Java EE应用，还是经典 Java EE应用，一样具有稳定的性能和极高的可扩展性、可维护性。 6. Java虚拟机Java在虚拟机层面隐藏了底层技术的复杂性以及机器与操作系统的差异性。运行程序的物理机器的情况千差万别，而Java虚拟机则在千差万别的物理机上建立了统一的运行平台，实现了在任意一台虚拟机上编译的程序都能在任何一台虚拟机上正常运行。这一极大优势使得Java应用的开发比传统C/C++应用的开发更高效和快捷，程序员可以把主要精力集中在具体业务逻辑上，而不是物理硬件的兼容性上。在一般情况下，一个程序员只要了解了必要的Java API、Java语法，以及学习适当的第三方开发框架，就已经基本能满足日常开发的需要了，虚拟机会在用户不知不觉中完成对硬件平台的兼容及对内存等资源的管理工作。因此，了解虚拟机的运作并不是一般开发人员必须掌握的知识。 其实，目前商用的高性能Java虚拟机都提供了相当多的优化特性和调节手段，用于满足应用程序在实际生产环境中对性能和稳定性的要求。如果只是为了入门学习，让程序在自己的机器上正常运行，那么这些特性可以说是可有可无的；如果用于生产开发，尤其是企业级生产开发，就迫切需要开发人员中至少有一部分人对虚拟机的特性及调节方法具有很清晰的认识，所以在Java开发体系中，对架构师、系统调优师、高级程序员等角色的需求一直都非常大。学习虚拟机中各种自动运作特性的原理也成为了Java程序员成长道路上必然会接触到的一课。 6.1. Java内存区域Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。 程序计数器 程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 Java虚拟机栈 与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame ）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量表部分。 局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。 其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 在Java虚拟机规范中，对这个区域规定了两种异常状况： 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。 本地方法栈 本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 Java堆 对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。 Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。 根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 方法区 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。 对于习惯在HotSpot虚拟机上开发、部署程序的开发者来说，很多人都更愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。原则上，如何实现方法区属于虚拟机实现细节，不受虚拟机规范约束，但使用永久代来实现方法区，现在看来并不是一个好主意，因为这样更容易遇到内存溢出问题（永久代有-XX：MaxPermSize的上限，J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB，就不会出现问题），而且有极少数方法（例如String.intern（））会因这个原因导致不同虚拟机下有不同的表现。因此，对于HotSpot虚拟机，根据官方发布的路线图信息，现在也有放弃永久代并逐步改为采用Native Memory来实现方法区的规划了，在目前已经发布的JDK 1.7的HotSpot中，已经把原本放在永久代的字符串常量池移出。 Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说，这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是必要的。在Sun公司的BUG列表中，曾出现过的若干个严重的BUG就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。 根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 运行时常量池 运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 Java虚拟机对Class文件每一部分（自然也包括常量池）的格式都有严格规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern（）方法。 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 直接内存 直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。 在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。 6.2. 垃圾收集器与内存分配策略Java内存运行时区域，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。 判断对象已死 在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）。 (1)引用计数算法 很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。作者面试过很多的应届生和一些有多年工作经验的开发人员，他们对于这个问题给予的都是这个答案。 客观地说，引用计数算法（Reference Counting）的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，也有一些比较著名的应用案例，例如微软公司的COM（Component Object Model）技术、使用ActionScript 3的FlashPlayer、Python语言和在游戏脚本领域被广泛应用的Squirrel中都使用了引用计数算法进行内存管理。但是，至少主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。 (2)可达性分析算法 在主流的商用程序语言（Java、C#，甚至包括前面提到的古老的Lisp）的主流实现中，都是称通过可达性分析（Reachability Analysis）来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。如图3-1所示，对象object 5、object 6、object 7虽然互相有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。 在Java语言中，可作为GC Roots的对象包括下面几种：虚拟机栈（栈帧中的本地变量表）中引用的对象。方法区中类静态属性引用的对象。方法区中常量引用的对象。本地方法栈中JNI（即一般说的Native方法）引用的对象。 生存还是死亡 即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize（）方法。当对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。 如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize（）方法中执行缓慢，或者发生了死循环（更极端的情），将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。finalize（）方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第次小规模的标记。如果对象要在finalize（）中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。 需要特别说明的是，上面关于对象死亡时finalize（）方法的描述可能带有悲情的艺术色彩，笔者并不鼓励大家使用这种方法来拯救对象。相反，笔者建议大家尽量避免使用它，因为它不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。有些教材中描述它适合做“关闭外部资源”之类的工作，这完全是对这个方法用途的一种自我安慰。finalize（）能做的所有工作，使用try-finally或者其他方式都可以做得更好、更及时，所以笔者建议大家完全可以忘掉Java语言中有这个方法的存在。 垃圾收集算法 (1)标记-清除算法 最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。标记—清除算法的执行过程如下图所示。 (2)复制算法 为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。复制算法的执行过程如下图所示。 现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor 。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。 内存的分配担保就好比我们去银行借款，如果我们信誉很好，在98%的情况下都能按时偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有风险了。内存的分配担保也一样，如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。 (3)标记-整理算法 复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。 根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，“标记-整理”算法的示意图如下图所示。 (4)分代收集算法 当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。 垃圾收集器 如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。这里讨论的收集器基于JDK 1.7 Update 14之后的HotSpot虚拟机（在这个版本中正式提供了商用的G1收集器，之前G1仍处于实验状态），这个虚拟机包含的所有收集器如下图所示。 上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。 虽然我们是在对各个收集器进行比较，但并非为了挑选出一个最好的收集器。因为直到现在为止还没有最好的收集器出现，更加没有万能的收集器，所以我们选择的只是对具体应用最合适的收集器。这点不需要多加解释就能证明：如果有一种放之四海皆准、任何场景下都适用的完美收集器存在，那HotSpot虚拟机就没必要实现那么多不同的收集器了。 内存分配与回收策略 Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存。 对象的内存分配，往大方向讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配 ），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。 (1)对象优先在Eden分配 大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。 (2)大对象直接进入老年代 所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。大对象对虚拟机的内存分配来说就是一个坏消息（替Java虚拟机抱怨一句，比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，写程序的时候应当避免），经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。 (3)长期存活的对象将进入老年代 既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。 如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX：MaxTenuringThreshold设置。 (4)动态对象年龄判定 为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。 (5)空间分配担保 在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。 6.3. 类文件结构 代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。 时至今日，商业机构和开源机构已经在Java语言之外发展出一大批在Java虚拟机之上运行的语言，如Clojure、Groovy、JRuby、Jython、Scala等。使用过这些语言的开发者可能还不是非常多，但是听说过的人肯定已经不少，随着时间的推移，谁能保证日后Java虚拟机在语言无关性上的优势不会赶上甚至超越它在平台无关性上的优势呢？ 实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。基于安全方面的考虑，Java虚拟机规范要求在Class文件中使用许多强制性的语法和结构化约束，但任一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。作为一个通用的、机器无关的执行平台，任何其他语言的实现者都可以将Java虚拟机作为语言的产品交付媒介。例如，使用Java编译器可以把Java代码编译为存储字节码的Class文件，使用JRuby等其他语言的编译器一样可以把程序代码编译成Class文件，虚拟机并不关心Class的来源是何种语言，如下图所示。 Java语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的，因此字节码命令所能提供的语义描述能力肯定会比Java语言本身更加强大。因此，有一些Java语言本身无法有效支持的语言特性不代表字节码本身无法有效支持，这也为其他语言实现一些有别于Java的语言特性提供了基础。 Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。 根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表，后面的解析都要以这两种数据类型为基础，所以这里要先介绍这两个概念。 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表，它由下图所示的数据项构成。 6.4. 虚拟机类加载机制虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。 与那些在编译时需要进行连接工作的语言不同，在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的。 这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。例如，如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类；用户可以通过Java预定义的和自定义类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分，这种组装应用程序的方式目前已广泛应用于Java程序之中。从最基础的Applet、JSP到相对复杂的OSGi技术，都使用了Java语言运行期类加载的特性。 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3部分统称为连接（Linking），这7个阶段的发生顺序如下图所示。 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。注意，这里写的是按部就班地“开始”，而不是按部就班地“进行”或“完成”，强调这点是因为这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用、激活另外一个阶段。 虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。 类加载器可以说是Java语言的一项创新，也是Java语言流行的重要原因之一，它最初是为了满足Java Applet的需求而开发出来的。虽然目前Java Applet技术基本上已经“死掉”，但类加载器却在类层次划分、OSGi、热部署、代码加密等领域大放异彩，成为了Java技术体系中一块重要的基石，可谓是失之桑榆，收之东隅。 类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。 这里所指的“相等”，包括代表类的Class对象的equals（）方法、isAssignableFrom（）方法、isInstance（）方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。如果没有注意到类加载器的影响，在某些情况下可能会产生具有迷惑性的结果。 从Java虚拟机的角度来讲，只存在两种不同的类加载器： 一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。 从Java开发人员的角度来看，类加载器还可以划分得更细致一些，绝大部分Java程序都会使用到以下3种系统提供的类加载器。 启动类加载器（Bootstrap ClassLoader）：这个类将器负责将存放在＜JAVA_HOME＞\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。扩展类加载器（Extension ClassLoader）：这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载＜JAVA_HOME＞\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher $App-ClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader（）方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。这些类加载器之间的关系一般如下图所示。 上图展示的类加载器之间的这种层次关系，称为类加载器的双亲委派模型（ParentsDelegation Model）。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。 双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。 7. Java SE APIjava.applet 提供了需要创建一个小程序和用来跟其他小程序交流上下文的类。 java.awt 包含了所有用于创建用户界面和绘制图形和图像的类。 java.awt.color 提供了颜色空间的类。 java.awt.datatransfer 提供了应用程序内部和应用程序之间进行数据交换的接口和类。 java.awt.dnd 拖放功能是分布在许多提供一个与GUI中的显示元素逻辑相关的两个实体之间交换数据机制的用户界面系统中的直接操作动作。 java.awt.event 提供了处理由AWT组件激活的不同类型的事件的接口和类。 java.awt.font 提供了与字体相关的类和接口。 java.awt.geom 提供了定义和执行二维几何相关对象的Java 2D类。 java.awt.im 提供了输入法框架的类和接口。 java.awt.im.spi 提供了能开发可用于在任何Java运行环境的输入法的接口。 java.awt.image 提供了创建和修改图片的类。 java.awt.image.renderable 提供了生产呈现无关的图像类和接口。 java.awt.print 提供了通用的打印API的类和接口。 java.beans 包含了beans(基于JavaBean架构组件)开发相关的类。 java.beans.beancontext 提供了bean上下文相关的类和接口。 java.io 提供了通过数据流、序列化和文件系统进行的系统系统输入和输出。 java.lang 提供了Java编程语言基础设计的类。 java.lang.annotation 提供了支持Java编程语言的注释设备库 java.lang.instrument 提供了允许Java编程语言代理运行在JVM上的程序的服务。 java.lang.invoke java.lang.invoke包包含了直接提供Java核心类库和虚拟机的动态语言支持。 java.lang.management 提供了Java运行时监控和管理Java虚拟机和其他组件的管理接口。 java.lang.ref 提供了与垃圾回收器有限程度交互作用的引用对象类。 java.lang.reflect 提供了获取关于类和对象反射信息的类和接口。 java.math 提供了执行任意精度整数算法(BigInteger)和任意精度小数算法的类。 java.net 提供了实现网络应用程序的类。 java.nio 定义了缓冲器，它是数据容器，并且提供其他NIO包的概述。 java.nio.channels 定义了描述连接能够执行I/O操作的实体，例如文件和sockets。定义了多路复用且非阻塞I/O操作的选择器。 java.nio.channels.spi java.nio.channels包的服务提供者类。 java.nio.charset 定义了用于字节和统一编码字符之间转换的字符集、解码器和编码器。 java.nio.charset.spi java.nio.charset包的服务提供者类。 java.nio.file 定义了Java虚拟机访问文件、文件属性和文件系统的接口和类。 java.nio.file.attribute 提供访问文件和文件系统属性的接口和类。 java.nio.file.spi java.nio.file.spi包的服务提供者类。 java.rmi 提供了RMI包。 java.rmi.activation 为RMI对象激活提供支持。 java.rmi.dgc 提供了RMI分布式垃圾收集(DGC)的类和接口。 java.rmi.registry 提供了RMI注册表的一个类和两个接口。 java.rmi.server 提供了支持RMI的服务器端的类和接口。 java.security 提供了安全框架的类和接口。 java.security.acl 这个包里的类和接口已经取代了 in the java.security包的类。 java.security.cert 提供了解析和管理证书、证书废除列表(CRLs)和证书路径的类和接口。 java.security.interfaces 提供了生成在RSA实验室技术说明PKS#1中定义的RSA(Rivest，Shamir和Adleman AsymmetricCipher算法)密匙和在NIST’s FIPS-186中定义的DSA(数字信号算法)密匙的接口。 java.security.spec 提供了密匙规范和算法参数规范的类和接口。 java.sql 提供了使用Java编程语言访问和处理存储在一个数据源(通常是一个关系数据库)的API。 java.text 提供了语言无关的方式处理文本、日期、数字和信息的类和接口。 java.text.spi java.text包的服务提供者类。 java.time 日期、时间、时刻和时间段的主要API。 java.time.chrono 不同于默认ISO的日历系统的通用API。 java.time.format 提供了打印和解析日期和时间的类。 java.time.temporal 使用字段和单元和日期时间调整来访问日期和时间， java.time.zone 时区及其规则的支持。 java.util 包含了集合框架、遗留的集合类、事件模型、日期和时间工具、国际化和各种各样的工具类(一个字符编译器、一个随机数生成器和一个位数组)。 java.util.concurrent 用于并发编程的的公共工具类。 java.util.concurrent.atomic 支持单一变量无锁和线程安全的小工具类。 java.util.concurrent.locks 为锁定和等待不同的内置同步和监视器提供一个框架的类和接口。 java.util.function 为微积分表达式和方法引用提供目标类型的功能接口。 java.util.jar 提供了读写JAR(Java归档)文件格式，它是基于标准的的ZIP文件格式和一个可选清单文件的。 java.util.logging 为JavaTM2平台核心日志工具提供了类和接口。 java.util.prefs 此包允许应用程序存储并检索用户和系统首选项和配置数据。 java.util.regex 用于匹配违反了正则表达式指定模式的字符序列的类。 java.util.spi java.util包的服务提供者类。 java.util.stream 支持在如集合多核处理转换这样的元素流上的功能样式操作的类。 java.util.zip 提供了读写标准的ZIP和GZIP文件格式的类。 javax.accessibility 定义了用户界面组件和提供了访问其他组件的辅助技术之间的协议。 javax.activation javax.activity 包含了解组期间通过ORB机制抛出异常的相关活动服务。 javax.annotation javax.annotation.processing 声明注释处理器和允许注释处理器与注释处理工具环境通信的工具。 javax.crypto 提供了加密操作的类和接口。 javax.crypto.interfaces 提供了RSA实验室的PKCS#3中定义的Diffie-Hellman密钥接口。 javax.crypto.spec 提供了密匙规范和算法参数规范的类和接口。 javax.imageio Java 图像 I/O API 的主包。 javax.imageio.event 一个在读写图像期间Java 图像 I/O API处理同步通知的事件的包。 javax.imageio.metadata Java 图像 I/O API处理读写元数据的一个包。 javax.imageio.plugins.bmp 包含了用于内置BMP插件公共类的包。 javax.imageio.plugins.jpeg 支持内置JPEG插件的类。 javax.imageio.spi Java图像I/O API的包含阅读器、写入器、转码器和流，和一个运行时注册表的插件接口的包。 javax.imageio.stream Java图像I/O API处理低级文件和流的包。 javax.jws javax.jws.soap javax.lang.model 用于模拟Java编程语言的类和包层次结构。 javax.lang.model.element 用于模拟Java编程语言的元素接口。 javax.lang.model.type 用于模拟Java编程语言的类型的接口。 javax.lang.model.util 帮助在编程元素和类型过程中处理的实用程序。 javax.management 提供了Java管理拓展的核心类。 javax.management.loading 提供了实现高级动态加载的类。 javax.management.modelmbean 提供了ModelMBean类的定义。 javax.management.monitor 提供了监视器类的定义。 javax.management.openmbean 提供了开放数据类型和开放MNBeam描述符类。 javax.management.relation 提供了关系服务的定义。 javax.management.remote 远程访问JMX MBean服务器的接口。 javax.management.remote.rmi RMI连接器是一个使用RMI来传输客户端请求道一个远程MBean服务器的 JMX Remote API 连接器。 javax.management.timer 提供了MBean定时器的定义。 javax.naming 提供了访问命名服务的类和接口。 javax.naming.directory 扩展了he javax.naming包提供访问目录服务的功能。 javax.naming.event 提供了当访问命名和目录服务时支持事件通知。 javax.naming.ldap 提供了支持LDAPv3 扩展操作和控制。 javax.naming.spi javax.net 提供了网络应用的类。 javax.net.ssl 提供了安全套接字包。 javax.print 提供了Java打印服务API 的主要类和接口。 javax.print.attribute 提供了描述Java打印服务属性和如何将它们收集到属性集中的类和接口。 javax.print.attribute.standard javax.print.attribute.standard 包包含了特定打印属性的类。 javax.print.event javax.print.event包包含了事件类和监听接口。 javax.rmi 包含了RMI-IIOP的用户APIs。 javax.rmi.CORBA 包含了 RMI-IIOP的便携性APIs。 javax.rmi.ssl 提供了安全套接字层(SSL)或传输层安全(TLS)协议之上的RMIClientSocketFactory和RMIServerSocketFactory的实现。 javax.script 组成API脚本的和接口定义了Java TM脚本引擎并提供了它们在Java应用程序中使用的一个。框架 javax.security.auth 此包提供了验证和授权的框架。 javax.security.auth.callback 此包提供了为了检索信息(验证包含例如用户名或密码的数据)或者呈现信息(例如错误和警告信息)相作用的所需要的服务类。 javax.security.auth.kerberos 此包包含了Kerberos 网络验证协议相关的实用工具类。 javax.security.auth.login 此包提供了一个可插拔的认证框架。 javax.security.auth.spi 此包提供了用于实现可插入验证模块的接口。 javax.security.auth.x500 此包包含了可用于存储X500 Principal 和 X500私有证书的主题类。 javax.security.cert 提供了用于公钥证书的类。 javax.security.sasl 包含了支持SASL的类和接口。 javax.sound.midi 提供了I/O、 系列化和合成MIDI(音乐乐器数字接口)数据的接口和类。 avax.sound.midi.spi 提供接口当提供新的MIDI设备、MIDI文件读写器或音库读取器时服务提供者去实现。 javax.sound.sampled 提供了捕获、处理和音频数据取样回放的接口和类。 javax.sound.sampled.spi 当提供音频设备、声音文件读写器或音频格式转换器时提供抽象类给服务提供者作为子类。 javax.sql javax.sql.rowset JDBC RowSet实现的标准接口和基类。 avax.sql.rowset.serial 在Java编程语言中提供了允许SQL类型和数据类型之间序列化映射的实用工具类。 javax.sql.rowset.spi 给同步提供者的实现中使用的第三方供应商的标准类和接口。 javax.swing 提供了一组“轻量级”(纯Java语言)组件，最大程度的可能，在所有平台上进行同样的工作。 javax.swing.border 提供了围绕一个Swing组件绘制特殊边框的类和接口。 javax.swing.colorchooser 包含了供JColorChooser组件使用的类和接口。 javax.swing.event 提供了由Swing组件触发的事件。 javax.swing.filechooser 包含用于JFileChooser组件的类和接口。 javax.swing.plaf 提供一个接口和许多抽象类，Swing用它们来提供自己的可插入的外观和感觉功能。 javax.swing.plaf.basic 提供了根据基本外观构建的用户界面对象。 javax.swing.plaf.metal 提供根据Java外观(曾经代称为Metal)构建的用户界面对象，这是默认的外观和感觉。 javax.swing.plaf.multi 提供了组合两个或多个外观的用户界面对象。 javax.swing.plaf.nimbus 提供了根据跨平台的Nimbus外观构建的用户界面对象。 javax.swing.plaf.synth Synth是一个可更换皮肤的外观，其中所有绘制都是可委托的。 javax.swing.table 提供了处理 javax.swing.JTable.的类和接口。 javax.swing.text 提供了处理可编辑和不可编辑的文本组件的类和接口。 javax.swing.text.html) 提供了用于创.html)文本编辑器.html)EditorKit和支持类。 javax.swing.text.html).parser 提供了默认.html)解析器以及支持类。 javax.swing.text.rtf 提供一个类(RTFEditorKit)，用于创建富文本格式的文本编辑器。 javax.swing.tree 提供了处理 javax.swing.JTree的类和接口。 javax.swing.undo 允许开发者提供支持撤消/重做的应用，如文本编辑器。 javax.tools 提供le 可以从一个程序被调用的接口，例如编译器工具。 javax.transaction 包含解组期间ORB机制抛出的三个异常。 javax.transaction.xa 提供了事务管理和资源管理之间的协议的定义，这样允许事务管理在JTA事务中去获取和去除资源对象(由资源管理驱动程序提供)。 javax.xml javax.xml.bind 提供了一个运运行时绑定框架给客户端应用程序，包括解组、编组和验证功能。 javax.xml.bind.annotation 定义为XML模式映射定义Java变成元素的注释 javax.xml.bind.annotation.adapters XmlAdapter及其规范定义的子类允许任意Java类与JAXB一起使用。 javax.xml.bind.attachment javax.xml.bind.helpers JAXB提供者专用：提供部分默认实现一些 the javax.xml.bind接口。 javax.xml.bind.util 有用的客户端实用工具类。 javax.xml.crypto XML加密通用类。 javax.xml.crypto.dom javax.xml.crypto包的DOM特定类。 javax.xml.crypto.dsig 用于生成和验证XML数字签名的类。 javax.xml.crypto.dsig.dom javax.xml.crypto.dsig包的DOM特定类。 javax.xml.crypto.dsig.keyinfo 解析和处理KeyInfo元素和结构的类。 javax.xml.crypto.dsig.spec XML数字签名的参数类。 javax.xml.datatype XML/Java类型映射。 javax.xml.namespace XML命名空间的处理。 javax.xml.parsers 提供允许处理XML文档的处理的类。 javax.xml.soap 提供用于创建和构建SOAP消息的API。 javax.xml.stream javax.xml.stream.events javax.xml.stream.util javax.xml.transform 此包定义了用于处理转换指令，以及执行从源到结果的转换的一般API。 javax.xml.transform.dom 此包实现特定DOM的转换API。 javax.xml.transform.sax 此包实现了特定SAX2的转换API。 javax.xml.transform.stax 提供了特定的StAX的转换API。 javax.xml.transform.stream 此包实现了流和特定URI转换API。 javax.xml.validation 此包提供了用于XML文档验证的API。 javax.xml.ws 此包包含核心JAX-WS的API。 javax.xml.ws.handler 此包定义了消息处理程序的API。 javax.xml.ws.handler.soap 此包定义了SOAP消息处理程序的API。 javax.xml.ws.http 此包定义了特定于HTTP绑定的API。 javax.xml.ws.soap 此包定义了特定于SOAP绑定的API。 javax.xml.ws.spi 此包定义了JAX-WS的SPI。 javax.xml.ws.spi.http 提供了一个用于便携式容器部署JAX-WS Web服务(如用于HTTP SPI 提供了一个HTTP SPI用于在容器中JAX-WS服务的便携式部署(例如..)。 javax.xml.ws.wsaddressing 此包定义了WS-Addressing相关的API。 javax.xml.xpath 此件包为XPath表达式的访问评估和访问评估环境提供了对象模型中立的API。 org.ietf.jgss 此包提供了一个框架，允许应用程序开发人员使用安全服务，如身份验证，数据完整性和数据保密性的各种如Kerberos基础安全机制，采用了统一的API。 org.omg.CORBA 提供OMG CORBA API到JavaTM的编程语言的映射，包括ORB类，它已经实现，因此程序员可以使用它作为一个全功能对象请求代理(ORB)。 org.omg.CORBA_2_3 CORBA23包定义添加到Java(TM)标准版6现有的CORBA接口。这些改变发生在最近的由OMG定义的CORBA API版本。这些新的方法被添加到从在CORBA包中的相应接口派生的接口。这提供向后兼容性和避免断JCK测试。 org.omg.CORBA_2_3.portable 提供输入和输出值类型的方法，并包含其他更新的org/omg/CORBA便携包。 org.omg.CORBA.DynAnyPackage 提供了用DynAny接口((InvalidValue, Invalid, InvalidSeq, and TypeMismatch)方式使用的异常。 org.omg.CORBA.ORBPackage 提供了InvalidName异常，这是由ORB方法抛出的，保留最初参数和InconsistentTypeCode异常，这是由ORB类中的动态Any创建的方法抛出的。 org.omg.CORBA.portable 提供可移植性层，即一组ORB API，这些API可以使一个供应商生成到另一个供应商的ORB运行代码。 org.omg.CORBA.TypeCodePackage 提供用户定义的异常BadKind和Bounds，它们通过方法TypeCode类中抛出。 org.omg.CosNaming 为Java IDL提供命名服务。 org.omg.CosNaming.NamingContextExtPackage 此包包含以下类，它们用于org.omg.CosNaming.NamingContextExt。 org.omg.CosNaming.NamingContextPackage 此包包含了 org.omg.CosNaming 包的异常类。 org.omg.Dynamic 此包包含了OMG移植拦截规范中的特定动态模块。 org.omg.DynamicAny 提供了能够遍历与任何运行时关联的数据值，并能提取出数值的原始成分的类和接口。 org.omg.DynamicAny.DynAnyFactoryPackage 此包包含了 DynAnyFactory接口中来自OMG的公共对象请求代理的定的DynamicAny模块的类和异常：结构和规范。 org.omg.DynamicAny.DynAnyPackage 此包包含了 DynAny接口中来自OMG的公共对象请求代理的定的DynamicAny模块的类和异常：结构和规范。 org.omg.IOP 此包包含了这个软件包包含了OMG文档中的通用对象请求代理指定的IOP模块：结构和规范。 org.omg.IOP.CodecFactoryPackage 此包包含了IOP :: CodeFactory接口中指定的异常(作为Portable Interceptor规范的一部分)。 org.omg.IOP.CodecPackage 这个包是从IOP ::编解码器IDL接口定义生成。 org.omg.Messaging 此包包含了CORBA消息规范中的特定消息模块。 org.omg.PortableInterceptor 提供了一个注册ORB钩子通过ORB服务可以截取执行ORB的正常流动的机制。 org.omg.PortableInterceptor.ORBInitInfoPackage 此包包含了来自OMG移植拦截规范中的HTTP指定的PortableInterceptor模块的ORBInitInfo本地接口的异常和类型定义。 org.omg.PortableServer 提供使您的应用程序移植的服务器端跨多个供应商ORB的类和接口。 org.omg.PortableServer.CurrentPackage 供方法实现能够访问被调用的方法的对象的身份。 org.omg.PortableServer.POAManagerPackage 封装POA关联的处理状态 org.omg.PortableServer.POAPackage 允许程序员构造便携不同ORB产品间对象实现。 org.omg.PortableServer.portable 提供使您的应用程序移植跨多个供应商ORB的服务器端的类和接口。 org.omg.PortableServer.ServantLocatorPackage 提供定位servant的类和接口。 org.omg.SendingContext 为值类型的编组提供支持。 org.omg.stub.java.rmi 包含RMI-IIOP Stubs给发生在 java.rmi包的远程类型。 org.w3c.dom 为文档对象模型(DOM)提供接口。 org.w3c.dom.Bootstrap org.w3c.dom.events org.w3c.dom.ls org.w3c.dom.views org.xml.sax 此包提供了核心SAX API。 org.xml.sax.ext 此包包含SAX2设施的接口，一致性的SAX驱动程序不一定支持。 org.xml.sax.helpers 此包包含“帮助器”类，其中包括对引导基于SAX的应用程序的支持。 8. 后记本篇博客主要介绍了Java的历史，Java SE，Java Card，Java ME，Java EE，Java虚拟机。希望能对Java有一个系统的认识，避免出现概念上的认知偏差，方便以后进一步深入学习。 9. 参考文献BruceEckel. Java编程思想:第4版[M]. 机械工业出版社, 2007.周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）[M]. 机械工业出版社, 2013.《JavaCard 应用程序开发三部曲》詹建飞. Java ME核心技术与最佳实践[M]. 电子工业出版社, 2007.郝玉龙, 周旋. Java EE核心技术与应用[M]. 电子工业出版社, 2013.李刚. 经典Java EE企业应用实战:基于WebLogi/JBoss的JSF+EJB+JPA整合开发[M]. 电子工业出版社, 2010.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>转载</tag>
        <tag>学习</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于NI-VISA获取示波器波形数据]]></title>
    <url>%2F2016%2F07%2F21-lecroy-ni-visa-get-and-control-wave-trc%2F</url>
    <content type="text"><![CDATA[基于NI-VISA获取示波器波形数据实验室在做一个故障检测的项目，需要读取485串口发来的数据，为此使用了鼎阳的示波器SDS3054来获取和记录波形。示波器可以在触发信号下记录一次波形，但是项目要求波形能够远程实时获取和保存，并且能持续的记录。示波器支持NI-VISA编程，这就可以编程来实现示波器的控制。而NI-VISA的资料在网上也很少，费劲很大周折才搞出了这个一个小DEMO。在这过程中，也认识到查阅官方英文文档和直接使用搜索引擎之间的不同。如果有人需要其他帮助的，可以联系我。 项目背景以下摘自百度：NI-VISA(Virtual Instrument Software Architecture，以下简称为”VISA”)是美国国家仪器 NI(National Instruments VISA)公司开发的一种用来与各种仪器总线进行通信的高级应用编程接口。VISA总线I/O软件是一个综合软件包，不受平台、总线和环境的限制，可用来对USB、GPIB、串口、VXI、PXI和以太网系统进行配置、编程和调试。VISA是虚拟仪器系统I/O接口软件。基于自底向上结构模型的VISA创造了一个统一形式的I/O控制函数集。一方面，对初学者或是简单任务的设计者来说， VISA提供了简单易用的控制函数集，在应用形式上相当简单; 另一方面，对复杂系统的组建者来说，VISA提供了非常强大的仪器控制功能与资源管理。 简单将，NI-VISA屏蔽了底层的硬件细节，程序员只需要调用NI-VISA提供的函数和API，以及相关的SCPI指令集，就可以完成对示波器等设备的控制。这也不得不佩服做底层的工程师。 项目需求项目需要控制示波器完成： 在外源触发信号的控制下，示波器工作在single模式下，记录触发信号通道，485串口数据通道的波形，并且在触发信号（一个小方波，上升沿触发）到来时，保存当前的波形。并且可以被实时的远程获取，且在获取到这一帧波形时，能自动的继续记录下一次波形。 项目源码项目中需要研究厂家的示波器保存文件TRC的文件格式，这里借鉴了一个外国网站上的Matlab代码下载：main.m ReadLeCroyBinaryWaveform.m 这个项目开发IDE为VS2013，开发语言为C（C++），需要安装好NI-VISA的相关软件，可以在官网Teledyne Lecroy下载示波器Oscilloscope软件。同时采用的是网络方式进行远程控制，需要配置安装好LeCroyVICPPassport.dll（官网也能下载到），当然也可以使用USB控制方式，不过只要改动连接命令即可，这个官方手册可以查询（需要手册可以联系我）。 提供main.cpp，需要完整源码包的联系我下载。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184#include "main.h"int main(int argc, char *argv[])&#123; char addr[100] = &#123; 0 &#125;; char source[10][5] = &#123; 0 &#125;; int src_num = 0; if (argc &lt; 3)&#123; plog("Usage: Get waveforms from an oscilloscope.\n"); plog("Tips: Should be used in cmd mode.\n"); plog("Format: [ADDR][SOURCE1][SOURCE2][SOURCE3]...\n"); plog("Example:\n\tVICP::192.168.1.133 C1 C2 Z1 Z2\n\tUSB0::0x05FF::0x1023::SDS300B21443023::INSTR C1 C2 Z1 Z2\n"); plog("\nPress any key to exit...\n"); getchar(); return -1; &#125; else&#123; //此处需要添加addr地址合法性、通道名有效性判断 char tmp[100] = &#123; 0 &#125;; src_num = argc-2; strcpy(addr, argv[1]); int m = 0; for (; m &lt; argc-2; m++)&#123; memset(tmp, 0, sizeof(tmp)); strcpy(tmp, argv[m+2]); strcpy(source[m], _strupr(tmp)); &#125; &#125; plog("ADDR:%s SOURCES(%d):",addr,src_num); for (int t = 0; t &lt; src_num;t++)&#123; plog("%s ",source[t]); &#125; printf("\n"); //开始工作 ViSession default_RM = -1; //default_resource_manager ViSession ins = -1; //instrument ViStatus stat = -1; //status ViUInt32 rt_cnt = -1; //read_count(or return_count) ViUInt32 wt_cnt = -1; //write_count static unsigned char str_rt_buf[RT_BUF_SIZE] = &#123; 0 &#125;; //read_buf_size static unsigned char str_wt_buf[WT_BUF_SIZE] = &#123; 0 &#125;; //write_buf_size fflush(stdin); fflush(stdout); //Open a session and find resources if (fun_visa_viConnect(&amp;default_RM, addr, str_rt_buf, &amp;ins) == -1)&#123; goto ERR; &#125; //设置一些属性，如超时时间等 //属性设置前需要询问当前设置，设置完后也需要再次询问设置，以确认设置成功 //stat=viSetAttribute(); if (fun_visa_viPrintf(&amp;ins, "CHDR OFF;CORD HI;CFMT DEF9,WORD,BIN\n","E001") == -1)&#123; goto ERR; &#125; if (fun_visa_viPrintf(&amp;ins, "WFSU SP,0,NP,0,FP,0,SN,0\n", "E002") == -1)&#123; goto ERR; &#125; //获取波形数据并保存 //建议用多线程实现 //示波器触发频率不宜太频繁(即假设错误发生是偶然的) int rts = -1; int m = 0; char s_vbs_rt[100] = &#123; 0 &#125;; char s_vbs_wt_ask[100] = &#123; 0 &#125;; char s_vbs_wt_set[100] = &#123; 0 &#125;; char filename[30] = &#123; 0 &#125;; char time_tmp[20] = &#123; 0 &#125;; char err_str[100] = &#123; 0 &#125;; int err_times = 0; strcat(s_vbs_wt_ask, "VBS? 'Return=app.Acquisition.TriggerMode'\n"); strcat(s_vbs_wt_set, "VBS 'app.Acquisition.TriggerMode=\"Single\"'\n"); while (1)&#123; err_times = 0; //循环询问示波器是否进入‘stopped’状态 memset(time_tmp, 0, sizeof(time_tmp)); get_timeNow(time_tmp, sizeof(time_tmp)); plog("\n[%s] Waiting for trigger 'Stopped'...\n", time_tmp); while (1)&#123; memset(time_tmp, 0, sizeof(time_tmp)); get_timeNow(time_tmp, sizeof(time_tmp)); memset(err_str, 0, sizeof(err_str)); strcat(err_str, " ["); strcat(err_str, time_tmp); strcat(err_str, "]ask for trigger 'Stopped'"); memset(s_vbs_rt, 0, sizeof(s_vbs_rt)); if(fun_visa_viQuerf(&amp;ins, (unsigned char *)s_vbs_wt_ask, (unsigned char *)s_vbs_rt, err_str) == -1)&#123; err_times++; &#125; if (err_times == 5)&#123; goto ERR; &#125; if (findstr(s_vbs_rt,"Stopped") &gt;= 0)&#123; plog("[%s] Get trigger 'Stopped'!\n",time_tmp); break; &#125; Sleep(1000); &#125; //休息一秒，让示波器显示波形，从而各个缓冲区均有数据 Sleep(1000); //根据Source数量依次获取波形数据并保存 for (m = 0; m &lt; src_num; m++)&#123; rts = -1; memset(filename, 0, sizeof(filename)); strcat(filename,time_tmp); strcat(filename, "_"); strcat(filename, source[m]); strcat(filename, ".trc"); rts = fun_main_viGetWaveFromScopeAndSave(&amp;ins, source[m], str_wt_buf, str_rt_buf, filename); if (rts == 0) &#123; plog("Waveform in source %s has saved into file '%s'!\n", source[m], filename); &#125; else&#123; plog("Waveform data in source %s failed\n",source[m]); &#125; //需要休息会，让示波器上一个通道缓冲区重置，顺便让计算机写入文件 Sleep(200); &#125; err_times = 0; //重新设置示波器为‘single’状态，注意示波器不宜触发太过频繁 memset(time_tmp, 0, sizeof(time_tmp)); get_timeNow(time_tmp, sizeof(time_tmp)); plog("[%s] Switch trigger into 'Single'...\n", time_tmp); while (1)&#123; memset(time_tmp, 0, sizeof(time_tmp)); get_timeNow(time_tmp, sizeof(time_tmp)); memset(err_str, 0, sizeof(err_str)); strcat(err_str, " ["); strcat(err_str, time_tmp); strcat(err_str, "]switch trigger into 'Single'"); memset(s_vbs_rt, 0, sizeof(s_vbs_rt)); fun_visa_viPrintf(&amp;ins,s_vbs_wt_set, err_str); Sleep(2000); if(fun_visa_viQuerf(&amp;ins, (unsigned char *)s_vbs_wt_ask, (unsigned char *)s_vbs_rt, err_str)==-1)&#123; err_times++; &#125; if (err_times == 5)&#123; goto ERR; &#125; if (findstr(s_vbs_rt, "Single") &gt;= 0)&#123; plog("[%s] Get trigger 'Single'!\n", time_tmp); break; &#125; Sleep(1000); &#125; &#125;ERR: stat = viClose(ins); stat = viClose(default_RM); fflush(stdin); fflush(stdout); plog("\nProgram exited.\n"); return 0;&#125; 项目测试设置示波器的IP，并使得远程计算机和示波器最好在同一网络区域中。打开示波器设置面板，选择VICP方式，可以获得设备IP地址。 在CMD中运行编译好的程序，比如scope.exe。 485的数据通过差分探头接在示波器的C1和C2通道上，触发信号接在C3通道上。 &gt; scope VICP::192.168.1.133 C1 C2 C3 之后程序就能自动的获取持续的波形了。 （以上过程截图均省略） 完]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>示波器</tag>
        <tag>NI-VISA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求最小公倍数和最大公约数]]></title>
    <url>%2F2016%2F07%2F08-lcm-gcd-algorithm%2F</url>
    <content type="text"><![CDATA[求最小公倍数和最大公约数这个是算法中的基础题目了，在此记录一下。 公共函数求两数最小：123public static int min(int i, int j) &#123; return i &gt; j ? j : i;&#125; 求两数最大：123public static int max(int i, int j) &#123; return i &gt; j ? i : j;&#125; 最大公约数暴力求解法暴力法求解：从两个数中的最小的一个开始，逐次递减，每次都进行判断是不是这两个数的公约数。若是，则直接返回，此时返回的即为最大公约数。补充：自然数1是任意两个正整数的约数。123456public static int zdgys1(int i, int j) &#123; for (int p = min(i, j); p &gt; -1; p--) if (i % p == 0 &amp;&amp; j % p == 0) return p; return 1;&#125; 辗转相除法1、辗转相除法(欧几里得算法) - 1辗转相除法又称为欧几里得算法，这里是用循环的做法。1234567891011public static int zdgys2(int i, int j) &#123; int m = min(i, j); int n = max(i, j); while (true) &#123; if (m == 0) return n; int t = m; m = n % m; n = t; &#125;&#125; 2、辗转相除法(欧几里得算法) - 2这里是用递归的做法。1234567891011public static int zdgys3(int i, int j) &#123; int m = min(i, j); int n = max(i, j); return gcd(m, n);&#125; private static int gcd(int m, int n) &#123; if (m == 0) return n; return gcd(n % m, m);&#125; 最小公倍数暴力求解法做法和求最大公约数类似，通过循环加判断。12345678public static int zxgbs2(int i, int j) &#123; int m = max(i, j); for (; m &lt; i * j; m++) &#123; if (m % i == 0 &amp;&amp; m % j == 0) return m; &#125; return m;&#125; 使用最大公约数使用公式：lcm = ( i * j / gcd( i , j ) )123public static long zxgbs2(int i, int j) &#123; return i * j / zdgys2(i, j);&#125; 方法测试123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void start() &#123; cut = System.currentTimeMillis();&#125;public static void end() &#123; System.out.println("spend: " + (System.currentTimeMillis() - cut));&#125;private static long cut = 0l;// 最大公约数、最小公倍数public static void main(String[] args) &#123; start(); System.out.println(zdgys1(1123123124, 21123324)); end(); start(); System.out.println(zdgys1(7, 4)); end(); start(); System.out.println(zdgys2(1123123124, 21123324)); end(); start(); System.out.println(zdgys2(7, 4)); end(); start(); System.out.println(zdgys3(15, 40)); end(); start(); System.out.println(zxgbs1(5, 8)); end(); start(); System.out.println(zxgbs2(5, 8)); end(); start(); System.out.println(qmqm(5, 8, 17)); end();&#125; 测试结果4spend: 801spend: 04spend: 01spend: 15spend: 140spend: 140spend: 1 完]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Ubuntu服务器中安装和配置VirtualBox]]></title>
    <url>%2F2016%2F07%2F03-use-vbox-on-linux%2F</url>
    <content type="text"><![CDATA[在Ubuntu服务器中安装和配置VirtualBox实验室购置了两台服务器，原本是将所有的业务都装在了物理机上，也供其他的成员学习使用。时间长了后发现，这样的“一篮子鸡蛋”做法不可取，存在安全问题。为此学习了服务器安装虚拟机的方法，这之中也走了不少弯路。最终，实现将业务分离在不同的虚拟机上，且当有成员需要服务器进行学习时，也能提供独立的平台和故障恢复功能，管理起来很方便。 配置环境和软件：Ubuntu 14.04 64位Oracle VirtualBox 5.x 安装和配置过程准备环境安装Ubuntu安装Ubuntu服务器版，这里不做阐述。实验室服务器安装的时Ubuntu 14.04 LTS 64位版本，且服务器需要支持虚拟化（一般支持）。 安装VirtualBox安装Linux版的VirtualBox，并做简单的配置进入Oracle VirtualBox官网，下载与系统对应的Linux版本的VirtualBox。我这里时Ubuntu 14.04，因此下载Ubuntu 14.04 (“Trusty”) / 14.10 (“Utopic”) / 15.04 (“Vivid”)中AMD64版本，下载好deb包即可。当然也可以使用apt安装方式，官网有详细说明。 安装VirtualBox：&gt; sudo apt-get update&gt; sudo dpkg -i virtualbox-5.xxx-Ubuntu-trusty_amd64.deb如果安装出现错误&gt; sudo at-get -f install再执行dpkg即可 另外需要下载好 VirtualBox 5.xxx Oracle VM VirtualBox Extension Pack 包。建议也下载好官网上的帮助手册（下载）。 设置VirtualBox因为服务器是纯命令行界面，不能像桌面VirtualBox那样方便鼠标点击，所以设置均需要使用命令，好在VBox的命令也很强大。 1、安装一同下载好的VIrtualBox的扩展包。 &gt; vboxmanage extpack install Oracle_VM_VirtualBox_Extension_Pack-5.xxx.vbox-extpack 2、可以修改虚拟机的安装路径。 &gt; vboxmanage setproperty machinefolder “存放虚拟机安装位置的目录” 3、设置VRDE auth library。虚拟机安装系统时，可以对其进行远程登陆显示，就好像安装了一个远程显示器一样，方便操作。这里建议在局域网中安装虚拟机系统，因为VRDE并不是很安全，且安装好后也需要关闭对应的虚拟机的VRDE的功能。 &gt; vboxmanage setproperty vrdeauthlibrary “VBoxAuthSimple” 4、 设置VBox开启自启动这样可以使得Ubuntu物理机服务器启动时，虚拟机也能定时启动。 &gt; vboxmanage setproperty autostartdbpath /etc/vbox 使用VirtualBox在VirtualBox中安装Ubuntu Server注：安装部分 参考1 参考2 参考3 1、进入到VirtualBox的虚拟机安装目录。默认是/home/用户名下的VirtualBox VMs 目录，如果更改了VirtualBox的设置，则进入设置中的Default machine folder配置的虚拟机安装目录。 确保安装目录的可读写权限。 2、新建目录，设置为安装系统的存储路径，比如ubuntu-vm-server-01 &gt; mkdir ubuntu-vm-server-01&gt; cd ubuntu-vm-server-01 3、新建一个大小为100G的vdi磁盘（–size 单位 M）。默认使用动态增加的方式，简单讲就是虚拟机系统用多少就占多少实际物理硬盘空间（只可增不会减），而虚拟机系统会认为磁盘大小为100G。 &gt; vboxmanage createmedium disk –filename ubuntu-vm-server-01.vdi –size 102400 4、新建vbox虚拟机文件并注册（–ostype 设置系统格式）。可以使用vboxmanage list ostypes查看vbox支持的系统格式。 &gt; vboxmanage createvm –name ubuntu-vm-server-01.vdi–ostype “Ubuntu_64” –register 5、新建SATA磁盘控制器并将3中新建的vdi磁盘绑定到该虚拟机。 &gt; vboxmanage storagectl ubuntu-vm-server-01–name “SATA Controller” –add sata –controller IntelAHCI&gt; vboxmanage storageattach ubuntu-vm-server-01 –storagectl “SATA Controller” –port 0 –device 0 –type hdd –medium ubuntu-vm-server-01.vdi 6、新建IDE控制器，设置它为dvd，并绑定系统ios文件到该dvd。注：–medium为你的iso路径。 &gt; vboxmanage storagectl ubuntu-vm-server-01–name “IDE Controller” –add ide&gt; vboxmanage storageattach ubuntu-vm-server-01–storagectl “IDE Controller” –port 0 –device 0 –type dvddrive –medium /home/downloads/ubuntu-14.04.4-server-amd64.iso 7、查看自己的网卡信息，并设置虚拟机的网卡为桥接方式（bridged）。 &gt; ifconfig输出：eth0 Link encap:Ethernet HWaddr f4:4d:30:1b:34:e1 inet addr:192.168.100.8 Bcast:192.168.100.255 Mask:255.255.255.0 将虚拟机的第一块“网卡”nic1和eth0绑定。 &gt; vboxmanage modifyvm ubuntu-vm-server-01–nic1 bridged –bridgeadapter1 eth0 8、设置虚拟机的IO控制，启动项顺序，内存大小，CPU数量，显存大小等其他设置（可以参考手册）。注：安装系统时先设置dvd为第一启动项，disk为第二启动项，安装好后再掉过来。 &gt; vboxmanage modifyvm ubuntu-vm-server-01 –ioapic on&gt; vboxmanage modifyvm ubuntu-vm-server-01 –boot1 dvd –boot2 disk –boot3 none –boot4 none&gt; vboxmanage modifyvm ubuntu-vm-server-01 –memory 2048 –vram 128 9、设置远程桌面访问。可以使用Windows自带的远程桌面连接程序连接虚拟机，也可以使用Ubuntu桌面版自带的Remmina remote desktop client。vrde模式的认证库是VBoxAuth，使用系统的用户来认证。官方文档还提供了一个VBoxAuthSimple认证库。这里设置成VBoxAuthSimple认证库： # 设定vrdeauthtype为external&gt; vboxmanage modifyvm ubuntu-vm-server-01 –vrdeauthtype external# 设定vrdeauthlibrary 为 VBoxAuthSimple&gt; vboxmanage modifyvm ubuntu-vm-server-01 –vrdeauthlibrary VBoxAuthSimple# 生成加密的密码字串，比如我要设定一个密码为 1234&gt; vboxmanage internalcommands passwordhash “1234”# 输出，复制加密的密码字串&gt; Password hash: XXXXXXX# 添加一个VBoxAuthSimple用户，用户名：test 密码：1234&gt; vboxmanage setextradata ubuntu-vm-server-01 “VBoxAuthSimple/users/test” XXXXXXX# 开启vrde服务&gt; vboxmanage controlvm ubuntu-vm-server-01 vrde on vrdeport 3389 vrde服务可以在虚拟机运行时动态开启和关闭。 这样可以设置一些与系统用户无关的用户和密码用于远程桌面登陆。 另外，Windows使用远程登陆时需要注意，如果登陆一直卡在准备阶段，需要在连接设置里勾选上允许我保存凭证。 10、启动虚拟机。万事具备，启动虚拟机开始安装。因为服务器没有桌面程序，所以需要使用headless方式启动。 &gt; vboxmanage startvm ubuntu-vm-server-01 –type=headless 11、现在就可以用rdesktop远程连接虚拟机了连接的 IP为服务器IP，端口为3389，需要确保服务器的防火墙3389可访问。 &gt; rdesktop localhost:3389 12.安装完成后需要修改启动项顺序，并退出dvd上的iso，可以关闭vrde。 &gt; vboxmanage storageattach ubuntu-vm-server-01 –storagectl “IDE Controller” –port 0 –device 0 –type dvddrive –medium none 在VirtualBox中安装其他操作系统大致安装过程和安装Ubuntu Server类似，我的建议是可以参照桌面版的VirtualBox安装其他操作系统的方式来反推命令的设置。 常用命令 vboxmanage controlvm &lt;uuid|vmname&gt;pause | resume | reset | poweroff | savestate| acpipowerbutton | acpisleepbutton | 其他事项实现VirtualBox开机自启动1、 在/etc/default中新建virtualbox文件 &gt; sudo vim /etc/default/vbox 添加如下内容 VBOXAUTOSTART_DB=/etc/vboxVBOXAUTOSTART_CONFIG=/etc/vbox/autostart.conf 2、 设置vbox目录的权限，添加vbox用户到vboxusers用户组 &gt; sudo chgrp vboxusers /etc/vbox&gt; sudo chmod 1775 /etc/vbox&gt; sudo adduser vbox vboxusers 3、 新建虚拟机自动启动配置文件autostart.conf并添加如下内容 &gt; sudo vim /etc/vbox/autostart.conf # default policy is to deny starting a VM, the other option is “allow”.default_policy = deny# user vbox is allowed to start virtual machines but starting them# will be delayed for 120 secondsvbox= { allow = true startup_delay = 120} 4、 设置开启自动启动设置成功后会在/etc/vbox目录下生成vbox.start文件。 &gt; vboxmanage setproperty autostartdbpath /etc/vbox&gt; vboxmanage modifyvm ubuntu-vm-server-01 –autostart-enabled on 如果最后一步出现以下类似的错误，那么需要用这个命令groups vbox确认vbox用户已经添加到vboxusers组中，而且vbox对/etc/vbox有写权限。 VBoxManage: error: Adding machine ‘ubuntu-vm-server-01’ to the autostart database failed with VERR_ACCESS_DENIED 设置虚拟机的快照快照是一个很好的功能，可以备份系统的状态，在虚拟机因病毒或者黑客破坏后，也能迅速恢复到备份时的状态。新建快照 &gt; vboxmanage snapshot ubuntu-vm-server-01 take “snapshot-001”; 删除快照 会将虚拟机的修改写入磁盘 &gt; vboxmanage snapshot ubuntu-vm-server-01 delete “snapshot-001”; 回滚快照 恢复虚拟机到备份时的状态&gt; vboxmanage snapshot ubuntu-vm-server-01 restore “snapshot-001”; 复制虚拟机安装好虚拟机系统后，再开一个虚拟机新安装系统很麻烦，可以使用虚拟机复制。 方法一：使用vboxmanage clonevm 将现有的系统克隆。&gt; vboxmanage clonevm “”ubuntu-vm-server-02” –name “ubuntu-vm-server-01” –register使用vboxmanage list vms查看到新的虚拟机已经复制成功。 方法二：使用vboxmanage clonehd 复制vdi磁盘。首先：&gt; vboxmanage clonehd ubuntu-vm-server-01.vdi ubuntu-vm-server-02..vdi会生成一个新的UUID但内容一样的磁盘，复制到ubuntu-vm-server-02目录下，进入ubuntu-vm-server-02目录，然后就和使用VirtualBox部分差不多，区别是不用再安装系统，使用磁盘即可。 完]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>服务器</tag>
        <tag>VirtualBox</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java核心技术--卷I]]></title>
    <url>%2F2016%2F06%2F22-book-javahxjs1%2F</url>
    <content type="text"><![CDATA[Java核心技术–卷I终于看完这本书了，看的中文版，文字读起来有些别扭，不过结合看过的毕老师的JavaSE视频，也是有所收获。 每章小结第一章 Java程度设计概述1234561.1 Java程序设计平台1.2 Java&quot;白皮书&quot;的关键术语简单性，面对对象，网络技能，健壮性，安全性，体系结构中立，可移植性，解释型，高性能，多线程，动态性1.3 Java Applet 与 Internet1.4 Java发展简史1.5 关于Java的常见误解 第二章 Java程序设计环境1234562.1 安装Java开发工具箱2.2 选择开发环境2.3 使用命令行工具2.4 使用集成开发环境(IDE)2.5 运行图形化应用程序2.6 建立并运行Applet 第三章 Java的基本程序设计结构12345678910111213141516173.1 一个简单的Java应用程序3.2 注释3.3 数据类型整形，浮点类型，char类型，boolean类型3.4 变量变量的初始化，常量3.5 运算符自增运算符与自减运算符，关系运算符与boolean运算符，位运算符，数学函数与常量，数值类型之间的转换，强制类型转换，括号与运算符级别，枚举类型3.6 字符串子串，拼接，不可变字符串，检测字符串是否相等，空串与Null串，代码点与代码单元，字符串API，阅读联机API文档，构建字符串3.7 输入输出读取输入，格式化输出，文件输入与输出3.8 控制流程块作用域，条件语句，循环，确定循环，多重选择:switch语句，中断控制流程语句(continue,break)3.9 大数值3.10 数组foreach 循环，数组初始化以及匿名数组，数组拷贝，命令行参数，数组排序，多维数组，不规则数组 第四章 对象与类12345678910111213141516171819202122234.1 面对对象程序设计概述(OOP)类（Class），对象（Object，行为behavior，状态state，标识identity），识别类，类之间的关系(依赖uses-a，聚合has-a，继承is-a)构造（Construct），实例（Instance），封装（Encapsulation，数据隐藏，黑盒），实例域（instance field），方法（method），状态（state），继承（Inheritance）Algorithms+Data Structures=Programs面向过程，算法第一位，数据结构第二位面向对象，数据第一位，算法第二位4.2 使用预定义类对象与对象变量，更改器方法与访问类方法4.3 用户自定义类多个源文件的使用，从构造器开始，隐式参数与显式参数，封装的优点(getXXX,setXXX，数据private)，基于类的访问权限，私有方法，final实域类4.4 静态域与静态方法(static)静态域，静态常量，静态方法，工厂方法，main方法4.5 方法参数Java目前只有值传递，没有C语言内的地址传递。Java引用居多。4.6 对象构造重载(重载解析，overloading resolution)，默认域初始化(尽量显式赋初值)，无参数的构造器，显示域初始化，参数化（this），调用另一个构造器，初始化块(initialization block)，对象析构与finalize方法4.7 包类的导入(import)，静态导入(静态方法，静态域)，将类放入包中，包的作用域4.8 类路径4.9 文档注释（javadoc）注释的插入，类注释，方法注释，域注释，通用注释，包与概述注释，注释的抽取4.10 类设计技巧保障数据私有(private)，显式的数据初始化，类内数据需要认真设计，类间关系想想清楚，类内关联降低，不是所有的类都需要set和get，类的分解恰当，类和方法名要与实际对应。 第五章 继承12345678910111213141516171819205.1 类、超类（superclass,baseclass,parentclass）和子类(subclass,derivedclass,childclass)继承（Inheritance，复用,拓展,覆盖override）层次（inheritance hierarchy），多态（子类对象赋给超类变量，但不能将超类的引用赋给子类变量），动态绑定，阻止继承：final类和方法，强制类型转换（instanceof检测），抽象类（abstract），受保护访问（private,protected,public,default）super和this，Java不支持多继承5.2 Object：所有类的超类equals方法，相等测试与继承，hashCode方法，toString方法5.3 泛型数组列表访问数组列表元素（ArrayList&lt;Object&gt;），类型化与原始数组列表的兼容性，对象包装器与自动装箱(autoboxing)@SuppressWarnings(&quot;unchecked&quot;)5.4 参数数量可变的方法(范例printf)5.6 枚举类(Enum)5.7 反射（reflection，强大工具）Class类，捕获异常(try..catch)，利用反射分析类的能力(Field,Method,Constructor；private,protected,public,default)，在运行时使用反射分析对象，使用反射编写泛型数组代码，调用任意方法（对比接口interface和内部类，不建议使用Method对象，效率相对较低而且不易维护）5.8 继承设计的技巧将公共操作和域放在超类；不要使用受保护的域，确保封装性private；使用继承实现“is-a”关系；除非所有继承的方法都有意义，否则不要使用继承；在覆盖方法时，不要改变预期的行为；使用多态、接口，而非类型信息；不要过多的使用反射，反射多用于工具类。 第六章 接口与内部类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686.1 接口（interface）接口的特性接口可以白看作没有实例域的抽象类，但有区别。实现（implement）如果类遵从某个特定接口，那么就履行这项服务（必须实现接口内的方法）。任意的x,y，sgn(x.compareTo(y))==-sgn(y.compareTo(x))接口不是类，不能用new运算符实例化一个接口，即构造接口的对象，但能声明接口的变量。接口变量必须引用实现了接口的类对象，使用instanceof可以检查对象是否实现了某个特定的接口。像类可以继承一样，接口也可以被扩展。接口不能有实例域或静态方法，但是可以包含常量。接口方法将被标记为public，域标记public static final。接口与抽象类Java不支持多继承（mulitiple inheritance，比较复杂而且容易造成效率降低），即只能有一个超类，但是可以实现多个接口。6.2 对象克隆拷贝与克隆，浅拷贝与深拷贝。Clonable实现的是深拷贝（约等于完全拷贝了一个独立的新对象）。6.3 接口与回调（callback）Java中函数指针的调用类似物--Method对象，但速度反而略慢，且麻烦，而且没有编译时的安全检查。回调典型如Timer。6.4 内部类（inner class）内部类是定义在另一个类中类。内部类可以访问该类包括私有域的数据。内部类可以相对同一个包而言可以隐藏起来。匿名内部类可以定义一个回调函数且不用编写大量的代码。6.4.1 使用内部类访问对象状态内部类与接口是Java重要的基本特性。内部类的对象总有一个隐式引用，指向了创建它的外部类对象，由编译器自动添加。内部类当且仅当外部类需要时才会有实例域。常规类具有包可见性或者公共可见性，而内部类可以是私有类。6.4.2 内部类的特殊语法规则内部类中，使用外部类的引用正规语法：OuterClass.this在外围类的作用域之外，可以这样的语法来引用内部类：OuterClass.InnerClass6.4.3 内部类是否安全，必要，有用编译器将内部类翻译成$来分割外部类名和内部类名的常规类文件，虚拟机对此一无所知。内部类不是绝对安全的。例：static boolean access$0(com.chain.chapter6.TalkingClock);编译器在外围类添加静态方法，返回作为参数传递给它的对象域。这个可以被调用用作访问类内私有域数据，但难度较高。6.4.4 局部内部类局部类对外界的世界完全隐藏起来，当然也不能用public或private。6.4.5 由外部方法访问final变量局部类不仅可以访问包含它们的外部类，也可以访问局部变量，但这些局部变量需要被声明为final。原理在于编译器会自动的为局部变量创建副本。例：final com.chain.chapter6.TalkingClock this$0;public com.chain.chapter6.TalkingClock$TimePrinter(com.chain.chapter6.TalkingClock);这是内部类自动生成的构造器，作为副本。6.4.6 匿名内部类（Annoymous inner class）例：Person psn1=new Person(&quot;Tom&quot;); //这是Person类的一个实例Person psn2=new Person(&quot;Jack&quot;)&#123; ... &#125;; //an object of an inner class extending person其实匿名内部类与普通内部类可以相互转化，匿名内部类有时可以减少代码的编写，但其实不易维护。ArrayList&lt;String&gt; friends=new ArrayList&lt;&gt;();friends.add(&quot;Andy&quot;);friends.add(&quot;Dan&quot;);invite(friends);//接下来friends数组列表可以不要了==&gt;invite(new ArrayList&lt;String&gt;&#123;&#123;add(&quot;Andy&quot;);add(&quot;Dan&quot;);&#125;&#125;);匿名类使用equals时需注意。new SuperType(construction parameters)&#123;inner class methods and data&#125;new InterfaceType()&#123;methods and data&#125;6.4.7 静态内部类仅需隐藏一个类在另一个类的内部时，并不需要内部类引用外部类对象时，可将内部类声明为static，以便取消编译器自动添加的外部类的引用。static class and method。6.5 代理（Proxy）动态加载类，invoke(Object proxy,Method method,Object[] args) 第七章到第九章 GUI部分1省略 第十章 部署应用程序和applet1234567891011121310.1 JAR文件（Jav归档文件）将应用程序进行打包，可以包含类文件，图像和声音的资源文件。JAR文件是压缩的，使用了熟悉的ZIP压缩格式。使用JAVA自带的jar工具可以创建JAR文件。清单文件（MANIFEST.MF)可运行的jar文件10.2 Java WEb Start密封，沙箱，签名代码,JNLP API10.3 appletHTML标记语属性，object标记，使用参数向applet传递信息，访问图像和音频文件，applet上下文10.4 应用程序首选项存储属性映射（Properties类）Preferences API（数据以XML存储） 第十一章 异常、断言、日志和调试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838411.1 处理错误出现错误而无法执行：返回安全状态，进行保存作业的操作，可以以适当的方式终止程序。用户输入错误（如输入不标准），设备错误（如设备脱机），物理限制（如磁盘满了），代码错误（如返回值处理）。Java中出现问题后会采用另一种路劲退出该方法，并抛出异常（throw），并停止继续执行，立即退出。异常处理机制（exception handler）会接着处理。异常分类Throwable:Error（无法控制的错误）+Exception（）Exception:IOException+RuntimeException（逻辑错误，checked）+非 RuntimeException（unchecked）声明已检查异常(throws)如何抛出异常throw new XXXException;throws XXXException创建异常类派生一个Exception类，超类为Throwable11.2 捕获异常(try/catch/finally)捕获多个异常多个catch语句，每一个catch语句内对应一个已知的错误类再次抛出异常与异常链try&#123;...&#125;catch(SQLException e)&#123;throw new ServletException(&quot;throw again&quot;+e.getMessage());&#125;finally字句当程序错误时，一般会无条件终止，这使得资源尚未释放，finally则无论发生还是没有发生错误都会执行，以便及时关闭资源。带资源的try语句open a restry&#123;try&#123;work with the res&#125;finally&#123;close the res&#125;&#125;catch(XXXException e)&#123;...&#125;分析堆栈跟踪元素(stack trace)方法调用过程的列表，包含程序执行过程中的方法调用的特定位置。printStackTace();11.3 使用异常机制的技巧尽量避免错误的发生，不能用作测试，滥用会降低效率；不要太过分的细化异常；抛出的异常如果重要，需要利用异常的层次结构；重要的异常需要去处理，而不是一直空着，捕获到却不处理；早抛出，晚捕获11.4 使用断言（assert）启用和禁用断言java -anableassertions XXXX使用断言完成参数检查Java语言中3种常见处理错误的机制：抛出一个异常，日志，使用断言使用断言时，断言失败是致命的，不可恢复的错误。断言检查用于开发和测试阶段。为文档假设使用断言assert i!=null:i;11.5 记录日志最原始的记录方式就是println出觉得有错误的地方。但是建议使用记录日志(Logger)的API。可以方便的取消全部日志记录，打开关闭很方便。可以一键禁止日志，减少系统开销。日志记录可以设置不同的处理方式，如XML或文本。日志记录应该添加上如包名等具有层次结构的名字。基本日志高级日志修改日志管理器配置本地化处理器过滤器格式化器日志记录说明11.6 调试技巧System.out.println(&quot;x=&quot;,x);日志代理，logging proxyLogger.getGlobal().info(&quot;x=&quot;,x);每个类里可以放一个main()用于测试，事后可以注释，java只调用启动类的main()JUnitThrowable提供的printStackTrace()代码的任意位置插入这条语句就可以堆栈跟踪，Thread.dumpStack()可以将错误输出到文件中，比如printStackTrace(out)，或者命令行参数重定向输出将日常调试的信息写入log文件java -verbose 可以将类的加载信息输出javac -Xlint:fallthrough 可以通知编译器检查某个特别注意点jconsole监控管理虚拟机的内存消耗，线程使用，类加载情况jmap获得堆的转储，然后在localhost:7000如果使用-Xprof标志，则会剖析经常用到的方法。11.7 GUI程序排错技巧11.8 使用调试器使用Eclipse的Debug模式 第十二章 泛型程序设计123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051在java5内加入，比强制使用类型转换的代码较安全，较C#而言，Java的泛型是“假泛型”。12.1 为什么要使用泛型程序设计在编译时提供安全检查，消除强制类型转换（隐式自动完成，运行时都是普通类，再从泛型容器里取出值时，编译器进行类型转换），最大限度重用代码。但是，擦除使得无法与数组混合使用的很好，基本类型（int,float等）无法作为类型参数，需要使用包装类（Integer等），不能用于显示引用运行时的类型操作中（如instanceof和new表达式），重载不识别泛型，基类劫持了接口，try/catch语句不能捕获泛型类型的异常，泛型类不能使用Super，通配符不能盲目使用？等。12.2 定义简单泛型类类型变量T，用&lt;&gt;框住，放在类名后面。用具体的类型来替换。class Generic&lt;T&gt;&#123;&#125;12.3 泛型方法public static &lt;T&gt; T getMiddle(T...a)&#123;return a[a.length/2];&#125;类型变量放在修饰符之后，返回类型之前12.4 类型变量的限定泛型需要绑定接口，比如int和Integer.public static &lt;T extends Comparable&gt; T minmax(T[] a)&#123;&#125;修饰符+类型变量+返回类型+方法名（参数...）T与绑定的类型可以是类也可以是接口，不过选择extends接近子类的概念。限定类型用&amp;隔开，而逗号用来分割类型变量12.5 泛型代码和虚拟机虚拟机没有泛型类型对象，所有对象都属于普通类。无论何种泛型，都有一种相应的原始类型（raw type），原始类型的名字就是删除类型参数后的泛型类型名，擦除（erased）类型变量T，并替换为限定类型（无限定类型就使用Object），T是一个无限定的变量，所以可以直接用Object替换，但是这有区别。翻译泛型表达式，擦除返回的是Object类型，编译器会自动插入强制类型转换。翻译泛型方法，类型擦除和多态可以用桥方法解决，即public void setSecond(Object second) &#123; setSecond( (Date) second); &#125;泛型转换的事实，虚拟机中没有泛型，只有普通类和方法；所有类型参数都用它们的限定类型替换；桥方法被合成来保持多态；为保持类型安全性，必要时插入强制类型转换。调用遗留代码，利用注释（annotation）@SuppreussWarnings(&quot;unchecked&quot;)，@SafeVarargs12.6 约束与局限性Java泛型的限制，大多由类型擦除引起的。不能用类型参数代替基本类型，例如XXX&lt;int&gt;，只用XXX&lt;Integer&gt;，保持Java一切皆对象思想，如果要使用可以使用包装类实现，比如Integer或者自己定义的类。不能使用Instanceof，所有泛型类运行时都是普通类而已，同样getClass()也是如此。不能创建参数化类型的数组，比如Pair&lt;String&gt; table=new Pair&lt;&gt;[10]这样在擦除后。table类型是Pair[10]，而非Pair&lt;String&gt;[10]，如果需要收集参数化类型对象，可以使用ArrayList&lt;Pair&lt;String&gt;&gt;周转实现。或者：@SafeVarargs static &lt;T&gt; T[] array(T...array)&#123;return array;&#125;Pair&lt;String&gt;[] table =array(pair1,pair2);Object[] objary=table;bojary[0]=new Pair&lt;Employee&gt;(); YEStable[0]=new Pair&lt;Employee&gt;(); ERR不能实例化类型变量，如new T(...)，new T[...]，T.class，因为T会被擦除成Object，可以使用以下实现：public static &lt;T&gt; Pair&lt;T&gt; makePair(Class&lt;T&gt; cl)&#123;try&#123;return new Pair&lt;&gt;(cl.newInstance(),cl.newInstance());&#125;catch( Exception e ) &#123;return null;&#125;&#125;接下来：Pair&lt;String&gt; p=ArrayAlg.makeClass(String.class);不能抛出或捕获泛型类的实例异常，注意擦除后的冲突泛型类型的继承规则，为了安全，其实泛型的继承互相没有联系12.8 通配符类型Pair&lt;? extends Employee&gt;? super Manager12.9 反射和泛型 第十三章 集合123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133见《数据结构与算法经典问题解析Java版》数据结构（Data Structures）JAVA最初：Vector、Stack、HashTable、BitSet、Enumeration现在：Collection, List,LinkedList,ArrayList,Vector,Stack,Set C++标准模板库STL复杂，结合泛型算法，Java的集合类库（Collection）接口interface、实现implementation在Java中分离队列（queue）,FIFO先进先出：循环数组，链表Queue接口实现ArrayQueue，LinkedList类一般循环数组比链表要高效，但是数组有界Java中还有一个AbstractQueue，抽象队列，可以自己实现扩展队列集合接口（Collection）和迭代器接口（Iteration）集合接口有两个基本的方法add，iteratorJava的迭代器位于两个元素之间，当调用next时，会越过下一个元素，并返回刚刚越过的那个元素的引用。需要配合hasNext()。remove方法会删除上次next方法返回的元素。next与remove相互依赖。每次调用remove时需要在之前调用nextJava中有一个AbstractCollenction，基础方size和iterator抽象化，泛型接口。Collection ├List │├LinkedList │├ArrayList │└Vector │ └Stack └Set│ ├ TreeSet│ ├ EnumSet│ ├ HashSet│ ├ LinkedHashSet│└Queue ├ArrayDeque ├PriorityDequeMap ├Hashtable ├HashMap ├TreeMap├EnumMap├LinkedHashMap├IdentityHashMap └WeakHashMap Set集,List链,Map（映射）表，Queue队列，Stack栈Linked链接,Array数组,Hash哈希、散列,Tree树Sorted,UnsortedVector链表：LinkedList，List接口数组列表ArrayList类，删除插入一个元素代价较大链表LinkedList类，删除插入方便Java中，链表是双向的（doubly linked）C语言指针，Java则是引用链表是有序集合（Ordered Collection）add方法依赖迭代器set是无序的Java屏蔽了双向链表复杂的引用变更，add，remove,next,hasNext，很好的屏蔽了细节。如果同时有两个迭代器最链表进行修改操作，将会抛出ConcurrentModificationException但是一个只读，另一个可读可写的两个迭代器是允许的链表不支持随机读取，所以get(i)方法不适合用来遍历链表如果数组中元素较少，可以完全使用ArrayList，可以实现随机访问数组列表：ArrayList，List接口封装了一个可动态再分配的对象数组Vector类所有方法是同步的，可由多个线程来访问Vector，进行同步操作但是，单线程使用Vector就得不偿失了ArrayList是非同步的。散列表：HashTable，散列值：HashCode，Set接口，HashSet链表和数组都是有一定顺序的，查找元素需要具体的位置或者从头遍历等方法，速度较慢HashTable可以快速的找到元素，如果不在意数据的排列的话，数据是无序的Java中，散列表是有链表数组产生的，每个列表被称为桶（bucket）确定位置，先计算散列值，在与桶的总数取余，这个值就是桶的索引有时有散列冲突（hash collision）,有对应的解决方法，比如向后沿找空位放或者链表串起来等散列表太满的话会再散列（rehashed）如果元素的散列码发生变化，则位置可能也会改变散列的递归树集：TreeSet，集Set接口树集是一个有序集合（Sorted Collection）,红黑树（red-black tree）每次添加元素时，都会添加到正确的结点上，这样迭代器访问时是按照排好序的顺序访问元素如果不需要数据排序，不建议使用排序要比散列困难的多NavigableSet，增加了反向遍历和定位元素的方法队列和双端队列：DequeArrayDeque、LinkedList可动态增加队列的长度优先级队列：Priority Queue优先级队列采用了一个高雅数据结构，堆（Heap）堆是一个可以自动调整的二叉树，add和remove操作会将最小的元素移动到树根，这样不用再花费时间排序可以进行任务调度操作，优先级最高值也为最小1与TreeSet不同，PriorityQueue是根据优先级排序映射表：MapHashMap，TreeMap散列映射表对键进行散列，树映射表用键的整体顺序进行排序，在组织成搜索树散列和比较函数只能用于键，其关联的值不用于散列和比较与集Set一样，如果不需要排序则散列键值（key）必须是唯一的专用集和映射表类弱散列映射表WeakHashMap：删除表中一些无用的值链接散列集LinkedHashSet和链接映射表LinkedHashMap：表面是随机排列的，实际会记住插入的顺序枚举集EnumSet和映射表EnumMap：位序列标识散列映射表IdentityHashMap：根据内存地址计算散列码集合框架：集合和数组之间的转化toArray()算法：排序和查找Collections类中的sort方法，shuffle方法，Collections是一个包装类将所有元素转入一个数组，然后运用归并排序的一个变体进行数组排序，好了后在复制回去归并排序比快速排序慢一点但是稳定排序方法查找方法遗留的集合HashTable和子类Properties：和HashMap类似，区别是HashTable是同步的，另一个是不同步的Vector和子类Stack,BitsetEnumeration：hasMoreElements和nextElement与Iterator的hasNext、next类似属性映射表（property map）位集BitSet：位序列，更类似与位向量或者位数组栈Stack 第十四章 多线程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194多任务（multitasking），在同一时刻运行多个程序的能力。每一个任务可以称为线程（Thread），多线程程序（multithreaded）。多进程和多线程：每一个进程拥有一整套变量，而线程是共享数据。共享变量使得线程之间通信比进程之间更有效。线程是轻量级的进程，启动、撤销一个线程比启动新进程容易少开销。14.1 什么是线程线程的sleep方法可能会抛出InterruptedException异常。当这个线程在sleep时，发出中断（Interrupt）请求。线程使得程序能够执行多个任务，对短暂的任务可以使用线程，对耗时的复杂项目需要精心设计。Runnable接口：public interface Runnable&#123;void run();&#125;由Runnable创建一个Thread对象：Thread t=new Thread(t);t.start();//创建一个新的线程t.run();//执行一个已有的线程但是为每一个任务创建一个独立的线程付出代价也不小，可以使用线程池。14.2 中断线程inerrupt()使用前isInterrupted()。14.3 线程状态New（新创建），Runnable（可运行，考虑优先级），Blocked（被阻塞），Waiting（等待），Time Waiting（计时等待），Terminated（被终止）。一个在运行状态（State）的线程可能是正在Running也可能是没有Running。14.4 线程属性线程优先级，守护线程，线程组，处理未捕获异常的处理器。线程优先级可以使用setPriority设置优先级，但是Java的优先级是高度依赖系统的，即通过虚拟机映射到系统中的优先级，但不同操作系统中优先级不一。进程的优先级需要谨慎使用，比如使用不当，低优先级进程会“饿死”状态。守护线程（daemon thread）为其他线程提供服务，比如计时线程，定时地发送信号给其他线程或者清空过时的高速缓存项的线程。未捕获异常处理器Thread.UncaughtExceptionHandler，线程的run并不能抛出任何已检查的错误，但是这些异常会导致线程的终止。可以用线程集合ThreadGroup，还有线程组。14.5 同步多个线程同时访问共享数据，竞争条件（race condition）。比如银行的转账系统。两种机制防止并发访问的干扰：synchronized关键字，和ReentrantLock类。A 锁对象：myLock.lock();//进入锁状态try&#123;critical section&#125;finally&#123;//确保即使程序异常也能执行finallymyLock.unlock();//解除锁&#125;锁是可以重入的，线程可以反复获得已经持有的锁，保持一个持有计数(hold count)来跟踪对lock方法的嵌套调用。线程每一次Lock()后必然调用Unlock()方法。所以，基于这一特性，被一个锁保护的代码可以调用另一个使用相同的锁的方法。留心临界区的代码。条件对象条件对象（条件变量,conditional variable）程序进入临界区，但是发现在满足一定条件后才执行。比如：if(a&gt;b)&#123;//线程可能在判断完a&gt;b后满足条件,，但在执行do sth时，线程时间到，被暂停，再次得到运行时间时，a&gt;b可能已经被其他相关线程改变，而不满足，再do sth可能就有问题。比如订票系统。do sth&#125;可以使用锁来解决这个问题（在if前加锁），但是如果账户中没有足够的钱，此时程序通过判断后执行等待用户存钱的线程使得余额增加，但是花钱的线程却得到了线程锁，也就意味着别的相关线程无法执行，就一直卡在这。此时就可以使用条件变量来使得花钱线程进入阻塞状态并放弃锁，这样存钱线程可以执行。await方法可以等待条件，但并不自动恢复执行。应当再在其他线程使用signAll来激活因为同一原因而阻塞等待的线程。从而从await()处调用返回。，从阻塞的地方继续执行。当然条件可能依然不满足，signAll知识通知而已，具体需要各个线程自行判断。while(!(ok to process))&#123;condition.await();&#125;如果没有其他线程来调用signAll那么这就会产生死锁(deadlock)现象。同步互锁虽然解决了并发读取数据的冲突，但是速度肯定降了下来。B synchronized关键字总结Lock和Condition：锁用来保护代码片段，保证任何时刻只用一个线程在运行被保护的代码。锁可以管理试图进入被保护代码段的线程。锁可以拥有一个或多个相关的条件对象。每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程Lock和Condition的控制是高度的，但是大多数情况并不需要如此严格。每个对象内部都有一个内部锁，如果使用synchronized关键字声明，那么对象锁将保护整个方法。public synchronized void method()&#123;&#125;//隐式锁等价于public void method()&#123;//显示锁this.intrinsicLock.lock();//进入锁状态try&#123;critical section&#125;finally&#123;//确保即使程序异常也能执行finallythis.intrinsicLock.unlock();//解除锁&#125;&#125;内部锁简单够用，但是有局限：不能中断一个正在试图获得锁的线程。试图获得锁时不能设定超时。每个锁只有单一的条件，可能是不够的。具体是用这两种方法中的哪一种：这两种方法可以都不使用，使用阻塞对列来同步完成一个共同任务的线程。减少代码编写量可以使用synchronized关键字，简单够用。如果特别需要Lock/Condition方式再使用同步阻塞synchronized(obj)&#123;critical section&#125;监视器概念锁和条件是线程同步的强大工具，但严格的讲，它们不是面对对象的。那么，可以不添加锁来保证安全性吗，那就是监视器（monitor）监视器是只包含私有域的类每个监视器类的对象有一个相关的锁。使用这种锁使得所有的方法都进行加锁，加锁是在方法开始之前自动获得，而方法返回时自动释放。域是私有的，所以又能确保只有一个线程能同时访问数据进行操作。Volatile域Java内存模型和线程规范。volatile关键字为实例域的同步访问提供了一种免锁机制。即如果声明一个域为volatile，那么编译器和虚拟机就会知道该域是被另一个线程并发更新的。使用synchronized可以使得保持同步，但方法也可能阻塞，再加上Condition。但是，如果是这样：public boolean isOk;public synchronized boolean isOk() &#123; return isOk; &#125;public synchronized void setOk() &#123; this.isOk=true; &#125;不如这样：public volatile boolean isOk;public boolean isOk() &#123; return isOk; &#125;public void setOk() &#123; this.isOk=true; &#125;volatile不能保证原子性。例如：public void flipDone() &#123; done=!done; &#125;//不是原子的，所以不能保证是能够翻转域中的值。final变量锁和volatile可以确保安全的读取一个域。还有一种方法是域被声明为final时可以保障。原子性java.util.concurrent.atomic包中有很多高效的机器级指令来确定不操作的原子性。原子性是指要么完整的一次性做完，要么就安全回滚到起点。死锁账户A:200 账户B:300线程1：从A转500到B线程2：从B转400到A这两个线程都阻塞了，余额均不足。这就是互锁。如果在运行中遇到死锁，在Java中目前没有什么解决方法，只能设计时避免。线程的局部变量SimpleDateFormat线程并不是安全的，因为如果两个线程同时调用同一个SimpleDateFormat的静态变量dateFormat的format方法时结果可能是混乱的。dateFormat的内部数据结构可能会因为并发处理而混乱。当然解决方法是每个线程一个单独的SimpleDateFormat对象，不过确实浪费。ThreadLocal&lt;&gt; initalValue()锁测试和超时tryLock()方法可以试图申请一个锁，成功则返回true，不成功再等待，超时后返回false。tryLock()在方法的等待时间时如果被中断会抛出InterruptedException并退出，这个可以反过来打破死锁，比如向死锁线程发送中断信号。同理await也有超时等待设置。特别的awaitUninterruptibly可以对InterruptedException不予理会，继续等待。读/写锁ReentrantReadWriteLock类，readLock()和writeLock()。适用于读的多写的少，或者写的多读的少情况。stop，suspend阻塞，resume天生不安全，容易导致死锁和意外情况。安全的挂起线程需要引入boolean变量来使得线程在suspend挂起的时候没有影响到其他线程需要对象的地方。14.6 阻塞队列上节内容是Java底层实现并发程序设计的技术。但是，正常使用中应当考虑阻塞队列。比如根关键字查找某目录下包含子目录的文件及文件内容。生产者线程负责枚举所有的文件，并添加到队列中去。搜索线程负责取出队列的东东，然后匹配判断。队列数据结构可以作为一种同步机制，但是显式的线程同步也是需要的。14.7 线程安全的集合映射表（HashMap），有序表（SkipListMap，SkipListSet），队列（LinkedQueue）。这些集合往往采用复杂的算法，来确保并发访问的安全性。写数组的拷贝CopyOnWriteArrayList，和CopyOnWriteArraySet。较早的线程安全集合Vector和HashTable，以及后来的ArrayLIst和HashMap，不过他们并不是安全的，可以通过同步包装器（synchronization wrapper）来加锁等确保安全。不过再此建议使用synchronizedList和synchronizedMap，而不是自己手动封装。比如：List&lt;E&gt; synchArrayList=Collections.synchronizedList(new ArraryList&lt;E&gt;()); Map&lt;K,V&gt; synchHashMap=Collections.synchronizedMap(new HashMap&lt;K,V&gt;());14.8 Callbale和FutureRunnable封装一个异步运行的任务，是一个没有参数和返回值的异步方法。而Callable是有返回值和参数的，只有一个方法call()public interface Callable&lt;V&gt;&#123;V call() throws Exception;&#125;类型参数是返回值的类型。Future保存异步计算的结果，Future可以将计算结果保存好，可以稍后获取。可以把结果放在ArrayList里，比如ArrayList&lt;Future&lt;Integer&gt;&gt;14.9 执行器线程池（thread pool）用来解决程序中大量生命期比较短的线程。当run方法结束后，线程不会死亡，而是再等待为下一个请求服务。同时创建大量的线程也大大降低性能，甚至使得虚拟机崩溃。所以一个固定数目的线程池是有必要的。执行器（Executor）类用于构建线程池。1调用newCachedThreadPool,newFixedThreadPool,newSingleThreadPool等静态方法2调用submit提交Runnable或Callable对象3如果要取消一个task，或提交Callable对象，需要保存好返回的Future对象，因为线程池别的进程也会使用。4shutdown,shutdownNow预定执行（scheduledExecutorService）或重复执行。允许线程池机制的Timer的泛化。控制任务组invokeAny。比如因式分解求解RSA，可以一次提交很多任务，只要有一个得到答案，其他的可以结束。Fork-Join框架用以将一个大问题划分为小部分，同时计算。RecursiveTask在后台，fork-jion框架使用了有效的智能方式来保持线程的工作负载。称为工作密取(work stealing)。每个工作线程都有一个双端队列(deque)来完成任务。比如在100000000个随机0-1的小数中，统计符合要求的数字和，比如x&gt;0.5。就可以采fork-join框架：在compute方法内，invokeAll接收很多小任务后阻塞，知道所有的小任务完成后再返回，而join方法获得各个小任务的返回值。同步器（java.util.concurrent）管理相互合作的线程集。信号量，倒计时门栓（CountDownLatch，下一个任务等待当前的任务计数减为0再运行），障栅（barrier，将运行进度不一致的线程统一起来，到某个阶段都同步起来再继续执行），交换器（Exchanger，共用数据缓冲区，一个写，一个读，完事再相互交换），同步队列（synchronousQueue，数据沿着一个方向传递，一个只负责put生产，另一个就一直take消费，不相互交换）14.11 线程与Swing在界面中使用线程是为了提高响应的性能。当程序再做某一个耗时的任务时，应当启动另一个线程来继续与用户接口交互。Swing并不是线程安全的，也就是说，多线程会导致界面崩溃，而程序的逻辑功能可能继续运行。Swing不使用同步机制的原因在于，同步需要大量的时间，降低速度，另一方面，同步机制比较容易搞混，造成死锁。运行耗时的任务如果线程任务耗时，那把它通过分配任务线程扔到一个独立的线程吧除了事件分配线程，其他的线程与界面无关，尽量分开他们。单一线程规则（single-thread rule）事件分配线程不要进行IO操作等耗时或者资源操作，很可能会卡死，也不要调用sleep()方法，如果需要等待指定的时间，建议使用定时器事件。这两条规则看起来彼此冲突，比如进行一个下载操作，启动下载线程，同时在界面上更行进度条。但是下载进程不能接触Swing组件。为此，可以将界面更新操作放在invokeLater和invokeAndWait里。EventQueue.invokeLater(new Runnable()&#123;public void run()&#123;label.setText(percentage+&quot;ok&quot;);&#125;&#125;);invokeLater会立即返回继续执行原来程序的接下来的部分，而run的方法会异步执行。例子读取长文件文本内容。单一线程机制main就是一个单一的线程。在Swing程序中，main的生命周期比较短暂，基本就是构建用户界面后退出，接下来由事件分配处理线程来接管。Swing中大部分方法是不安全的，只有很少但很有用的是安全的。JTextComponent.setTextJTextArea.insertJTextArea.appendJTextArea.replaceRangeJComponent.repaintJComponent.revalidate 卷I - 终]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法经典问题解析]]></title>
    <url>%2F2016%2F06%2F04-book-sjjgysfjdwtjx%2F</url>
    <content type="text"><![CDATA[数据结构与算法经典问题解析图书馆最近在上新书，看到了这本书，就借回去看了。虽然书中也有少许错误，但是讲解还是通俗易懂的。 每章小结第一章 绪论变量，数据类型，数据结构（data structure，线性与非线性），抽象数据类型（ADT）。什么是算法：解决问题的方法与步骤，不需要严格的证明。算法分析：确定在时间和空间上比较有效的算法。增长率：近似，忽略微不足道的。分析算法：最好（下界），平均时间，最差（上界）大O表示法（上界），大Ω表示法（下界），大Θ表示法（平均）。渐近分析（循环，嵌套循环，循环执行时间，if-then-else语句，级数时间复杂度），性质，常见公式。分治法主定理：T(n)=mT(n/p)+O(n)。算法分析经典例题。递归，数组，动态数组，链表，栈，队列，树，图，排序，查找，选择，散列，字符串 第二章 递归和回溯递归：任何调用自身的函数称为递归。递归算法必然需要是收敛的。递归比迭代代码更加简洁，而且在编译或者解释时，循环灰转化为递归函数。所以，递归往往使得处理更加简单高效。比如，排序，搜索，遍历。函数不再递归时为基本情形（base case），调用时称为递归情形（recursive case）。范例：阶乘。递归在内存里的情况：递归函数每次的再调用会产生副本（准确讲只是一些返回变量），函数均结束时会逐个返回。记住递归不能出现无穷递归，递归基于栈操作。迭代和递归。递归算法经典用例：斐波那契数列、阶乘归并排序，快速排序二分查找树的遍历：比如中序遍历，前序遍历，后序遍历图的遍历：深度优先搜索，广度优先搜索动态规划例子分治算法汉诺塔回溯算法 回溯是一种采用分治策略进行穷举搜索的方法。最笨但最有效的方法是：尝试所有的可能性回溯算法经典用例：二进制串：产生所有的二进制串生成k进制串背包问题广义字符串哈密顿回路图着色问题 递归算法和回溯具体的实现不一定要想的特别明白，只要思路能用递归实现就好，比如想简单的情况，一般是n=2-3，再计算他的特性。 测试中可以把数据设为char，然后表示top,front,rear等“指针”可以表示成下一位空的元素，也可以表示成当前元素，哪个方便用哪一种。 第三章 链表链表：相邻之间指针相连，最后一个元素的后续指针值为NULL，链表长度可增可减比较方便（注意不能无穷无尽，避免内存耗尽），空间浪费较少。链表的主要操作：插入，删除。计数，查找，清空链表。数组：在一整个连续内存块中，访问时基于首地址的偏移量以及数组元素的大小。数组简单易用，访问元素在常数时间上较快。但是数组大小分配后即固定，基于数组的插入操作比较复杂。动态数组：大小自动调整的线性数据结构。固定化一个数组初始大小，而后一旦满了就扩展两倍于原始数组大小的新数组，若元素个数不足数组大小的一般，则数组大小减少一半。数组的再次更改大小其实是重新划分一个数组，再将元素全部复制过去，这样速度较慢，不如链表方便。链表的缺点主要在于访问单个元素的时间开销问题，数组可以随机读取，而链表顺序读取。时间开销在O(1)~O(n)。链表的增加删除工作也比较麻烦，也需要额外的内存空间来存储指针。 单向链表：每个结点有指向后一个元素的next指针。链表基本操作：遍历，插入，删除链表的遍历：头结点开始，依次遍历，当next指针的值为null时结束遍历。单向链表的插入：在表头插入，在表尾插入，中间位置随机插入单向链表的删除：删除表头，删除表尾，删除中间的结点单向链表的清空：从头结点开始逐个删除，利用临时变量（对象），auxilaryNode 双向链表：首尾均可访问整个链表。缺点是需要再增加一个指针。结点插入或删除会更耗时。双向链表操作要比单向链表多一个previous“指针”变量 循环链表：尾结点指向头结点。此时不能通过null判断是否是尾结点或者头结点。循环链表可以用于管理计算机的计算资源，可以用于实现循环缓冲区，栈，队列。 改进的存储高效的双向链表：1 ptrdiff=后继结点的地址 异或 前驱结点的地址2 松散链表，链表的查找O比数组大，可以将链表分组。比如4个是一个小链表的串联。 练习：链表实现栈倒数找链表散列表判断是循环链表还是单向链表求整数的无穷级数的中位数交换链表的相邻结点判断回文数二叉树转双向链表删除链表中重复的字符 第四章 栈可以把栈（stack）比喻成餐馆里叠着的盘子，需要时从顶端取（入栈），洗干净后再放在顶端（出栈）。栈是一个有序线性表，栈顶（top）执行插入和删除操作。后入先出（LIFO）或者先入后出（FILO）。入栈（push）和出栈（pop）。空栈执行出栈为下溢（underflow），满栈执行入栈为溢出（overflow）。通常，将下溢和溢出认为错误异常。栈在计算机程序中做执行其他任务时的保存现场的执行地址的功能。栈的主要操作：压栈，出栈，栈长，为空，为满栈的应用：符号匹配中缀表达式转化为后缀表达式计算后缀表达式实现函数调用（包括递归调用）求范围误差（极差）网页浏览中的浏览记录文本编辑器中的撤销功能HTML和XML文件中的标签匹配数的遍历算法等 栈的实现方式比较多，常用的方法：基于（动态）数组的简单实现（数组倍增技术，执行n次push操作约需logn次倍增操作，倍增太多可能导致内存溢出）基于链表的实现（headNode） 栈的练习匹配括号等对称符号中缀表达式转化为后缀表达式判断回文逆置栈的内容栈实现队列123456通过出入栈得到特定的内容对栈中元素进行排序删除栈中重复的字符 第五章 队列队列好比排队买票，排队打饭等等队列只能在一端插入，另一端删除的有序线性表队列是先入先出（FIFO）或后入后出(LILO)入队（EnQueue），出队（DeQueue）空队列执行出列操作会导致下溢（underflow），对满队列执行入队会导致溢出（overflow） 队列的常用操作：入队enQueue，出队deQueue，返回队首的元素front，返回队尾的元素rear，队列元素个数，容量大小，是否为空 队列的应用模拟系统的任务调度模拟现实生活中的购票行为多道程序设计异步数据传输客户等待 队列的实现：（动态）循环数组，链表 队列的相关问题逆置队列元素两个栈实现队列两个队列实现栈反向输出元素 第六章 树树是一种类似链表的结构，不同的是树的一个结点可以指向多个子结点树是一种典型的非线性结构，具有层次特性的图结构的一种方法。 相关术语：根节点：根节点是一个没有双亲结点的结点，树中最多只有一个根节点边：双亲结点到孩子结点的连接叶子结点：没有孩子结点的结点兄弟结点：拥有相同双亲结点的所有孩子结点祖先结点：从根节点出发，一条路径到某结点，则这条路径上经过的结点结点的大小：子孙结点的个数，包括自身树的层：相同深度所有结点的集合为树的层，根节点为0层结点的深度：根节点到该结点的路径长度结点的高度：该结点到最深子孙结点的路径长度树的高度：所有结点高度的最大值。对于一棵树而言，它的高度和深度一样，但对一个结点而言，深度 和高度不一定一样斜树：除叶子结点为，每个结点都只有一个孩子结点，全只有右孩子结点叫右斜树，全只有左孩子结点叫左斜树 二叉树：如果每个结点最多有两个孩子结点，则称为二叉树严格二叉树：每个结点2个或0个孩子结点满二叉树：每个结点有2个孩子结点，且所有叶子结点都在同一层完全二叉树：二叉树本身的高度h，所有叶子结点的深度为h或h-1 满二叉树的结点个数：2^(h+1)-1完全二叉树的结点个数：2^h~2^(h+1)-1满二叉树的叶子结点个数:2^hn个结点的完全二叉树，空指针的个数：n+1 二叉树的操作插入，删除，查找，遍历获取树的大小，树的高度，其和最大的层，找出最近的公共祖先结点 二叉树的应用编译器表达式树数据压缩算法中的赫夫曼编码树优先队列 二叉树的遍历前序遍历（DLR），中序遍历（LDR），后续遍历（LRD），层次遍历 递归与非递归遍历递归是利用系统栈非递归是自己自定义栈 层次遍历：利用队列实现 二叉树问题：找出最大元素（递归、非递归）找出某个元素（递归、非递归）插入一个元素获取二叉树结点的个数删除一个元素查找最深结点比较二叉树结构列出二叉树的根结点到某结点路径镜像二叉树已知中序遍历和前序遍历求树或后序遍历… 通用树（N叉树） 线索二叉树（无需栈或队列的遍历）leftp ltag data rtag rightp如果ltag==0 指向中序序列的左结点如果ltag==1 指向左孩子的左结点如果rtag==0 指向中序序列的右结点如果rtag==1 指向右孩子的右结点 表达式树用来组合表达式的树，计算机根据优先级处理表达式的过程 异或树，二叉搜索树，平衡搜索二叉树，AVL树 红黑树，伸展树，增强树，替罪羊树，区间树等 第七章 优先队列和堆优先队列ADT也是队列，但是不是按先到先服务，而是按照优先级高低处理。常用于计算机的作业调度 优先队列的操作：优先队列是元素的容器，每个元素有一个相关的键值insert(key,data)deleteMin/Max()getMin/Max()队列的大小，堆的排序 优先队列的应用：数据压缩，最短路径算法（Dijkstra），最小生成树算法（Prim），顾客排队算法，查找第k个最小元素 优先队列的实现：无序链表，无序数组，有序数组，有序链表，二叉平衡树，平衡二叉搜索树的实现，二叉堆这几种实现的优缺点 堆：堆是具有特定性质的二叉树，是一个完全二叉树，且结点的值必须均大于等于其孩子结点的值（或均小于等于孩子结点的值） 二叉堆 第八章 并查集ADT集合，无需考虑顺序 第九章 图两个对象之间的路径问题从一个城市到另一个城市的路径多样 图可以表示为（V，E），v是结点的集合，称为顶点，e是顶点对的集合，称为边顶点和边代表位置和存储元素 有向边：有序顶点对&lt;u,v&gt;，u-&gt;v，单向道（单行道）无向边：无序顶点对(u,v)，uv，双向道（火车线） 有向图：所有的边都是有向边（路由网络）无向图：所有的边都是无向边（飞行航班） 无环图：树的变形自环：自身指向自身平行边：连接相同顶点对的边 顶点的度：关联该顶点的边的数量子图：图的子集简单路径：不包含重复顶点的路径环路：简单路径基础上的收尾相同结点 连通图：每对顶点都有路径可达有向无环图：不包含环的有向图 有权图：每条边有一个整数表示的权重来代表距离或者花费完全图：包含所有边的图稀疏图，稠密图有向有权图：网络 图的应用：电子线路之间的组件关系交通网络计算机网络数据库 图的表示：边的列表，邻接矩阵，邻接表，邻接集 图的遍历：深度优先搜索（DFS）：类似树的前序遍历，使用栈实现，一个顶点开始走遍所有的路径，遍历所有的其他顶点。访问中有是否访问标记。广（宽）度优先搜索（BFS）：类似树的层次遍历，使用队列实现，从一个顶点出发，逐层遍历一遍。访问中有是否访问标记。 拓扑排序：无环图中对顶点的排序入度，出度解决课程选修的先决条件，检测死锁，计算作业的流水线，检查符号的链接环，解析电子表格中的公式 最短路径算法：无权图，有权图，带负边的有权图中的最短路径应用：找出一个地方到另一个地方的最快最短路径Dijkstra算法，Bellman-Ford算法等 最小生成树：图生成树 Prim算法，Kruscal算法 图算法相关问题：n顶点的无向简单图具有的最大边数n个顶点和e条边的图有多少不同的邻接矩阵，邻接表，判断是否有孤立点判断指定两个顶点是否路径可达DFS应用四着色问题反转图哈密顿环 第十章 排序排序是按某种顺序进行排列元素的一种算法排序是计算机中重要算法，可以显著降低问题的复杂度 排序的分类：比较的次数交换的次数内存的使用递归稳定性适应性 内部排序，外部排序 冒泡排序(bubble sort)算法：迭代的对输入序列中的第一个元素到最后的元素按两两交换方法。逐渐将键值较小的元素如同气泡一样浮在序列的顶端。冒泡排序时间复杂度高O(n^2)，算法实现简单。冒泡排序可用来检测是否已经是排序的改进版：增加一个附加标记，判断是否已经排序好，时间复杂度最好O(n)，最差O(n^2) 选择排序(selection sort)算法：寻找序列中的最小值，用当前位置实现最小值，重复过程，分区（partition）操作。时间复杂度最坏O(n^2)，最好O(n) 插入排序(insertion sort)算法：每次从输入数据拿出一个元素，插入到另一个已经排好序的序列正确位置时间复杂度O(n^2) 希尔排序(shell sort)泛化的插入排序，适合序列已经几乎有序的情况 归并排序(merge sort)将序列分成两部分并递归处理每一部分，之后将子问题解合并 堆排序(heap sort)基于比较的算法，也是选择排序 快速排序(quick sort)分治算法技术的实例，分区交换排序，基于比较排序的著名算法 树排序二叉搜索树 算法比较： 线性排序算法：计数排序，桶排序，基数排序 拓扑排序 外部排序 第十一章 查找查找是一个从项目的集合中寻找某个具有特定属性的项目的过程。项目可以是数据库的记录，数组中简单数据元素，文件中的文本，树中的结点，图中的边和顶点等。查找是计算机中的核心算法。 查找的类型：无序的线性查找排序/有序线性查找二分查找符号表和散列字符串查找算法：键值，三叉搜索树，后缀树 第十二章 选择算法（中位数）选择算法是指在某个列表中寻找第k个最小/最大的数字。包括最小值，最大值，中位数。基于排序的选择算法基于划分的选择算法中位数算法 第十三章 符号表字典，关键字与键值的一种数据结构应用：拼写检查工具数据库应用的数据字典加载器(loader)，汇编器(assembler)，编译器(complier)产生的符号表路由器（DNS查找） 第十四章 散列散列是一种用以实现信息存储和快速检索的技术执行优化搜索和符号表的实现 平衡二叉树的插入删除检索的操作时间复杂度是O(logn)但实际应用中，这些操作仍然太慢散列可以提供平均时间复杂度为O(1)，最坏情况为O(n)的操作 散列表ADT:CreateHashTableHashSearchHashInsertHashDeleteDeleteAll 散列的例子：给定字符串，查找是否存在重复的符号，比传统的线性扫描要快的多 散列的组成：散列表：数组的一种推广，关键字分配数组中的位置散列函数：将关键字转为索引负载因子：散列函数是否将关键字均匀分布冲突：两个记录的存储位置相同冲突解决算法：直接连接法（分离链接法），开放地址法（线性探测法，二次探测法，双重散列法） 散列达到O(1)的时间复杂度 静态散列、动态散列 布鲁姆过滤器（Bloom filter） 第十五章 字符串算法自动完成，字符串匹配蛮力法，Robin-Karp算法，基于有限自动机的字符串匹配算法，KMP算法，Boyce-Moore算法，后缀树等 第十六章 算法设计技术待解决问题与已解决问题的相似递归或迭代过程式（C,PHP,PERL）或声明式(SQL)串行或并行或分布式确定性和不确定性精确或相似 贪婪法：问题化为多个阶段，每个阶段找出最佳方案，不考虑后续决策的影响分治法：原问题分成多个子问题，子问题与原问题类型相同规模较小，再分别递归求解，最终合理整合动态规划法（DP）：备忘录技术线性规划法：不等式约束下，最大化（或最小化）输入变量的线性函数归约（转化求解）：复杂问题转化为一个已解决问题 复杂度，随机算法，分支定界、枚举、回溯等 第十七章 贪婪算法第十八章 分治算法第十九章 动态规划算法第二十章 复杂度类型随着问题规模大变化，其复杂度的增长速率简单问题，难问题用计算机解决问题 （终）]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员修炼之道——专业程序员必知的33个技巧]]></title>
    <url>%2F2016%2F05%2F06-book-cxyxlzd%2F</url>
    <content type="text"><![CDATA[程序员修炼之道——专业程序员必知的33个技巧和《高效程序员的45个习惯——敏捷开发修炼之道》一书一样，这本书也是不错的。 每章小结第一章 编程生产娱乐消遣时一般可以不考虑边界，错误，警告灯。生产环境不能马虎大意。比起事后测试，当时测试也是必要的。需要建立正确的思维方式，及时验证代码的正确性，及时测试。巨大的项目不可怕，慢慢分解，逐步完成。确定一个合适优雅的编程风格，有时是公司的编码规范。敲代码时要保证质量。代码评审，单元测试，接受测试，负载测试，定向探索测试，机构测试，环境测试，兼容性测试，耐久性测试，Beta测试，运行测试。将要做的事分开写是个好习惯，但掌握平台。测试时要做有意义的测试。做和想同步进行。 第二章 整理工具没有那门语言的学习有捷径。学习的过程是如走楼梯，一层更比一层高。自动化部署工具，自动话能减少错误，节约时间。版本控制系统可以跟踪内容，发布新版本，回滚老版本。开源项目注意版权。GNU公共许可证。 第三章 自我管理找个好师傅，具有你欣赏的品质，支持你，技术技能，了解形势，高标准。在公司自我形象很重要，不要太随意。拥有自己风格，不是哗众取宠。积极的去做事。正确应对压力，严肃对待。善待自己，劳逸结合，提高效率。选择一个好的键盘，显示器，鼠标，桌子和椅子。 第四章 团队协作熟悉团队的性格，性情：内倾/外倾，感应：感觉/直觉，判断：思考/情感，生活方式：知觉/判断。男性大部分只有逻辑没有情感：ISTJ（introverted,sensing,thinking,judgment）。女性大部分是ISFJ（Feeling）。建立自己的人脉，了解团队之间的丛属关系，各成员之间感情关系。合作上分而治之，结对编程（一起编程），当专注于自己的状态时不要去打扰他，当心情不佳时要适时去喝咖啡。开会简短高效比较好。当然也可以开开类似聚会的会议。 第五章 走进公司程序员，技术领导，架构师，经理，测试员，构建部署的人员。公司结构，行政助理，项目支持，营销人员，产品管理，销售经理，后勤人员，人力资源，财务和会计，首席执行官（CEO），首席技术官（CTO），首席信息官（CIO），首席运营官（COO），首席财务官（CFO），首席法律顾问（CLO），董事会。。。 第六章 留意自己的企业了解自己的项目。瀑布项目管理，敏捷项目管理。注意产品生产周期，概念，原型，开发，发布，维护。有时站在公司角度思考，眼光会不一样。不要总是抱着图表不放，真实的度量很重要。《人月神话》 第七章 改善端正态度，创新创意。学无止境，与时俱进。自我定位，眼光远大。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高效程序员的45个习惯——敏捷开发修炼之道]]></title>
    <url>%2F2016%2F04%2F17-book-mjkfxlzd%2F</url>
    <content type="text"><![CDATA[高效程序员的45个习惯——敏捷开发修炼之道这本书一直被很多人推荐，就从学校图书馆借阅后阅读，也从中有所收获吧。 每章小结第一章 敏捷——高效软件开发之道不管路走了多远，错了就要重新返回。开发须持续不断，切勿时断续时续。持续注入能量。敏捷开发就是在一个高度协作的环境中，不断使用反馈进行自我反馈和完善。敏捷，重构，迭代。态度决定一切，学无止境，交付用户想要的软件，敏捷反馈，敏捷编码，敏捷调试，敏捷协作。建立wiki，版本控制，单元测试，自动构建。先易后难，掌握方法的平衡。 第二章 态度决定一切为做事而工作，欲速则不达，防微杜渐，对事不对人，排除万难，奋勇前进。团队之间进行代码复审。使用单元测试，不要求快速简单的修复。 第三章 学无止境即使正确的轨道，停滞不前，依然会被淘汰。跟踪变化，对团队投资，懂得丢弃，需要打破砂锅问到底，把握开发节奏。迭代增量式学习，了解最新行情，参加一些社区讨论，如饥似渴阅读。团队需要多聚聚讨论方向等多方面问题。旧的技术也要适时丢弃，沉舟侧畔千帆过，病树前头万木春。多问几个为什么，表面简单的事情不简单。定期整理代码，不要拖沓不整理，也不能次次整理，有规律的迭代代码进度。 第四章 交付用户想要的软件计划赶不上变化，没有哪个方案是最终就敲定的。多和客户交流，让客户做些决定。提早集成，频繁集成。自动化部署，随时可以发布。多向用户演示获得反馈。短迭代，增量发布。客户即使不懂，也要让他们了解他们能了解的东西。软件开发前的设计要有，但无需太详细。合理使用技术，无论新旧，不能盲目选择，套用。对于能下载到的代码，第一次学习要敲一遍，之后要灵活运用。要使得每次提交的代码是随时可以部署运行的。写代码时要多测试，自动化单元测试，团队之间要及时频繁的集成，当然不是一小时就来集成一次。自动化部署应当在不同操作系统，环境下都去做。演示获得客户的反馈需求，而不是先自己闭门造车，才使得不会浪费时间成本。需要在软件开发过程中勤写日志，会写日志。计划太详细，容易完蛋。成本难以估量，保持固定数，但需要实时评估。 第五章 敏捷反馈一步行动，胜过千万专家的意见。经常监督，频繁反馈。先用它再实现它。多使用Junit之类软件，有一个自动构建的机器。不同的环境，可能会出现不同的问题。在每一个不同的平台来实现。度量真实的进度，不要欺骗自己或者团队。倾听出用户的抱怨。 第六章 敏捷编码代码要清晰表达出意图，团队之间代码要互相沟通。增量式编程，编写内聚的代码，降低耦合。代码设计要尽量简单，利于交接和维护。代码中具体的数值要有实际的意义，如宏定义，枚举来说明。善于写注释，而不是乱写注释。留意写一些技术文档，如JavaDoc对有些功能的取舍要有度，不能走左右极端，过分追求设计或者性能。增量式编程，复杂的问题逐步解决。解决问题在解决一个问题后，方法可能是复杂的，想想有没有简便的方法。而不是过分追求新的框架或者设计。编写内聚的代码，比如将衣柜分层，提高内聚性。当有疑问时，自己主动去寻求问题的解决方案，而不是上来就找答案。 第七章 敏捷调试真正的高手知道如何亡羊补牢。记录问题的日志，记录解决方法。记住警告其实就是错误，有时也致命。对问题各个击破，报告所有的异常。向用户提供有用的错误信息，贴心的错误信息。 第八章 敏捷协作一个团队，需要定期安排会议时间，经常碰面。架构师也必须加入到项目中去。代码可以由SVN来管理，集体共享。小组成员可以各抒己见，不能一言堂。团队之间做好代码审计，遇到困难及时通报。会议可以是立会的形式，问题如下：做了什么，计划做什么，有哪些疑惑。会议不要商讨解决方案，而是提出总体的问题，问题单独解决。自己手中的代码需要确保没有问题后再提交，不要提交错误的代码。 第九章 走向敏捷一灯能除千年暗，一智能灭万年愚。养成好的习惯。再烂手的项目，需要全面彻底的方式改革。管理者做好立会，彼此讨论，架构师也要动起来，不能纸上谈兵，代码审查很重要，客户也要加入项目。做好版本控制，单元测试，自动构建。多看书。掌握好方法的平衡。程序员需要养成良好的习惯，提高效率，而不是瞎忙。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的数组排序算法]]></title>
    <url>%2F2016%2F03%2F28-sort-integer-array%2F</url>
    <content type="text"><![CDATA[常见的数组排序算法(Java版)在一些项目中经常会使用排序算法，Java的API中也有各种已经提供好的排序算法，比如TreeSet的sort方法。在会使用这些即有算法的同时，自己也加以学习整理出常见的排序算法（均为升序排序）。 常见的排序算法：插入排序，选择排序，冒泡排序，希尔排序，快速排序，交换元素等 推荐一个常见算法的动态演示网站：https://visualgo.net/ 文中插图来自网络。 常见的排序算法交换元素在写排序算法之前，先说一下交换元素的方法。交换数组中两个元素主要有三种做法：中间变量法，异或法，加减法。其中，异或法和加减法更适用于整型（包括长整型），中间变量法则是万能交换元素的方法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 异或方式交换元素，没有中间变量，不会增加数值长度 * * @param n * 要交换元素的数组 * @param i * 第一个交换元素的数组下标 * @param j * 第二个交换元素的数组小标 */ public static void swap(int[] n, int i, int j) &#123; checkSwapArgs(n, i, j); n[i] ^= n[j]; n[j] ^= n[i]; n[i] ^= n[j]; &#125; /** * * 加减方式交换元素，注意可能带来的数据溢出和符号位问题 * * @param n * 要交换元素的数组 * @param i * 第一个交换元素的数组下标 * @param j * 第二个交换元素的数组小标 */ private static void swap2(int[] n, int i, int j) &#123; checkSwapArgs(n, i, j); n[i] = n[i] + n[j]; n[j] = n[i] - n[j]; n[i] = n[i] - n[j]; &#125; /** * * 中间变量法，方法简单，带来额外的内存开销，不过开销很小 * * @param n * 要交换元素的数组 * @param i * 第一个交换元素的数组下标 * @param j * 第二个交换元素的数组小标 */ private static void swap3(int[] n, int i, int j) &#123; checkSwapArgs(n, i, j); int t = n[i]; n[i] = n[j]; n[j] = t; &#125; 冒泡排序冒泡排序就像水中冒泡一样，每次遍历中都将本次遍历中最大的元素排在最后（上）面。这里的冒泡算法做了一些小优化，如果在排序中，已经出现了数组排序好的情况则停止排序。在学习排序算法的时候也找到一写算法的动图，这里粘贴一下。 123456789101112131415161718192021/** * 冒泡排序：相邻比较，每次将尚未排序的序列中最大的元素移动到末尾 * * @param a * 要排序的数组 */ public static void bubbleSort(int[] a) &#123; // TODO Auto-generated method stub checkArray(a); int n = a.length; boolean flag = false;// false代表没有排好序 for (int i = 0; i &lt; n - 1 &amp;&amp; !flag; i++) &#123; flag = true; for (int j = 0; j &lt; n - 1 - i; j++) &#123; if (a[j] &gt; a[j + 1]) &#123; flag = false; swap(a, j, j + 1); &#125; &#125; &#125; &#125; 这个算法的名字由来是因为越小(或越大)的元素会经由交换慢慢“浮”到数列的顶端。 选择排序选择排序，是指在每次排序中，在尚未排序的序列中选择一个最小的然后接到已经排序好的算法后面。 12345678910111213141516171819/** * 选择排序：每次从剩余尚未排序的序列中选择一个最小的接在已排序的部分后面 * * @param a * 要排序的数组 */ public static void selectSort(int[] a) &#123; // TODO Auto-generated method stub checkArray(a); int n = a.length; for (int i = 0; i &lt; n - 1; i++) &#123; int min = i; for (int j = i + 1; j &lt; n; j++) if (a[j] &lt; a[min]) min = j; if (min != i) swap(a, i, min); &#125; &#125; 插入排序插入排序和选择排序有类似的地方，插入排序是每次从尚未排序的剩余序列中取第一个，然后按照其他如冒泡排序等方法插入到前面已经排序好的序列中。 注意是从已经排序好的序列最后一个开始，倒过来找到合适的位置后插入。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 插入排序：每次取尚未排序的序列的第一个元素插入到前面序列的合适位置 * * @param a * 要排序的数组 */ public static void insertSort(int[] a) &#123; // TODO Auto-generated method stub checkArray(a); int n = a.length; for (int i = 1; i &lt; n; i++) &#123; // 方法一：类似降序的冒泡排序法 // method3a(a, i); // 方法二：中间变量 // method3b(a, i); // 方法三：中间变量2 method3c(a, i); &#125; &#125; private static void method3c(int[] a, int i) &#123; int t = a[i]; int j = i - 1; for (; j &gt; -1 &amp;&amp; a[j] &gt; t; j--) a[j + 1] = a[j]; a[j + 1] = t; &#125; @SuppressWarnings("unused") private static void method3b(int[] a, int i) &#123; int t = a[i]; int j = i; for (; j &gt; 0 &amp;&amp; a[j] &gt; t; j--) a[j] = a[j - 1]; a[j] = t; &#125; @SuppressWarnings("unused") private static void method3a(int[] a, int i) &#123; for (int j = i - 1; j &gt; -1; j--) if (a[i] &lt; a[j]) swap(a, i, j); &#125; 插入排序不会动右边的元素，选择排序不会动左边的元素；由于插入排序涉及到的未触及的元素要比插入的元素要少，涉及到的比较操作平均要比选择排序少一半。 希尔排序希尔排序开始时设定一个gap（初始时设置为数组的长度），然后像跳格子一样，等间隔（gap）的取出序列中的数，在对取出的数进行冒泡选择插入排序。每次循环gap减半，逐步细化间隔。 希尔排序，也叫递减增量排序，是插入排序的一种更高效的改进版本。希尔排序是不稳定的排序算法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 希尔排序：设定一个gap，从序列开头开始，每隔一个gap取一个数，然后对取出的数排序(按常规排序法)。每次 循环后gap减小一半，最终细化。 * * @param a * 要排序的数组 */ public static void shellSort(int[] a) &#123; // TODO Auto-generated method stub checkArray(a); int n = a.length; for (int gap = n; gap &gt; 0; gap &gt;&gt;= 1) &#123; // 冒泡排序法 // method4a(n, a, gap); // 选择排序法 // method4b(n, a, gap); // 插入排序（希尔排序为插入排序类） method4c(n, a, gap); &#125; &#125; private static void method4c(int n, int[] a, int gap) &#123; for (int i = gap; i &lt; n; i += gap) &#123; int t = a[i]; int j = i - gap; for (; j &gt; -gap &amp;&amp; a[j] &gt; t; j -= gap) a[j + gap] = a[j]; a[j + gap] = t; &#125; &#125; @SuppressWarnings("unused") private static void method4b(int n, int[] a, int gap) &#123; for (int i = gap; i &lt; n - gap; i += gap) &#123; int min = i; for (int j = i + gap; j &lt; n; j += gap) if (a[j] &lt; a[min]) min = j; if (min != i) swap(a, i, min); &#125; &#125; @SuppressWarnings("unused") private static void method4a(int n, int[] a, int gap) &#123; boolean flag = false; for (int i = 0; i &lt; n - gap &amp;&amp; !flag; i += gap) &#123; flag = true; for (int j = 0; j &lt; n - gap - i; j += gap) &#123; if (a[j] &gt; a[j + gap]) swap(a, j, j + gap); flag = false; &#125; &#125; &#125; 希尔排序是基于插入排序的以下两点性质而提出改进方法的：1) 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；2) 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。 希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。 假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n^2)的排序（冒泡排序或直接插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。 快速排序快速排序是一个不稳定算法。原理形象的说，就是每次递归时，在该序列段内选择一个数（一般为第一个数）做为基准，然后将这个序列中比这个数大的数放在右边，比它小的放在左边。 Java的API中可以使用深度优化的Arrays.sort()方法。对于基础类型，底层使用快速排序。对于非基础类型，底层使用归并排序。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 快速排序：选择一个数作为基准(一般是第一个数),然后将之后的序列中比这个基准数小的数放在左边，比它大的数放在右边。接着将基准数放在“中间”，通过递归分别再处理左边和右边。 * * @param a * 要排序的数组 */ public static void quickSort(int[] a) &#123; // TODO Auto-generated method stub checkArray(a); int n = a.length; int le = 0; int ri = n - 1; quickFun(a, le, ri); &#125; private static void quickFun(int[] a, int le, int ri) &#123; if (le &lt; 0 || ri &gt; a.length - 1 || le &gt;= ri) return; int i = le; int j = ri; int base = a[le]; while (i &lt; j) &#123; while (a[j] &gt; base &amp;&amp; i &lt; j) j--; if (i &lt; j) &#123; a[i] = a[j]; i++; &#125; while (a[i] &lt; base &amp;&amp; i &lt; j) i++; if (i &lt; j) &#123; a[j] = a[i]; j--; &#125; &#125; a[i] = base; quickFun(a, le, i - 1); quickFun(a, i + 1, ri); &#125; 对一般快速排序进行一些改进可以提高其效率。 当划分到较小的子序列时，通常可以使用插入排序替代快速排序。 三平均分区法(Median of three partitioning)。 由于快速排序在排序算法中具有排序速度快，而且是就地排序等优点，使得在许多编程语言的内部元素非稳定的排序实现中采用的就是快速排序。 可以参考这篇博客 其他排序其他的排序方法还有： 归并排序采用“分治”思想，简单将就是分块执行，每部分排序好后，再逐层合并结果。 堆排序堆排序的存储元素的数据结构为树，并且满足堆的性质（完全二叉树）。 排序算法的性能常用的排序算法的时间复杂度和空间复杂度 排序法 最差时间分析 平均时间复杂度 稳定度 空间复杂度 冒泡排序 O($n^{2}$) O($n^{2}$) 稳定 O(1) 快速排序 O($n^{2}$) O($n*\log_2n$) 不稳定 O($\log_2n$)~O(n) 选择排序 O($n^{2}$) O($n^{2}$) 稳定 O(1) 二叉树排序 O($n^{2}$) O($n*\log_2n$) 不稳定 O(n) 插入排序 O($n^{2}$) O($n^{2}$) 稳定 O(1) 堆排序 O($n*\log_2n$) O($n*\log_2n$) 不稳定 O(1) 希尔排序 O O 不稳定 O(1) 结果测试只是验证了排序算法的正确性，没有对性能等进行测试。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public void test() &#123; int a[] = RandomIntegerArrayMethod.randomSelectArray(0, 9, 10); TestMethod.print(a); int b[] = a.clone(); swap(b, 3, 6); TestMethod.print(b); swap2(b, 1, 4); TestMethod.print(b); swap3(b, 5, 2); TestMethod.print(b); int c1[] = a.clone(); insertSort(c1); TestMethod.print(c1); int c2[] = a.clone(); bubbleSort(c2); TestMethod.print(c2); int c3[] = a.clone(); selectSort(c3); TestMethod.print(c3); int c4[] = a.clone(); shellSort(c4); TestMethod.print(c4); int c5[] = a.clone(); quickSort(c5); TestMethod.print(c5); // other test int d[] = &#123; 2, 4, 5, 6, 2, 0, 2 &#125;; int d1[] = d.clone(); insertSort(d1); TestMethod.print(d1); int d2[] = d.clone(); bubbleSort(d2); TestMethod.print(d2); int d3[] = d.clone(); selectSort(d3); TestMethod.print(d3); int d4[] = d.clone(); shellSort(d4); TestMethod.print(d4); int d5[] = d.clone(); quickSort(d5); TestMethod.print(d5); // insertSort(null); &#125; 测试结果6 9 8 7 2 4 0 3 1 56 9 8 0 2 4 7 3 1 56 2 8 0 9 4 7 3 1 56 2 4 0 9 8 7 3 1 50 1 2 3 4 5 6 7 8 90 1 2 3 4 5 6 7 8 90 1 2 3 4 5 6 7 8 90 1 2 3 4 5 6 7 8 90 1 2 3 4 5 6 7 8 90 2 2 2 4 5 60 2 2 2 4 5 60 2 2 2 4 5 60 2 2 2 4 5 60 2 2 2 4 5 6]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的查找算法]]></title>
    <url>%2F2016%2F03%2F24-search-integer-array%2F</url>
    <content type="text"><![CDATA[常见的数组查找算法(Java版)在一些算法题中，或者是做项目中，常常需要查找某个数据，为此将一些常见的查找算法加以整理。还有很多高级的查找算法，这里只是一些基础的查找算法，数组均为整型类型。 常见的查找算法： 找出最值 线性查找 折半查找 哈希查找 2017年12月13日，加入哈希查找。 常见的查找算法找出最值顾名思义就是找出数组中的最大值和最小值，基础做法是循环遍历即可。123456789101112131415161718192021222324252627282930313233343536/** * 找出整型数组中的&lt;i&gt;最小值&lt;/i&gt; * * @param a * 要查找的数组 * @return 返回数组中最小元素的值 */ public static int getMin(int[] a) &#123; checkArray(a); int p = 0; for (int i = 0; i &lt; a.length; i++) if (a[p] &gt; a[i]) p = i; return a[p]; &#125; /** * 找出整型数组中的&lt;i&gt;最大值&lt;/i&gt; * * @param a * 要查找的数组 * @return 返回数组中最大元素的值 */ public static int getMax(int[] a) &#123; checkArray(a); int p = 0; for (int i = 0; i &lt; a.length; i++) if (a[p] &lt; a[i]) p = i; return a[p]; &#125; private static void checkArray(int[] a) &#123; if (a == null || a.length &lt; 1) throw new RuntimeException("array is null or empty"); &#125; 线性查找所谓线性查找，简单讲是将数组遍历一遍。123456789101112131415161718/** * 线性查找 * * @param a * 待查找数组 * @param k * 查找的数据 * @return 若找到则返回元素所在数组的&lt;i&gt;下标&lt;/i&gt;，若没有找到则返回-1 */ public static int orderSearch(int[] a, int k) &#123; checkArray(a); int index = -1; for (index = 0; index &lt; a.length; index++) &#123; if (a[index] == k) return index; &#125; return -1; &#125; 折半查找折半查找又叫二分查找。需要查找的数组需要是已经排序好的。这里参考别人博客里的一张图，演示二分查找的基本过程。12345678910111213141516171819202122232425262728/** * 折半查找(二分查找)，&lt;b&gt;必须有序数组或者已知固定数组&lt;/b&gt; * * @param a * 待查找数组 * @param k * 查找的数据 * @return 若找到则返回元素所在数组的&lt;i&gt;下标&lt;/i&gt;，若没有找到则返回查找的元素在序列&lt;i&gt;可插入的位置的负数&lt;/i&gt; */ public static int halfSearch(int[] a, int k) &#123; checkArray(a); int min, max, mid; min = 0; max = a.length - 1; do &#123; mid = (max + min) &gt;&gt;&gt; 1; if (k &lt; a[mid]) max = mid - 1; else if (k &gt; a[mid]) min = mid + 1; else if (k == a[mid]) return mid; &#125; while (min &lt;= max); return -1 - min; &#125; 哈希查找哈希查找是利用hash值建表进行查找。hash主要耗时是在第一次建表的过程，只要数据没有发生改变，之后的查找速度会快的多。1234567891011121314151617181920212223242526/** * 利用hash查找无序表中的某一个元素（只是演示算法，并不是最优的） * * @param a * 待查找数组 * @param k * 查找的数据 * @return 若找到则返回元素所在数组的&lt;i&gt;下标&lt;/i&gt;，若没有找到返回-1 */ public static int hashSearch(int[] a, int k) &#123; int base = 10; int len = a.length; if (len &lt; base) return orderSearch(a, k); int[] f = new int[base]; int[][] h = new int[base][len]; int[][] s = new int[base][len]; for (int i = 0; i &lt; len; i++) &#123; int v = Math.abs(a[i]) % base; h[v][f[v]] = a[i]; s[v][f[v]++] = i; &#125; int e = Math.abs(k) % base; int p = orderSearch(h[e], k); return p == -1 ? -1 : s[e][p]; &#125; 测试结果测试代码： 12345678910111213141516171819202122232425262728293031323334353637383940package com.chain.test;import org.junit.Test;import com.chain.utils.IntegerArraySearchUtils;import com.chain.utils.IntegerArraySortUtils;import com.chain.utils.PrintUtils;import com.chain.utils.RandomIntegerArrayUtils;public class IntegerArraySearchUtilsTest &#123; @Test public void test() &#123; int[] a = RandomIntegerArrayUtils.randomSelectArray(0, 9, 10); PrintUtils.show(a); System.out.println(IntegerArraySearchUtils.getMax(a)); System.out.println(IntegerArraySearchUtils.getMin(a)); System.out.println(IntegerArraySearchUtils.orderSearch(a, 4)); System.out.println(IntegerArraySearchUtils.orderSearch(a, 12)); IntegerArraySortUtils.quickSort(a); PrintUtils.show(a); System.out.println(IntegerArraySearchUtils.halfSearch(a, 8)); System.out.println(IntegerArraySearchUtils.halfSearch(a, 10)); System.out.println(IntegerArraySearchUtils.halfSearch(a, 20)); a = new int[] &#123; 2, 4, 7, 9, 11, 15, 23, 27, 29, 31, 35, 40, 43, 50, 65 &#125;; System.out.println(IntegerArraySearchUtils.halfSearch(a, 43)); a = RandomIntegerArrayUtils.randomSelectArray(0, 1000, 500); System.out.println(IntegerArraySearchUtils.orderSearch(a, 100)); System.out.println(IntegerArraySearchUtils.hashSearch(a, 100)); // other test // System.out.println(IntegerArraySearchUtils.halfSearch(null, 8)); &#125;&#125; 测试结果： 1234567891011127 2 5 9 8 1 4 6 0 3 906-10 1 2 3 4 5 6 7 8 9 8-11-1112245245]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成随机整型数组的方法]]></title>
    <url>%2F2016%2F03%2F21-random-integer-array%2F</url>
    <content type="text"><![CDATA[生成随机整型数组的方法(Java版)在做一些项目时，常常需要一些随机的数据，为此研究和整理了一些常见的生成随机不重复的整形数组的方法。 主要有以下几种:1.使用List2.两次循环3.使用HashSet4.使用已排序数组 下面详细介绍一下这些方法的源码：使用List方法主要利用了List中的contains方法，循环生成随机数，再添加前判断List中是否已经存在这个数。12345678910111213141516171819202122232425/** * 随机指定范围内N个不重复的数 利用List中contains方法 * * @param min * 指定范围最小值 * @param max * 指定范围最大值 * @param n * 随机数个数 * @return int[] 随机数结果数组 */ private static int[] randomByList(int min, int max, int n) &#123; checkArgs(min, max, n); int[] result = new int[n]; List&lt;Integer&gt; lst = new ArrayList&lt;&gt;(); Random rand = new Random(); while (lst.size() &lt; n) &#123; int num = rand.nextInt(max + 1) + min; if (!lst.contains(num)) lst.add(num); &#125; for (int i = 0; i &lt; n; i++) result[i] = lst.get(i); return result; &#125; 使用两次循环其实原理和1一样，是利用循环的方式，翻看Java的ArrayList源码也可以看到contains方法也是利用了循环判断方式。123456789101112131415161718192021222324252627282930313233/** * 随机指定范围内N个不重复的数 最简单最基本的方法(双重循环) * * @param min * 指定范围最小值 * @param max * 指定范围最大值 * @param n * 随机数个数 * @return int[] 随机数结果数组 */ private static int[] randomDoubleCirculation(int min, int max, int n) &#123; checkArgs(min, max, n); int[] result = new int[n]; int count = 0; boolean flag = true; while (count &lt; n) &#123; // Math.random()返回[0.0 1.0) int num = (int) (Math.random() * (max - min + 1)) + min; flag = true; for (int j = 0; j &lt; count; j++) &#123; if (num == result[j]) &#123; flag = false; break; &#125; &#125; if (flag == true) &#123; result[count] = num; count++; &#125; &#125; return result; &#125; 使用HashSet方式利用HashSet的特征，只能存放不同的值，可以达到要求。但是，该方法不能产生正确的随机数数组，因为HashSet底层是HashMap，如果随机数个数和范围区间值一样，比如生成0-9的10个随机数，结果会自动排序。 无论使用递归还是循环，都不能正确的得到结果。123456789101112131415161718192021222324252627282930313233/** * 随机指定范围内N个不重复的数 利用HashSet的特征，只能存放不同的值 * * 更新：该方法不能产生正确的随机数数组，因为HashSet底层是HashMap,如果随机数个数和范围区间值一样，比如生成0-9的10个随机数，结果会自动排序。 * 无论使用递归还是循环，都不能正确的得到结果。 * * @param min * 指定范围最小值 * @param max * 指定范围最大值 * @param n * 随机数个数 * @return int[] 随机数结果数组 */ @Deprecated private static int[] randomHashSet(int min, int max, int n) &#123; checkArgs(min, max, n); HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(0); Random rand = new Random(); while (set.size() &lt; n) &#123; int num = rand.nextInt(max + 1) + min; /* * while (set.contains(num)) num = rand.nextInt(max) + min; */ set.add(num); &#125; int a[] = new int[n]; Integer ia[] = new Integer[n]; set.toArray(ia); for (int i = 0; i &lt; n; i++) a[i] = ia[i]; return a; &#125; 使用已排序好的数组在初始化的无重复待选数组中随机产生一个数放入结果中，将待选数组被随机到的数，用待选数组(len-1)下标对应的数替换 然后从len-2里随机产生下一个随机数，如此类推。12345678910111213141516171819202122232425262728293031323334/** * 随机指定范围内N个不重复的数 在初始化的无重复待选数组中随机产生一个数放入结果中， * 将待选数组被随机到的数，用待选数组(len-1)下标对应的数替换 然后从len-2里随机产生下一个随机数，如此类推 * * @param max * 指定范围最大值 * @param min * 指定范围最小值 * @param n * 随机数个数 * @return int[] 随机数结果数组 */ private static int[] randomSelectArray(int min, int max, int n) &#123; checkArgs(min, max, n); int len = max - min + 1; // 初始化给定范围的待选增序数组 int[] source = new int[len]; for (int i = min; i &lt; min + len; i++) &#123; source[i - min] = i; &#125; int[] result = new int[n]; Random rd = new Random(); int index = 0; for (int i = 0; i &lt; result.length; i++) &#123; // 待选数组0到(len-2)随机一个下标 index = Math.abs(rd.nextInt() % len--); // 将随机到的数放入结果集 result[i] = source[index]; // 将待选数组中被随机到的数，用待选数组(len-1)下标对应的数替换 source[index] = source[len]; &#125; return result; &#125; 方法测试123456789101112131415161718192021222324@Testpublic void test() &#123; int a[] = randomDoubleCirculation(0, 9, 10); TestMethod.print(a); int b[] = randomSelectArray(0, 9, 10); TestMethod.print(b); int c[] = randomHashSet(0, 9, 10); TestMethod.print(c); int d[] = randomByList(0, 9, 10); TestMethod.print(d); int e[] = randomSelectArray(-6, 9, 5); TestMethod.print(e); int f[] = randomDoubleCirculation(-6, 9, 7); TestMethod.print(f); // other test // int g[] = randomDoubleCirculation(-6, 9, 20); // TestMethod.print(g); &#125; 测试结果： a: 4 2 6 1 9 8 7 0 3 5b: 9 0 6 3 2 4 8 1 5 7c: 0 1 2 3 4 5 6 7 8 9d: 9 3 0 6 2 5 1 8 4 7e: 9 4 -3 0 2f: 6 -3 1 -6 8 9 -4]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2F2016%2F03%2F18-hello-world%2F</url>
    <content type="text"><![CDATA[Welcome to StackEdit!Hey! I’m your first Markdown document in StackEdit[^stackedit]. Don’t delete me, I’m very helpful! I can be recovered anyway in the Utils tab of the Settings dialog. Download file link: hello-world.txt DocumentsStackEdit stores your documents in your browser, which means all your documents are automatically saved locally and are accessible offline! Note: StackEdit is accessible offline after the application has been loaded for the first time. Your local documents are not shared between different browsers or computers. Clearing your browser’s data may delete all your local documents! Make sure your documents are synchronized with Google Drive or Dropbox (check out the Synchronization section). Create a documentThe document panel is accessible using the button in the navigation bar. You can create a new document by clicking New document in the document panel. Switch to another documentAll your local documents are listed in the document panel. You can switch from one to another by clicking a document in the list or you can toggle documents using Ctrl+[ and Ctrl+]. Rename a documentYou can rename the current document by clicking the document title in the navigation bar. Delete a documentYou can delete the current document by clicking Delete document in the document panel. Export a documentYou can save the current document to a file by clicking Export to disk from the menu panel. Tip: Check out the Publish a document section for a description of the different output formats. SynchronizationStackEdit can be combined with Google Drive and Dropbox to have your documents saved in the Cloud. The synchronization mechanism takes care of uploading your modifications or downloading the latest version of your documents. Note: Full access to Google Drive or Dropbox is required to be able to import any document in StackEdit. Permission restrictions can be configured in the settings. Imported documents are downloaded in your browser and are not transmitted to a server. If you experience problems saving your documents on Google Drive, check and optionally disable browser extensions, such as Disconnect. Open a documentYou can open a document from Google Drive or the Dropbox by opening the Synchronize sub-menu and by clicking Open from…. Once opened, any modification in your document will be automatically synchronized with the file in your Google Drive / Dropbox account. Save a documentYou can save any document by opening the Synchronize sub-menu and by clicking Save on…. Even if your document is already synchronized with Google Drive or Dropbox, you can export it to a another location. StackEdit can synchronize one document with multiple locations and accounts. Synchronize a documentOnce your document is linked to a Google Drive or a Dropbox file, StackEdit will periodically (every 3 minutes) synchronize it by downloading/uploading any modification. A merge will be performed if necessary and conflicts will be detected. If you just have modified your document and you want to force the synchronization, click the button in the navigation bar. Note: The button is disabled when you have no document to synchronize. Manage document synchronizationSince one document can be synchronized with multiple locations, you can list and manage synchronized locations by clicking Manage synchronization in the Synchronize sub-menu. This will let you remove synchronization locations that are associated to your document. Note: If you delete the file from Google Drive or from Dropbox, the document will no longer be synchronized with that location. PublicationOnce you are happy with your document, you can publish it on different websites directly from StackEdit. As for now, StackEdit can publish on Blogger, Dropbox, Gist, GitHub, Google Drive, Tumblr, WordPress and on any SSH server. Publish a documentYou can publish your document by opening the Publish sub-menu and by choosing a website. In the dialog box, you can choose the publication format: Markdown, to publish the Markdown text on a website that can interpret it (GitHub for instance), HTML, to publish the document converted into HTML (on a blog for example), Template, to have a full control of the output. Note: The default template is a simple webpage wrapping your document in HTML format. You can customize it in the Advanced tab of the Settings dialog. Update a publicationAfter publishing, StackEdit will keep your document linked to that publication which makes it easy for you to update it. Once you have modified your document and you want to update your publication, click on the button in the navigation bar. Note: The button is disabled when your document has not been published yet. Manage document publicationSince one document can be published on multiple locations, you can list and manage publish locations by clicking Manage publication in the menu panel. This will let you remove publication locations that are associated to your document. Note: If the file has been removed from the website or the blog, the document will no longer be published on that location. Markdown ExtraStackEdit supports Markdown Extra, which extends Markdown syntax with some nice features. Tip: You can disable any Markdown Extra feature in the Extensions tab of the Settings dialog. Note: You can find more information about Markdown syntax here and Markdown Extra extension here. TablesMarkdown Extra has a special syntax for tables: Item Value Computer $1600 Phone $12 Pipe $1 You can specify column alignment with one or two colons: Item Value Qty Computer $1600 5 Phone $12 12 Pipe $1 234 Definition ListsMarkdown Extra has a special syntax for definition lists too: Term 1Term 2: Definition A: Definition B Term 3 : Definition C : Definition D &gt; part of definition D Fenced code blocksGitHub’s fenced code blocks are also supported with Highlight.js syntax highlighting: 12// Foovar bar = 0; Tip: To use Prettify instead of Highlight.js, just configure the Markdown Extra extension in the Settings dialog. Note: You can find more information: about Prettify syntax highlighting here, about Highlight.js syntax highlighting here. FootnotesYou can create footnotes like this[^footnote]. [^footnote]: Here is the text of the footnote. SmartyPantsSmartyPants converts ASCII punctuation characters into “smart” typographic punctuation HTML entities. For example: ASCII HTML Single backticks &#39;Isn&#39;t this fun?&#39; ‘Isn’t this fun?’ Quotes &quot;Isn&#39;t this fun?&quot; “Isn’t this fun?” Dashes -- is en-dash, --- is em-dash – is en-dash, — is em-dash Table of contentsYou can insert a table of contents using the marker [TOC]: [TOC] MathJaxYou can render LaTeX mathematical expressions using MathJax, as on math.stackexchange.com: The Gamma function satisfying $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$ is via the Euler integral $$\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,.$$ Tip: To make sure mathematical expressions are rendered properly on your website, include MathJax into your template: 1&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot;&gt;&lt;/script&gt; Note: You can find more information about LaTeX mathematical expressions here. UML diagramsYou can also render sequence diagrams like this: 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! And flow charts like this: 12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op Note: You can find more information: about Sequence diagrams syntax here, about Flow charts syntax here. Support StackEdit [^stackedit]: StackEdit is a full-featured, open-source Markdown editor based on PageDown, the Markdown library used by Stack Overflow and the other Stack Exchange sites.]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
