<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="转载,学习,操作系统,">










<meta name="description" content="操作系统原理之文件管理转载整理自这篇博客 操作系统原理之基础知识操作系统原理之死锁操作系统原理之处理机调度操作系统原理之信号量操作系统原理之进程和线程管理操作系统原理之内存管理 文件的概念和定义文件(File)是操作系统中的一个重要概念。 在系统运行时，计算机以进程为基本单位进行资源的调度和分配；在用户进行的输入、输出中，则以文件为基本单位。 大多数应用程序的输入都是通过文件来实现的，其输出也都保">
<meta name="keywords" content="转载,学习,操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统原理之文件管理">
<meta property="og:url" content="https://www.leechain.top/2017/07/21-operation-system-file/index.html">
<meta property="og:site_name" content="天印湖畔映白鹭">
<meta property="og:description" content="操作系统原理之文件管理转载整理自这篇博客 操作系统原理之基础知识操作系统原理之死锁操作系统原理之处理机调度操作系统原理之信号量操作系统原理之进程和线程管理操作系统原理之内存管理 文件的概念和定义文件(File)是操作系统中的一个重要概念。 在系统运行时，计算机以进程为基本单位进行资源的调度和分配；在用户进行的输入、输出中，则以文件为基本单位。 大多数应用程序的输入都是通过文件来实现的，其输出也都保">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/93.gif">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/94.gif">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/95.jpg">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/96.jpg">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/97.jpg">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/98.jpg">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/99.jpg">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/100.jpg">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/101.jpg">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/102.jpg">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/103.jpg">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/104.jpg">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/105.jpg">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/106.jpg">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/107.jpg">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/108.jpg">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/109.jpg">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/110.jpg">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/111.jpg">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/112.jpg">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/119.gif">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/120.gif">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/121.gif">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/122.gif">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/113.jpg">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/114.jpg">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/115.jpg">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/116.jpg">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/117.jpg">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/118.jpg">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/123.jpg">
<meta property="og:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/124.jpg">
<meta property="og:updated_time" content="2018-11-12T10:04:16.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="操作系统原理之文件管理">
<meta name="twitter:description" content="操作系统原理之文件管理转载整理自这篇博客 操作系统原理之基础知识操作系统原理之死锁操作系统原理之处理机调度操作系统原理之信号量操作系统原理之进程和线程管理操作系统原理之内存管理 文件的概念和定义文件(File)是操作系统中的一个重要概念。 在系统运行时，计算机以进程为基本单位进行资源的调度和分配；在用户进行的输入、输出中，则以文件为基本单位。 大多数应用程序的输入都是通过文件来实现的，其输出也都保">
<meta name="twitter:image" content="https://www.leechain.top/uploads/multithreads-basic-knowledge/93.gif">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.leechain.top/2017/07/21-operation-system-file/">





  <title>操作系统原理之文件管理 | 天印湖畔映白鹭</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">天印湖畔映白鹭</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">LEECHAIN | 博客</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.leechain.top/2017/07/21-operation-system-file/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chain Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天印湖畔映白鹭">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">操作系统原理之文件管理</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-21T00:00:00+08:00">
                2017-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2017/07/21-operation-system-file/#SOHUCS" itemprop="discussionUrl">
                  <span id="changyan_count_unit" class="post-comments-count hc-comment-count" data-xid="2017/07/21-operation-system-file/" itemprop="commentsCount"></span>
                </a>
              
            
          

          
          

          

          

          

        </span></div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="操作系统原理之文件管理"><a href="#操作系统原理之文件管理" class="headerlink" title="操作系统原理之文件管理"></a>操作系统原理之文件管理</h1><p>转载整理自<a href="http://c.biancheng.net/cpp/u/xitong_4/" target="_blank" rel="noopener">这篇博客</a></p>
<p><a href="https://www.leechain.top/blog/2017/07/15-operation-system-basic-knowledge.html">操作系统原理之基础知识</a><br><a href="https://www.leechain.top/blog/2017/08/24-operation-system-deadlock.html">操作系统原理之死锁</a><br><a href="https://www.leechain.top/blog/2017/08/23-operation-system-job-schedule.html">操作系统原理之处理机调度</a><br><a href="https://www.leechain.top/blog/2017/08/22-operation-system-semaphore.html">操作系统原理之信号量</a><br><a href="https://www.leechain.top/blog/2017/08/25-operation-system-multithreads.html">操作系统原理之进程和线程管理</a><br><a href="https://www.leechain.top/blog/2017/07/25-operation-system-memory.html">操作系统原理之内存管理</a></p>
<h2 id="文件的概念和定义"><a href="#文件的概念和定义" class="headerlink" title="文件的概念和定义"></a>文件的概念和定义</h2><p>文件(File)是操作系统中的一个重要概念。</p>
<p>在系统运行时，计算机以<strong>进程</strong>为基本单位进行资源的调度和分配；在用户进行的输入、输出中，则以<strong>文件</strong>为基本单位。</p>
<p>大多数应用程序的输入都是通过文件来实现的，其输出也都保存在文件中，以便信息的长期存及将来的访问。当用户将文件用于应用程序的输入、输出时，还希望可以访问文件、修改文件和保存文件等，实现对文件的维护管理，这就需要系统提供一个<strong>文件管理系统</strong>，操作系统中的文件系统(File System)就是用于实现用户的这些管理要求。</p>
<p>从用户的角度看，文件系统是操作系统的重要部分之一。用户关心的是如何命名、分类和查找文件，如何保证文件数据的安全性以及对文件可以进行哪些操作等。而对其中的细节，如文件如何存储在辅存上、如何管理文件辅存区域等关心甚少。</p>
<p>文件系统提供了与二级存储相关的资源的抽象，让用户能在不了解文件的各种属性、文件存储介质的特征以及文件在存储介质上的具体位置等情况下，方便快捷地使用文件。<br>用户通过文件系统建立文件，提供应用程序的输入、输出，对资源进行管理。</p>
<p>首先了解文件的结构，我们通过自底向上的方式来定义：</p>
<h3 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h3><p>数据项是文件系统中最低级的数据组织形式，可分为以下两种类型：<br>1、基本数据项：用于描述一个<strong>对象的某种属性</strong>的一个值，如姓名、日期或证件号等，是数据中可命名的最小逻辑数据单位，即原子数据。<br>2、组合数据项：由多个基本数据项组成。</p>
<h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3><p>记录是一组相关的<strong>数据项的集合</strong>，用于描述一个对象在某方面的属性，如一个考生报名记录包括考生姓名、出生日期、报考学校代号、身份证号等一系列域。</p>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件是指由创建者所定义的一组相关信息的集合，逻辑上可分为有结构文件和无结构文件两种：<br>1、在有结构文件中，文件由一组相似记录组成，如报考某学校的所有考生的报考信息记录，又称记录式文件；<br>2、无结构文件则被看成是一个字符流，比如一个二进制文件或字符文件，又称流式文件。</p>
<p>虽然上面给出了结构化的表述，但实际上关于文件并无严格的定义。<strong>通常在操作系统中将程序和数据组织成文件</strong>。文件可以是数字、字母或二进制代码，基本访问单元可以是字节、 行或记录。文件可以长期存储于硬盘或其他二级存储器中，允许可控制的进程间共享访问，能够被组织成复杂的结构。<strong>Linux中一切皆文件。</strong></p>
<h2 id="文件的属性"><a href="#文件的属性" class="headerlink" title="文件的属性"></a>文件的属性</h2><p>文件有一定的属性，这根据系统的不同而有所不同，但是通常都包括如下属性：</p>
<p>①名称：文件名称唯一，以容易读取的形式保存。<br>②标识符：标识文件系统内文件的唯一标签,通常为数字，它是对人不可读的一种<strong>内部名称</strong>。<br>③类型：被支持不同类型的文件系统所使用。<br>④位置：指向设备和设备上文件的指针。<br>⑤大小：文件当前大小（用字节、字或块表示），也可包含文件允许的最大值。<br>⑥保护：对文件进行保护的访问控制信息，比如读写执行权限等。<br>⑦时间、日期和用户标识：文件创建、上次修改和上次访问的相关信息，用于保护、 安全和跟踪文件的使用。</p>
<p>所有文件的信息都保存在目录结构中，而目录结构也保存在外存上。文件信息当需要时再调入内存。</p>
<blockquote>
<p>通常，目录条目包括文件名称和文件的唯一标识符，唯一标识符则定位该文件其他属性信息。</p>
</blockquote>
<h2 id="文件的基本橾作"><a href="#文件的基本橾作" class="headerlink" title="文件的基本橾作"></a>文件的基本橾作</h2><p>文件属于抽象数据类型。为了恰当地定义文件，就需要考虑有关文件的操作。操作系统提供<strong>系统调用</strong>，它对文件进行创建、写、读、定位和截断。</p>
<p>①创建文件：创建文件有两个必要步骤，一是在文件系统中为文件找到空间；二是在目录中为新文件创建条目，该条目记录文件名称、在文件系统中的位置及其他可能信息。<br>②写文件：为了写文件，执行一个系统调用，指明文件名称和要写入文件的内容。对于给定文件名称，系统搜索目录以查找文件位置。系统必须为该文件维护一个写位置的指针。每当发生写操作，便更新写指针。<br>③读文件：为了读文件，执行一个系统调用，指明文件名称和要读入文件块的内存位置。同样，需要搜索目录以找到相关目录项，系统维护一个读位置的指针。每当发生读操作时，更新读指针。一个进程通常只对一个文件读或写，所以当前操作位置可作为每个进程当前文件位置指针。由于读和写操作都使用<strong>同一指针</strong>，节省了空间也降低了系统复杂度。<br>④文件重定位（文件寻址）：按某条件搜索目录，将当前文件位置设为给定值，并且不会读、写文件。<br>⑤删除文件：先从目录中找到要删除文件的目录项，使之成为空项，然后回收该文件所占用的存储空间（一般只是删除目录项，不会再覆写文件内容）。<br>⑥<strong>截断文件</strong>：允许文件所有属性不变，并删除文件内容，即将其<strong>长度设为0</strong>并释放其空间。</p>
<p>这6个基本操作可以组合执行其他文件操作。</p>
<p>例如，一个文件的复制：先创建新文件，再从旧文件读出内容并写入到新文件。</p>
<h2 id="文件的打开与关闭"><a href="#文件的打开与关闭" class="headerlink" title="文件的打开与关闭"></a>文件的打开与关闭</h2><p>因为许多文件操作都涉及为给定文件搜索相关目录条目，许多系统要求在首次使用文件时，使用系统调用open，将指明文件的属性（包括该文件在外存上的物理位置）从外存拷贝到内存打开文件目录表的一个表目中，并将该表目的<strong>编号（或称为索引）</strong>返回给用户。操作系统维护一个包含所有<strong>打开的文件信息表</strong>（打开文件表，open-file table）。当用户需要一个文件操作时，可通过该表的一个<strong>索引</strong>指定文件，就省略了搜索环节。当文件不再使用时，进程可以关闭它，操作系统从打开文件表中删除这一条目。</p>
<p>大部分操作系统要求在文件使用之前就被显式地打开。操作open会根据文件名搜索目录，并将目录条目复制到打开文件表。如果调用open的请求（创建、只读、读写、添加等）得到允许，进程就可以打开文件，而open通常返回一个指向打开文件表中的一个条目的<strong>指针</strong>。通过使用该指计（而非文件名）进行所有I/O操作，以简化步骤并节省资源。</p>
<p>整个系统表包含进程相关信息，如文件在磁盘的位置、访问日期和大小。一个进程打开一个文件，系统打开文件表就会为打开的文件增加相应的条目。当另一个进程执行open时，只不过是在其进程打开表中增加一个条目，并指向整个系统表的相应条目。通常，系统打开文件表的每个文件时，还用一个<strong>文件打开计数器(Open Count)</strong>，以记录多少进程打开了该文件。每个关闭操作close则使count递减，当打开计数器为0时，表示该文件不再被使用，系统将回收分配给该文件的内存空间等资源。若文件被修改过，则将文件写回外存，并将系统打开文件表中相应条目删除，最后释放文件的<strong>文件控制块(File Control Block, FCB)</strong>。</p>
<p>每个打开的文件都有如下关联信息：<br>1、文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是<strong>唯一</strong>的，因此必须与磁盘文件属性分开保存。<br>2、文件打开计数：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间会不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件。该计数器跟踪打开和关闭的数量，当该计数为0 时，系统关闭文件，删除该条目。<br>3、文件磁盘位置：绝大多数文件操作都要求系统修改文件数据。该信息保存在内存中以免为每个操作都从磁盘中读取。<br>4、访问权限：每个进程打开文件都需要有一个<strong>访问模式</strong>（创建、只读、读写、添加等)。该信息保存在进程的打开文件表中以便操作系统能允许或拒绝之后的I/O请求。</p>
<h2 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h2><p>文件的逻辑结构是从用户观点出发看到的文件的<strong>组织形式</strong>。<br>文件的物理结构是从实现观点出发，又称为文件的存储结构，是指文件在外存上的<strong>存储形式</strong>。<br>文件的逻辑结构与存储介质特性无关，但文件的物理结构与存储介质的特性有很大关系。</p>
<p>按逻辑结构，文件有无结构文件和有结构文件两种类型：<strong>无结构文件和有结构文件</strong>。</p>
<h3 id="无结构文件（流式文件）"><a href="#无结构文件（流式文件）" class="headerlink" title="无结构文件（流式文件）"></a>无结构文件（流式文件）</h3><p>无结构文件是最简单的文件组织形式。无结构文件将数据按<strong>顺序</strong>组织成记录并积累保存，它是有序相关信息项的集合，以字节(Byte)为单位。由于无结构文件没有结构，因而对记录的访问只能通过<strong>穷举搜索</strong>的方式，故这种文件形式对大多数应用不适用。</p>
<p>但字符流的无结构文件管理简单，用户可以方便地对其进行操作。所以，那些对基本信息单位操作不多的文件较适于釆用字符流的无结构方式，如源程序文件、目标代码文件等。</p>
<h3 id="有结构文件（记录式文件）"><a href="#有结构文件（记录式文件）" class="headerlink" title="有结构文件（记录式文件）"></a>有结构文件（记录式文件）</h3><blockquote>
<p>有结构文件按记录的组织形式可以分为：顺序文件、索引文件、索引顺序文件、直接文件（散列文件）。</p>
</blockquote>
<h4 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h4><p>文件中的<strong>记录</strong>一个接一个地<strong>顺序</strong>排列，记录可以是定长的或变长的，可以顺序存储或以链表形式存储，在访问时需要顺序搜索文件。</p>
<p>顺序文件有以下两种结构：<br>第一种是串结构，记录之间的顺序与关键字无关。通常的办法是由时间决定，即按<strong>存入时间的先后</strong>排列，最先存入的记录作为第1个记录，其次存入的为第2个记录，依此类推。<br>第二种是顺序结构，指文件中的所有记录按<strong>关键字顺序</strong>排列。</p>
<p>在对记录进行批量操作时，即每次要<strong>读或写</strong>一大批记录，对顺序文件的效率是所有逻辑文件中最高的；<br>此外，也只有顺序文件才能存储在磁带上，并能有效地工作。<br><strong>但顺序文件对查找、修改、增加或删除单个记录的操作比较困难</strong>。</p>
<h4 id="索引文件。"><a href="#索引文件。" class="headerlink" title="索引文件。"></a>索引文件。</h4><p>对于<strong>定长记录</strong>文件，如果要查找第i个记录，可直接根据<strong>公式计算</strong>来迅速获得第i个记录相对于第一个记录的地址：</p>
<p><img src="/uploads/multithreads-basic-knowledge/93.gif" alt="image"></p>
<p>对于<strong>可变长记录</strong>的文件，要查找第i个记录时，必须顺序地查找前i-1个记录，从而获得相应记录的长度L，然后才能按下面的公式计算出第i个记录的首址：</p>
<p><img src="/uploads/multithreads-basic-knowledge/94.gif" alt="image"></p>
<p>注意：假定每个记录前用一个字节指明该记录的长度。</p>
<p>变长记录文件只能顺序查找，系统开销较大。为此可以建立一张索引表以加快检索速度，索引表本身是<strong>定长记录的顺序文件</strong>。在记录很多或是访问要求高的文件中，需要引入索引以提供有效的访问。实际中，通过索引可以成百上千倍地<strong>提高访问速度</strong>。</p>
<p>索引文件示意图：</p>
<p><img src="/uploads/multithreads-basic-knowledge/95.jpg" alt="image"></p>
<h4 id="索引顺序文件。"><a href="#索引顺序文件。" class="headerlink" title="索引顺序文件。"></a>索引顺序文件。</h4><p>索引顺序文件是<strong>顺序和索引</strong>两种组织形式的结合。索引顺序文件将顺序文件中的所有记录分为若干个组，为顺序文件建立一张索引表，在索引表中为每组中的第一个记录建立一个索引项，其中含有该记录的关键字值和指向该记录的指针。</p>
<p>索引顺序文件示意图：</p>
<p><img src="/uploads/multithreads-basic-knowledge/96.jpg" alt="image"></p>
<p>如上图所示，主文件名包含姓名和其他数据项。姓名为关键字，索引表中为每组的第一个记录（不是每个记录）的关键字值，用指计指向主文件中该记录的起始位置。索引表只包含关键字和指计两个数据项，所有姓名关键字递增排列。主文件中记录分组排列，<strong>同一个组中关键字可以无序，但组与组之间关键字必须有序</strong>。查找一个记录时，通过索引表找到其所在的组，然后在该组中使用顺序查找就能很快地找到记录。</p>
<p>对于含有N个记录的顺序文件，查找某关键字值的记录时平均需要查找N/2次。在索引顺序文件中，假设N个记录分为N1/2组，索引表中有N1/2个表项，每组有N1/2个记录，在查找某关键字值的记录时，先顺序查找索引表，需要查找N1/2/2次，然后再在主文件中对应的组中顺序查找，也需要查找N1/2/2次，这样总共查找N1/2/2+N1/2/2=N1/2次。显然，索引顺序文件提高了查找效率，如果记录数很多，可以釆用<strong>两级或多级索引</strong>。</p>
<p>索引文件和索引顺序文件都提高了存取的速度，但因为配置索引表而增加了存储空间。</p>
<h4 id="直接文件或散列文件-Hash-File"><a href="#直接文件或散列文件-Hash-File" class="headerlink" title="直接文件或散列文件(Hash File)"></a>直接文件或散列文件(Hash File)</h4><p>给定记录的键值或通过Hash函数转换的键值<strong>直接决定</strong>记录的物理地址。<br>这种映射结构不同于顺序文件或索引文件，没有顺序的特性。</p>
<p>散列文件有很高的存取速度，但是会引起冲突，即不同关键字的散列函数值相同情况。</p>
<h2 id="文件的目录结构"><a href="#文件的目录结构" class="headerlink" title="文件的目录结构"></a>文件的目录结构</h2><p>与文件管理系统和文件集合相关联的是文件目录，它包含有关文件的信息，包括属性、 位置和所有权等，这些信息主要是由操作系统进行管理。</p>
<p>首先我们来看目录管理的基本要求:<br>从用户的角度看，目录在用户（应用程序）所需要的文件名和文件之间提供一种映射，所以目录管理要实现<strong>“按名存取”</strong>；目录存取的效率直接影响到系统的性能，所以要提高对目录的<strong>检索速度</strong>；在共享系统中，目录还需要提供用于<strong>控制访问文件的信息</strong>。此外，文件允许重名也是用户的合理和必然要求，目录管理通过<strong>树形结构</strong>来解决和实现。</p>
<h3 id="文件控制块和索引结点"><a href="#文件控制块和索引结点" class="headerlink" title="文件控制块和索引结点"></a>文件控制块和索引结点</h3><p>同进程管理一样，为实现目录管理，操作系统中引入了<strong>文件控制块</strong>的数据结构。</p>
<p>1) 文件控制块。</p>
<p>文件控制块(FCB)是用来存放控制文件需要的各种信息的数据结构，以实现“按名存取”。<strong>FCB的有序集合称为文件目录，一个FCB就是一个文件目录项</strong>。<br>为了创建一个新文件，系统将分配一个FCB并存放在文件目录中，成为目录项。</p>
<p>FCB主要包含以下信息：<br>1、基本信息，如文件名、文件的物理位置、文件的逻辑结构、文件的物理结构等。<br>2、存取控制信息，如文件存取权限等。<br>3、使用信息，如文件建立时间、修改时间等。</p>
<p>2) 索引结点。</p>
<p>在检索目录文件的过程中，只用到了文件名，仅当找到一个目录项（查找文件名与目录项中文件名匹配）时，才需要从该目录项中读出该文件的物理地址。<br>也就是说，在检索目录时，文件的其他描述信息不会用到，也不需调入内存。因此，有的系统（如UNIX，见下表）釆用了文件名和文件描述信息分开的方法，文件描述信息单独形成一个称为索引结点的数据结构，简称为i-Node。在文件目录中的每个目录项仅由文件名和指向该文件所对应的i结点的指针构成。</p>
<p>UNIX的文件目录结构：<br><img src="/uploads/multithreads-basic-knowledge/97.jpg" alt="image"></p>
<p>一个FCB的大小是64字节，盘块大小是1KB，则在每个盘块中可以存放16个FCB（注意，FCB必须连续存放）。而在UNIX系统中一个目录项仅占16字节，其中14字节是文件名，2字节是i结点指针。在1KB的盘块中可存放64个目录项。这样，可使查找文件时平均启动磁盘次数减少到原来的1/4，大大节省了系统开销。</p>
<p>存放在磁盘上的索引结点称为磁盘索引结点，UNIX中的每个文件都有一个<strong>唯一的磁盘索引结点</strong>，主要包括以下几个方面：<br>1、文件主标识符，拥有该文件的个人或小组的标识符。<br>2、文件类型，包括普通文件、目录文件或特别文件。<br>3、文件存取权限，各类用户对该文件的存取权限。<br>4、文件物理地址，每个索引结点中含有13个地址项，即 iaddr(0) ~ iaddr(12)，它们以直接或间接方式给出数据文件所在盘块的编号。<br>5、文件长度，以字节为单位。<br>6、文件链接计数，在本文件系统中所有指向该文件的文件名的指针计数。<br>7、文件存取时间，本文件最近被进程存取的时间、最近被修改的时间以及索引结点最近被修改的时间。<br>8、文件被打开时，磁盘索引结点复制到内存的索引结点中，以便于使用。在内存索引结点中又增加了以下内容：<br>9、索引结点编号，用于标识内存索引结点。<br>10、状态，指示i结点是否上锁或被修改。<br>11、访问计数，每当有一进程要访问此i结点时，计数加1，访问结束减1。<br>12、逻辑设备号，文件所属文件系统的逻辑设备号。<br>13、链接指针，设置分别指向空闲链表和散列队列的指针。</p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>在理解一个文件系统的需求前，我们首先来考虑在目录这个层次上所需要执行的操作，这有助于后面文件系统的整体理解。<br>1、搜索：当用户使用一个文件时，需要搜索目录，以找到该文件的对应目录项。<br>2、创建文件：当创建一个新文件时，需要在目录中增加一个目录项。<br>3、删除文件：当删除一个文件时，需要在目录中删除相应的目录项。<br>4、显示目录：用户可以请求显示目录的内容，如显示该用户目录中的所有文件及属性。<br>5、修改目录：某些文件属性保存在目录中，因而这些属性的变化需要改变相应的目录项。</p>
<p>操作时，考虑以下几种目录结构：</p>
<h4 id="单级目录结构"><a href="#单级目录结构" class="headerlink" title="单级目录结构"></a>单级目录结构</h4><p>在整个文件系统中只建立<strong>一张目录表</strong>，每个文件占一个目录项，如下图所示。</p>
<p>单级目录结构：<br><img src="/uploads/multithreads-basic-knowledge/98.jpg" alt="image"></p>
<p>当访问一个文件时，先按文件名在该目录中查找到相应的FCB，经合法性检查后执行相应的操作。当建立一个新文件时，必须先检索所有目录项以确保没有“重名”的情况，然后在该目录中增设一项，把FCB的全部信息保存在该项中。当删除一个文件时，先从该目录中找到该文件的目录项，回收该文件所占用的存储空间，然后再清除该目录项。</p>
<p>单级目录结构实现了 “按名存取”，但是存在查找速度慢、文件不允许重名、不便于文件共享等缺点，而且对于多用户的操作系统显然是不适用的。</p>
<h4 id="两级目录结构"><a href="#两级目录结构" class="headerlink" title="两级目录结构"></a>两级目录结构</h4><p>单级目录很容易造成文件名称的混淆，可以考虑釆用<strong>两级方案</strong>，将文件目录分成主文件目录(Master File Directory, MFD)和用户文件目录（User File Directory, UFD)两级，如下图所示。</p>
<p>两级目录结构：<br><img src="/uploads/multithreads-basic-knowledge/99.jpg" alt="image"></p>
<p>主文件目录项记录用户名及相应用户文件目录所在的存储位置。用户文件目录项记录该用户文件的FCB信息。当某用户欲对其文件进行访问时，只需搜索该用户对应的UFD，这既解决了不同用户文件的“重名”问题，也在一定程度上保证了文件的安全。</p>
<p>两级目录结构可以解决多用户之间的文件重名问题，文件系统可以在目录上实现访问限制。但是两级目录结构缺乏灵活性，不能对文件分类。</p>
<h4 id="多级目录结构（树形目录结构-。"><a href="#多级目录结构（树形目录结构-。" class="headerlink" title="多级目录结构（树形目录结构)。"></a>多级目录结构（树形目录结构)。</h4><p>将两级目录结构的层次关系加以推广，就形成了多级目录结构，即树形目录结构，如下图所示。</p>
<p>树形目录结枸：<br><img src="/uploads/multithreads-basic-knowledge/100.jpg" alt="image"></p>
<p>用户要访问某个文件时用文件的路径名标识文件，文件路径名是个字符串，由从根目录出发到所找文件的通路上的所有目录名与数据文件名用<strong>分隔符</strong>链接起来而成。<br>从根目录出发的路径称<strong>绝对路径</strong>。当层次较多时，每次从根目录查询浪费时间，于是加入了<strong>当前目录</strong>，进程对各文件的访问都是相对于当前目录进行的，叫<strong>相对路径</strong>。当用户要访问某个文件时，使用相对路径标识文件，相对路径由从当前目录出发到所找文件通路上所有目录名与数据文件名用分隔符“/”链接而成。</p>
<p>上图是Linux操作系统的目录结构，“/dev/hda”就是一个绝对路径。若当前目录为 “/bin”，则“./ls”就是一个相对路径，其中符号“.”表示当前工作目录。</p>
<p>通常，每个用户都有各自的“当前目录”，登录后自动进入该用户的“当前目录”。操作系统提供一条专门的系统调用，供用户随时改变“当前目录”。<br>例如，UNIX系统中， “/etc/passwd”文件就包含有用户登录时默认的“当前目录”，可用cd命令改变“当前目录”。</p>
<p>树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，在树形目录中查找一个文件，需要按路径名逐级访问中间结点，这就增加了磁盘访问次数，无疑将影响查询速度。</p>
<h4 id="无环图目录结构。"><a href="#无环图目录结构。" class="headerlink" title="无环图目录结构。"></a>无环图目录结构。</h4><p>树形目录结构可便于实现文件分类，但不便于实现<strong>文件共享</strong>，为此在树形目录结构的基础上增加了一些指向同一结点的有向边，使整个目录成为一个<strong>有向无环图</strong>。</p>
<p>引入无环图目录结构是为了实现文件共享，如下图所示。</p>
<p>图形目录结构：<br><img src="/uploads/multithreads-basic-knowledge/101.jpg" alt="image"></p>
<p>当某用户要求删除一个共享结点时，若系统只是简单地将它删除，当另一共享用户需要访问时，却无法找到这个文件而发生错误。为此可以为每个共享结点设置一个<strong>共享计数器</strong>，每当图中增加对该结点的共享链时，计数器加1；每当某用户提出删除该结点时，计数器减1。仅当共享计数器为0时，才真正删除该结点，否则仅删除请求用户的共享链。</p>
<p>在linux中存在类似的实现：ln创建链接，下面会详细介绍。</p>
<p>共享文件（或目录）不同于文件拷贝（副本）。如果有两个文件拷贝，每个程序员看到的是拷贝而不是原件；但如果一个文件被修改，那么另一个程序员的拷贝不会有改变。<br>对于共享文件，只存在一个真正文件，任何改变都会为其他用户所见。</p>
<p>无环图目录结构方便实现了文件的共享，但使得系统的管理变得更加复杂。</p>
<h2 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h2><p>文件共享使多个用户（进程）共享同一份文件，系统中只需保留该文件的<strong>一份副本</strong>。如果系统不能提供共享功能，那么每个需要该文件的用户都要有各自的副本，会造成对存储空间的极大浪费。随着计算机技术的发展，文件共享的范围已由单机系统发展到多机系统，进而通过网络扩展到全球。这些文件的分享是通过<strong>分布式文件系统</strong>、远程文件系统、分布式信息系统实现的。这些系统允许多个客户通过C/S模型共享网络中的服务器文件。</p>
<p>现代常用的两种文件共享方法有：</p>
<h3 id="基于索引结点的共享方式（硬链接）"><a href="#基于索引结点的共享方式（硬链接）" class="headerlink" title="基于索引结点的共享方式（硬链接）"></a>基于索引结点的共享方式（硬链接）</h3><p>在树形结构的目录中，当有两个或多个用户要共享一个子目录或文件时，必须将共享文件或子目录链接到两个或多个用户的目录中，才能方便地找到该文件，如下图所示。</p>
<p>基于索引结点的共享方式：<br><img src="/uploads/multithreads-basic-knowledge/102.jpg" alt="image"></p>
<p>在这种共享方式中引用<strong>索引结点</strong>，即诸如文件的物理地址及其他的文件属性等信息，不再是放在目录项中，而是放在索引结点中。在文件目录中只设置文件名及指向相应索引结点的指针。在索引结点中还应有一个链接计数count，用于表示链接到本索引结点（亦即文件）上的用户目录项的数目。当count=2时，表示有两个用户目录项链接到本文件上，或者说是有两个用户共享此文件。</p>
<p>当用户A创建一个新文件时，它便是该文件的所有者，此时将count置为1。当有用户B要共享此文件时，在用户B的目录中增加一个目录项，并设置一指针指向该文件的索引结点。此时，文件主仍然是用户A，count=2。如果用户A不再需要此文件，不能将文件直接删除。因为，若删除了该文件，也必然删除了该文件的索引结点，这样便会便用户B的指针悬空，而用户B则可能正在此文件上执行写操作，此时用户B会无法访问到文件。因此用户A不能删除此文件，只是将该文件的count减1，然后删除自己目录中的相应目录项。用户B仍可以使用该文件。当count=0时，表示没有用户使用该文件，系统将负责删除该文件。</p>
<p>如下图给出了用户B链接到文件上的前、后情况。</p>
<p>文件共享中的链接计数<br><img src="/uploads/multithreads-basic-knowledge/103.jpg" alt="image"></p>
<h3 id="利用符号链实现文件共享（软链接）"><a href="#利用符号链实现文件共享（软链接）" class="headerlink" title="利用符号链实现文件共享（软链接）"></a>利用符号链实现文件共享（软链接）</h3><p>为使用户B能共享用户A的一个文件F,可以由系统创建一个LINK类型的<strong>新文件</strong>，也取名为F，并将文件F写入用户B的目录中，以实现用户B的目录与文件F的链接。<br>在新文件中只存储被链接文件F的<strong>路径名</strong>。这样的链接方法被称为<strong>符号链接</strong>。</p>
<p>新文件中的路径名则只被看做是符号链，当用户B要访问被链接的文件F且正要读LINK类新文件时，操作系统根据新文件中的路径名去读该文件，从而实现了用户B对文件F的共享。</p>
<p>在利用符号链方式实现文件共享时，只有文件的拥有者才拥有指向其索引结点的指针。而共享该文件的其他用户则只有该文件的路径名，并不拥有指向其索引结点的指针。这样，也就不会发生在文件主删除一共享文件后留下一悬空指针的情况。当文件的拥有者把一个共享文件删除后，其他用户通过符号链去访问它时，会出现访问失败，于是将符号链删除，此时不会产生任何影响。当然，利用符号链实现文件共享仍然存在问题，例如：一个文件釆用符号链方式共享，当文件拥有者将其删除，而在共享的其他用户使用其符号链接访问该文件之前，又有人在同一路径下创建了另一个具有同样名称的文件，则该符号链将仍然有效，但访问的文件已经改变，从而导致问题。</p>
<p>在符号链的共享方式中，当其他用户读共享文件时，需要根据文件路径名逐个地查找目录，直至找到该文件的索引结点。因此，每次访问时，都可能要多次地读盘，使得访问文件的开销变大并增加了启动磁盘的频率。此外，符号链的索引结点也要耗费一定的磁盘空间。符号链方式有一个很大的优点，即网络共享只需提供该文件所在机器的网络地址以及该机器中的文件路径即可。</p>
<p>软链接：创建一个新的文件LINK，文件内存储目标文件的路径，访问这个LINK文件，读取存储的路径后再去访问目标文件。删除软链接并不会删除目标文件，反过来删除目标文件，会导致LINK文件无法读取到目标文件，但LINK文件并不会消失。<br>硬链接：增加原来的目标文件的一个索引，读取文件就是对原文件的操作。硬链接有一个计数器，删除文件只是将计数器-1，直到计数器为0时，文件才会被真正删除。</p>
<p>上述两种链接方式都存在一个共同的问题，即每个共享文件都有几个文件名。换言之，每增加一条链接，就增加一个文件名。这实质上就是每个用户都使用自己的路径名去访问共享文件。当我们试图去遍历整个文件系统时，将会<strong>多次遍历</strong>到该共享文件。</p>
<p>硬链接和软链接都是文件系统中的<strong>静态共享</strong>方法，是属于存储的物理共享。在文件系统中还存在着另外的共享需求，即两个<strong>进程</strong>同时对同一个文件进行操作，这样的共享可以称为<strong>动态共享</strong>。</p>
<h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><p>为了防止文件共享可能会导致文件被破坏或未经核准的用户修改文件，文件系统必须控制用户对文件的存取，即解决对文件的读、写、执行的许可问题。<br>为此，必须在文件系统中建立相应的文件保护机制。</p>
<p>文件保护通过<strong>口令保护、加密保护和访问控制</strong>等方式实现。<br>其中，口令保护和加密保护是为了防止用户文件被他人存取或窃取，而访问控制则用于控制用户对文件的访问方式。</p>
<h3 id="访问类型"><a href="#访问类型" class="headerlink" title="访问类型"></a>访问类型</h3><p>对文件的保护可以从限制对文件的访问类型中出发。可加以控制的访问类型主要有以下几种：<br>1、读：从文件中读。<br>2、写：向文件中写。<br>3、执行：将文件装入内存并执行。<br>4、添加：将新信息添加到文件结尾部分。<br>5、删除：删除文件，释放空间。<br>6、列表清单：列出文件名和文件属性。</p>
<p>此外还可以对文件的重命名、复制、编辑等加以控制。这些高层的功能可以通过系统程序调用低层系统调用来实现。保护可以只在低层提供。<br>例如，复制文件可利用一系列的读请求来完成。这样，具有读访问用户同时也具有复制和打印的权限了。</p>
<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>解决访问控制最常用的方法是根据用户身份进行控制。而实现基于身份访问的最为普通的方法是为每个文件和目录增加一个访问控制列表(Access-Control List, ACL)，以规定每个用户名及其所允许的访问类型。</p>
<p>这种方法的优点是可以使用复杂的访同方法。其缺点是长度无法预期并且可能导致复杂的空间管理，使用精简的访问列表可以解决这个问题。</p>
<p>精简的访问列表釆用拥有者、组和其他三种用户类型。<br>1、拥有者：创建文件的用户。<br>2、组：一组需要共享文件且具有类似访问的用户。<br>3、其他：系统内的所有其他用户。</p>
<p>这样只需用三个域列出访问表中这三类用户的访问权限即可。文件拥有者在创建文件时，说明创建者用户名及所在的组名，系统在创建文件时也将文件主的名字、所属组名列在该文件的FCB中。用户访问该文件时，按照拥有者所拥有的权限访问文件，如果用户和拥有者在同一个用户组则按照同组权限访问，否则只能按其他用户权限访问。UNIX操作系统即釆用此种方法。</p>
<p>口令和密码是另外两种访问控制方法。</p>
<p>口令指用户在建立一个文件时提供一个口令，系统为其建立FCB时附上相应口令，同时告诉允许共享该文件的其他用户。用户请求访问时必须提供相应口令。这种方法时间和空间的开销不多，缺点是口令直接存在系统内部，不够安全。</p>
<p>密码指用户对文件进行加密，文件被访问时需要使用密钥。这种方法保密性强，节省了存储空间，不过编码和译码要花费一定时间。</p>
<p>口令和密码都是防止用户文件被他人存取或窃取，并没有控制用户对文件的访问类型。不过单纯的口令和密码是不够的，加密文件的内容才是更安全的做法。</p>
<p>注意两个问题：<br>1、现代操作系统常用的文件保护方法，是将访问控制列表与用户、组和其他成员访问控制方案一起<strong>组合使用</strong>。<br>2、对于多级目录结构而言，不仅需要保护单个文件，而且还需要保护子目录内的文件, 即需要提供<strong>目录保护机制</strong>。目录操作与文件操作并不相同，因此需要不同的保护机制。</p>
<h2 id="文件系统层次结构"><a href="#文件系统层次结构" class="headerlink" title="文件系统层次结构"></a>文件系统层次结构</h2><p>现代操作系统有多种文件系统类型（如FAT32、NTFS、 ext2、ext3、ext4等），因此文件系统的层次结构也不尽相同。</p>
<p>文件系统层次结构：<br><img src="/uploads/multithreads-basic-knowledge/104.jpg" alt="image"></p>
<p>1) 用户调用接口<br>文件系统为用户提供与文件及目录有关的调用，如新建、打开、读写、关闭、删除文件，建立、删除目录等。此层由若干程序模块组成，每一模块对应一条系统调用，用户发出系统调用时，控制即转入相应的模块。</p>
<p>2) 文件目录系统<br>文件目录系统的主要功能是管理文件目录，其任务有管理活跃文件目录表、管理读写状态信息表、管理用户进程的打开文件表、管理与组织在存储设备上的文件目录结构、调用下一级存取控制模块。</p>
<p>3) 存取控制验证<br>实现文件保护主要由该级软件完成，它把用户的访问要求与FCB中指示的访问控制权限进行比较，以确认访问的合法性。</p>
<p>4) 逻辑文件系统与文件信息缓冲区<br>逻辑文件系统与文件信息缓冲区的主要功能是根据文件的逻辑结构将用户要读写的逻辑记录转换成文件逻辑结构内的相应块号。</p>
<p>5) 物理文件系统<br>物理文件系统的主要功能是把逻辑记录所在的相对块号转换成实际的物理地址。</p>
<p>6) 分配模块<br>分配模块的主要功能是管理辅存空间，即负责分配辅存空闲空间和回收辅存空间。</p>
<p>7) 设备管理程序模块<br>设备管理程序模块的主要功能是分配设备、分配设备读写用缓冲区、磁盘调度、启动设备、处理设备中断、释放设备读写缓冲区、释放设备等。</p>
<h2 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h2><h3 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h3><p>在读文件前，必须先打开文件。</p>
<p>打开文件时，操作系统利用路径名找到相应目录项，目录项中提供了查找文件磁盘块所需要的信息。<br>目录实现的基本方法有<strong>线性列表和哈希表</strong>两种。</p>
<h4 id="线性列表"><a href="#线性列表" class="headerlink" title="线性列表"></a>线性列表</h4><p>最简单的目录实现方法是使用存储文件名和数据块指针的线性表。创建新文件时，必须首先搜索目录表以确定没有同名的文件存在，然后在目录表后增加一个目录项。删除文件则 根据给定的文件名搜索目录表，接着释放分配给它的空间。若要重用目录项，有许多方法：可以将目录项标记为不再使用，或者将它加到空闲目录项表上，还可以将目录表中最后一个目录项复制到空闲位置，并降低目录表长度。釆用链表结构可以减少删除文件的时间。其优点在于<strong>实现简单</strong>，不过由于线性表的特殊性，比较费时。</p>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希表根据文件名得到一个值，并返回一个指向线性列表中元素的指针。这种方法的优点是查找<strong>非常迅速</strong>，插入和删除也较简单，不过需要一些预备措施来避免冲突。最大的困难是哈希表长度固定以及哈希函数对表长的依赖性。</p>
<p>目录查询是通过在磁盘上反复搜索完成，需要不断地进行I/O操作，开销较大。所以如前面所述，为了减少I/O操作，把当前使用的文件目录复制到内存，以后要使用该文件时只要在内存中操作，从而降低了磁盘操作次数，提高了系统速度。</p>
<h3 id="文件实现"><a href="#文件实现" class="headerlink" title="文件实现"></a>文件实现</h3><h4 id="文件分配方式"><a href="#文件分配方式" class="headerlink" title="文件分配方式"></a>文件分配方式</h4><p>文件分配对应于文件的物理结构，是指如何为文件分配磁盘块。常用的磁盘空间分配方法有三种：<strong>连续分配、链接分配和索引分配</strong>。<br>有的系统（如RDOS操作系统）对三种方法都支持，但是更普遍的是一个系统只提供一种方法的支持。</p>
<p>1) 连续分配</p>
<p>连续分配方法要求每个文件在磁盘上占有一组<strong>连续的块</strong>，如下图所示。<br>磁盘地址定义了磁盘上的一个线性排序。这种排序使作业访问磁盘时需要的寻道数和寻道时间最小。</p>
<p>连续分配：<br><img src="/uploads/multithreads-basic-knowledge/105.jpg" alt="image"></p>
<p>文件的连续分配可以用第一块的磁盘地址和连续块的数量来定义。如果文件有n块长并从位置b开始，那么该文件将占有块b, b+1, b+2, …, b+n-1。<br>一个文件的目录条目包括开始块的地址和该文件所分配区域的长度。</p>
<p>连续分配支持<strong>顺序访问和直接访问</strong>。其优点是实现简单、存取速度快。缺点在于，文件长度不宜动态增加，因为一个文件末尾后的盘块可能已经分配给其他文件，一旦需要增加，就需要大量移动盘块。此外，反复增删文件后会产生外部碎片（与内存管理分配方式中的碎片相似)，并且很难确定一个文件需要的空间大小，因而只适用于长度固定的文件。</p>
<p>2) 链接分配</p>
<p>链接分配是釆取<strong>离散分配</strong>的方式，消除了外部碎片，故而显著地提高了磁盘空间的利用率；又因为是根据文件的当前需求，为它分配必需的盘块，当文件动态增长时，可以动态地再为它分配盘块，故而无需事先知道文件的大小。此外，对文件的增、删、改也非常方便。链接分配又可以分为<strong>隐式链接和显式链接</strong>两种形式。</p>
<p><strong>隐式连接</strong>如下图所示。每个文件对应一个磁盘块的链表；磁盘块分布在磁盘的任何地方，除最后一个盘块外，每一个盘块都有指向<strong>下一个盘块的指针</strong>，这些指针对用户是透明的。目录包括<strong>文件第一块的指针和最后一块的指针</strong>。</p>
<p>隐式链接分配：<br><img src="/uploads/multithreads-basic-knowledge/106.jpg" alt="image"></p>
<p>创建新文件时，目录中增加一个新条目。每个目录项都有一个指向文件首块的指针。该指针初始化为NULL以表示空文件，大小字段为0。写文件会通过空闲空间管理系统找到空闲块，将该块链接到文件的尾部，以便写入。读文件则通过块到块的指针顺序读块。</p>
<p>隐式链接分配的缺点在于无法直接访问盘块，只能通过指针顺序访问文件，以及盘块指针消耗了一定的存储空间。隐式链接分配的稳定性也是一个问题，系统在运行过程中由于软 件或者硬件错误导致链表中的指针丢失或损坏，会导致文件数据的丢失。</p>
<p><strong>显式链接</strong>是指把用于链接文件各物理块的指针，显式地存放在内存的一张<strong>链接表</strong>中。 该表在整个磁盘仅设置一张，每个表项中存放链接指针，即下一个盘块号。在该表中，凡是属于某一文件的第一个盘块号，或者说是每一条链的链首指针所对应的盘块号，均作为文件地址被填入相应文件的FCB的“物理地址”字段中。由于查找记录的过程是在内存中进行的，因而不仅显著地提高了检索速度，而且大大减少了访问磁盘的次数。由于分配给文件的所有盘块号都放在该表中，故称该表为文件分配表（File Allocation Table, FAT)。</p>
<p>3) 索引分配。</p>
<p>链接分配解决了连续分配的外部碎片和文件大小管理的问题。但是，链接分配不能有效支持直接访问（FAT除外）。索引分配解决了这个问题，它把每个文件的所有的盘块号都集中放在一起构成索引块（表），如下图所示。</p>
<p>索引分配：<br><img src="/uploads/multithreads-basic-knowledge/107.jpg" alt="image"></p>
<p>每个文件都有其索引块，这是一个磁盘块地址的数组。索引块的第i个条目指向文件的第i个块。目录条目包括索引块的地址。要读第i块，通过索引块的第i个条目的指针来查找和读入所需的块。</p>
<p>创建文件时，索引块的所有指针都设为空。当首次写入第i块时，先从空闲空间中取得一个块，再将其地址写到索引块的第i个条目。索引分配支持直接访问，且没有外部碎片问 题。其缺点是由于索引块的分配，增加了系统存储空间的开销。索引块的大小是一个重要的问题，每个文件必须有一个索引块，因此索引块应尽可能小，但索引块太小就无法支持大文件。</p>
<p>可以釆用以下机制来处理这个问题。</p>
<p>链接方案：一个索引块通常为一个磁盘块，因此，它本身能直接读写。为了处理大文件，可以将多个索引块链接起来。<br>多层索引：多层索引使第一层索引块指向第二层的索引块，第二层索引块再指向文件块。这种方法根据最大文件大小的要求，可以继续到第三层或第四层。例如，4096B的块，能在 索引块中存入1024个4B的指针。两层索引允许1048576个数据块，即允许最大文件为4GB。<br>混合索引：将多种索引分配方式相结合的分配方式。例如，系统既釆用直接地址，又采用单级索引分配方式或两级索引分配方式。</p>
<p>三种分配方式的比较：<br><img src="/uploads/multithreads-basic-knowledge/108.jpg" alt="image"></p>
<h4 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h4><p>1) 文件存储器空间的划分与初始化。</p>
<p>一般来说，一个文件存储在一个文件卷中。文件卷可以是物理盘的一部分，也可以是整个物理盘，支持超大型文件的文件卷也可以由多个物理盘组成，如下图所示。</p>
<p>逻辑卷与物理盘的关系：<br><img src="/uploads/multithreads-basic-knowledge/109.jpg" alt="image"></p>
<p>在一个文件卷中，文件数据信息的空间（文件区）和存放文件控制信息FCB的空间（目 录区）是分离的。由于存在很多种类的文件表示和存放格式，所以现代操作系统中一般都有 很多不同的文件管理模块，通过它们可以访问不同格式的逻辑卷中的文件。逻辑卷在提供文件服务前，必须由对应的文件程序进行初始化，划分好目录区和文件区，建立空闲空间管理 表格及存放逻辑卷信息的超级块。</p>
<p>2) 文件存储器空间管理。</p>
<p>文件存储设备分成许多大小相同的物理块，并以块为单位交换信息，因此，文件存储设备的管理实质上是对空闲块的组织和管理，它包括空闲块的组织、分配与回收等问题。</p>
<p>①空闲表法<br>空闲表法属于连续分配方式，它与内存的动态分配方式类似，为每个文件分配一块连续的存储空间。系统为外存上的所有空闲区建立一张空闲盘块表，每个空闲区对应于一个空闲 表项，其中包括表项序号、该空闲区第一个盘块号、该区的空闲盘块数等信息。再将所有空闲区按其起始盘块号递增的次序排列，见下表。</p>
<p>空闲盘块表：<br><img src="/uploads/multithreads-basic-knowledge/110.jpg" alt="image"></p>
<p>空闲盘区的分配与内存的动态分配类似，同样是釆用首次适应算法、循环首次适应算法等。例如，在系统为某新创建的文件分配空闲盘块时，先顺序地检索空闲盘块表的各表项，直至找到第一个其大小能满足要求的空闲区，再将该盘区分配给用户，同时修改空闲盘块表。 系统在对用户所释放的存储空间进行回收时，也釆取类似于内存回收的方法，即要考虑回收区是否与空闲表中插入点的前区和后区相邻接，对相邻接者应予以合并。</p>
<p>②空闲链表法<br>将所有空闲盘区拉成一条空闲链，根据构成链所用的基本元素不同，可把链表分成两种形式：<strong>空闲盘块链和空闲盘区链</strong>。</p>
<p>空闲盘块链是将磁盘上的所有空闲空间，以盘块为单位拉成一条链。当用户因创建文件 而请求分配存储空间时，系统从链首开始，依次摘下适当的数目的空闲盘块分配给用户。当 用户因删除文件而释放存储空间时，系统将回收的盘块依次插入空闲盘块链的末尾。这种方法的优点是分配和回收一个盘块的过程非常简单，但在为一个文件分配盘块时，可能要重复多次操作。</p>
<p>空闲盘区链是将磁盘上的所有空闲盘区（每个盘区可包含若干个盘块）拉成一条链。在每个盘区上除含有用于指示下一个空闲盘区的指针外，还应有能指明本盘区大小（盘块数） 的信息。分配盘区的方法与内存的动态分区分配类似，通常釆用首次适应算法。在回收盘区时，同样也要将回收区与相邻接的空闲盘区相合并。</p>
<p>③位示图法<br>位示图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有 一个二进制位与之对应。当其值为“0”时，表示对应的盘块空闲；当其值为“1”时，表示对应的盘块已分配。</p>
<p>盘块的分配：<br>1、顺序扫描位示图，从中找出一个或一组其值为“0”的二进制位。<br>2、将所找到的一个或一组二进制位，转换成与之对应的盘块号。假定找到的其值为“0” 的二进制位，位于位示图的第i行、第j列，则其相应的盘块号应按下式计算（n代表每行 的位数）：<br>    b = n (i-1) + j<br>3、修改位示图，令map[i, j] = 1。</p>
<p>盘块的回收：<br>1、将回收盘块的盘块号转换成位示图中的行号和列号。<br>2、转换公式为<br>    i=(b-1)DIVn+l<br>    j=(b-l)MOD n+1<br>3、修改位示图，令map[i, j] = 0。</p>
<p>④成组链接法<br>空闲表法和空闲链表法都不适合用于大型文件系统，因为这会使空闲表或空闲链表太大。在UNIX系统中釆用的是成组链接法，这种方法结合了空闲表和空闲链表两种方法，克服了表太大的缺点。其大致的思想是：<br>把顺序的n个空闲扇区地址保存在第一个空闲扇区内， 其后一个空闲扇区内则保存另一顺序空闲扇区的地址，如此继续，直至所有空闲扇区均予以链接。系统只需要保存一个指向第一个空闲扇区的指针。假设磁盘最初全为空闲扇区；其成组链接如下图所示。通过这种方式可以迅速找到大批空闲块地址。</p>
<p>成组链接法示意图：<br><img src="/uploads/multithreads-basic-knowledge/111.jpg" alt="image"></p>
<p>表示文件存储器空闲空间的“位向量”表或第一个成组链块以及卷中的目录区、文件区划分信息都需要存放在辅存储器中，一般放在卷头位置，在UNIX系统中称为“超级块”。<br>在对卷中文件进行操作前，“超级块”需要预先读入系统空间的主存，并且经常保持主存“超 级块”与辅存卷中“超级块”的一致性。</p>
<p>注意：本书如无特别提示，所使用的位示图法，行和列都是从1开始编号。特别注意，如果题目中指明从0开始编号，则上述的计算方法要进行相应调整。</p>
<h2 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h2><p>磁盘(Disk)是由表面涂有磁性物质的金属或塑料构成的圆形盘片，通过一个称为磁头的导体线圈从磁盘中存取数据。在读/写操作期间，磁头固定，磁盘在下面高速旋转。</p>
<p>如下所示，磁盘的盘面上的数据存储在一组同心圆中，称为磁道。每个磁道与磁头一样宽, 一个盘面有上千个磁道。磁道又划分为几百个扇区，每个扇区固定存储大小（通常为512B), 一个扇区称为一个盘块。相邻磁道及相邻扇区间通过一定的间隙分隔开，以避免精度错误。</p>
<p><img src="/uploads/multithreads-basic-knowledge/112.jpg" alt="image"></p>
<blockquote>
<p>注意，由于扇区按<strong>固定圆心角度</strong>划分，所以密度从最内而外道递减，磁盘的存储能力受限于最内道的最大密度。</p>
</blockquote>
<p>磁盘安装在一个磁盘驱动器中，它由磁头臂、用于旋转磁盘的主轴和用于数据输入/输出的电子设备组成。如下图所示，多个盘片垂直堆叠，组成磁盘组，每个盘面对应一个磁头，所有磁头固定在一起，与磁盘中心的距离相同且一起移动。所有盘片上相对位置相同的磁道组成柱面。按照这种物理结构组织，扇区就是磁盘可寻址的最小存储单位，磁盘地址用“柱面号 • 盘面号 • 扇区号（或块号）”表示。</p>
<p>磁盘按不同方式可以分为若干类型：磁头相对于盘片的径向方向固定的称为<strong>固定头磁盘</strong>，每个磁道一个磁头；磁头可移动的称为<strong>活动头磁盘</strong>，磁头臂可以来回伸缩定位磁道。磁盘永久固定在磁盘驱动器内的称为<strong>固定盘磁盘</strong>；可移动和替换的称为<strong>可换盘磁盘</strong>。</p>
<h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><p>一次磁盘读写操作的时间由<strong>寻找（寻道）时间、延迟时间和传输时间</strong>决定：</p>
<p>1) 寻找时间Ts：活动头磁盘在读写信息前，将磁头移动到指定磁道所需要的时间。这个时间除跨越n条磁道的时间外，还包括启动磁臂的时间s，即：<br><img src="/uploads/multithreads-basic-knowledge/119.gif" alt="image"><br>式中，m是与磁盘驱动器速度有关的常数，约为0.2ms，磁臂的启动时间约为2ms。</p>
<p>2)延迟时间Tr：磁头定位到某一磁道的扇区（块号）所需要的时间，设磁盘的旋转速度为r，则：<br><img src="/uploads/multithreads-basic-knowledge/120.gif" alt="image"><br>对于硬盘，典型的旋转速度为5400r/m，相当于一周11.1ms，则Tr为5.55ms;对于软盘，其旋转速度在300~600r/m之间，则Tr为50~100ms。</p>
<p>3) 传输时间Tt：从磁盘读出或向磁盘写入数据所经历的时间，这个时间取决于每次所读/写的字节数b和磁盘的旋转速度：<br><img src="/uploads/multithreads-basic-knowledge/121.gif" alt="image"><br>式中，r为磁盘每秒钟的转数；N为一个磁道上的字节数。</p>
<p>在磁盘存取时间的计算中，寻道时间与磁盘调度算法相关，下面将会介绍分析几种算法，而<strong>延迟时间和传输时间都与磁盘旋转速度相关，且为线性相关，所以在硬件上，转速是磁盘性能的一个非常重要的参数</strong>。</p>
<p>总平均存取时间Ta可以表示为：<br><img src="/uploads/multithreads-basic-knowledge/122.gif" alt="image"></p>
<p>虽然这里给出了总平均存取时间的公式，但是这个平均值是没有太大实际意义的，因为在实际的磁盘I/O操作中，存取时间与磁盘调度算法密切相关。<br>调度算法直接决定寻找时间，从而决定了总的存取时间。</p>
<p>目前常用的磁盘调度算法有以下几种：</p>
<h3 id="先来先服务-First-Come-First-Served-FCFS-算法"><a href="#先来先服务-First-Come-First-Served-FCFS-算法" class="headerlink" title="先来先服务(First Come First Served, FCFS)算法"></a>先来先服务(First Come First Served, FCFS)算法</h3><p>FCFS算法根据进程请求访问磁盘的先后顺序进行调度，这是一种最简单的调度算法，如下图所示。该算法的优点是具有公平性。如果只有少量进程需要访问，且大部分请求都是访问簇聚的文件扇区，则有望达到较好的性能；但如果有大量进程竞争使用磁盘，那么这种算法在性能上往往接近于随机调度。所以，实际磁盘调度中考虑一些更为复杂的调度算法。</p>
<p>FCFS磁盘调度算法：<br><img src="/uploads/multithreads-basic-knowledge/113.jpg" alt="image"></p>
<p>例如，磁盘请求队列中的请求顺序分别为55、58、39、18、90、160、150、38、184，磁头初始位置是100磁道，釆用FCFS算法磁头的运动过程如上图所示。<br>磁头共移动了 (45+3+19+21+72+70+10+112+146)=498 个磁道，平均寻找长度=498/9=55.3。</p>
<h3 id="最短寻找时间优先-Shortest-Seek-Time-First-SSTF-算法"><a href="#最短寻找时间优先-Shortest-Seek-Time-First-SSTF-算法" class="headerlink" title="最短寻找时间优先(Shortest  Seek  Time  First, SSTF)算法"></a>最短寻找时间优先(Shortest  Seek  Time  First, SSTF)算法</h3><p>SSTF算法选择调度处理的磁道是与当前磁头所在磁道距离最近的磁道，以使每次的寻找时间最短。当然，总是选择最小寻找时间并不能保证平均寻找时间最小，但是能提供比 FCFS算法更好的性能。这种算法会产生“饥饿”现象。如图4-26所示，若某时刻磁头正在 18号磁道，而在18号磁道附近频繁地增加新的请求，那么SSTF算法使得磁头长时间在18 号磁道附近工作，将使184号磁道的访问被无限期地延迟，即被“饿死”。</p>
<p>SSTF磁盘调度算法：<br><img src="/uploads/multithreads-basic-knowledge/114.jpg" alt="image"></p>
<p>例如，磁盘请求队列中的请求顺序分别为55、58、39、18、90、160、150、38、184，磁头初始位置是100磁道，釆用SSTF算法磁头的运动过程如上图所示。<br>磁头共移动了 (10+32+3+16+1+20+132+10+24)=248 个磁道，平均寻找长度=248/9=27.5。</p>
<h3 id="扫描-SCAN-算法（又称电梯算法）"><a href="#扫描-SCAN-算法（又称电梯算法）" class="headerlink" title="扫描(SCAN)算法（又称电梯算法）"></a>扫描(SCAN)算法（又称电梯算法）</h3><p>SCAN算法在磁头当前移动方向上选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象，如下图所示。由于磁头移动规律与电梯运行相似，故又称为电梯调度算法。SCAN算法对最近扫描过的区域不公平，因此，它在访问局部性方面不如FCFS算法和 SSTF算法好。</p>
<p>SCAN磁盘调度算法：<br><img src="/uploads/multithreads-basic-knowledge/115.jpg" alt="image"></p>
<p>例如，磁盘请求队列中的请求顺序分别为55、58、39、18、90、160、150、38、184，磁头初始位置是100 磁道。釆用SCAN算法时，不但要知道磁头的当前位置，还要知道磁头的移动方向，假设磁头沿磁道号增大的顺序移动，则磁头的运动过程如上图所示。</p>
<p>磁头共移动了(50+10+24+94+32+3+16+1+20)=250 个磁道，平均寻找长度=250/9=27.8。</p>
<h3 id="循环扫描-Circulair-SCAN-C-SCAN-算法"><a href="#循环扫描-Circulair-SCAN-C-SCAN-算法" class="headerlink" title="循环扫描(Circulair SCAN, C-SCAN)算法"></a>循环扫描(Circulair SCAN, C-SCAN)算法</h3><p>在扫描算法的基础上规定磁头单向移动来提供服务，回返时直接快速移动至起始端而不服务任何请求。由于SCAN算法偏向于处理那些接近最里或最外的磁道的访问请求，所以使用改进型的C-SCAN算法来避免这个问题。</p>
<p>釆用SCAN算法和C-SCAN算法时磁头总是严格地遵循从盘面的一端到另一端，显然，在实际使用时还可以改进，即磁头移动只需要到达最远端的一个请求即可返回，不需要到达磁盘端点。这种形式的SCAN算法和C-SCAN算法称为LOOK和C-LOOK调度。这是因为它们在朝一个给定方向移动前会查看是否有请求。注意，若无特别说明，也可以默认SCAN算法和C-SCAN算法为LOOK和C-LOOK调度。</p>
<p>C-SCAN磁盘调度算法：<br><img src="/uploads/multithreads-basic-knowledge/116.jpg" alt="image"></p>
<p>例如，磁盘请求队列中的请求顺序分别为55、58、39、18、90、160、150、38、184，磁头初始位置是100磁道。釆用C-SCAN算法时，假设磁头沿磁道号增大的顺序移动，则磁头的运动过程如图4-28所示。</p>
<p>磁头共移动了(50+10+24+166+20+1+16+3+32)=322个磁道，平均寻道长度=322/9=35.8。</p>
<p>对比以上几种磁盘调度算法：<br>FCFS算法太过简单，性能较差，仅在请求队列长度接近于1时才较为理想；<br>SSTF算法较为通用和自然；<br>SCAN算法和C-SCAN算法在磁盘负载较大时比较占优势。</p>
<p><img src="/uploads/multithreads-basic-knowledge/117.jpg" alt="image"></p>
<p>除减少寻找时间外，减少延迟时间也是提高磁盘传输效率的重要因素。<br>可以对盘面扇区进行交替编号，对磁盘片组中的不同盘面<strong>错位命名</strong>。<br>假设每个盘面有8个扇区，磁盘片组共8个盘面，则可以釆用如下图所示的编号。</p>
<p>磁盘片组扇区编号：<br><img src="/uploads/multithreads-basic-knowledge/118.jpg" alt="image"></p>
<p>磁盘是连续自转设备，磁头读/写一个物理块后，需要经过短暂的处理时间才能开始读/写下一块。假设逻辑记录数据连续存放在磁盘空间中，若在盘面上按扇区交替编号连续存放，则连续读/写多个记录时能减少磁头的延迟时间；同柱面不同盘面的扇区若能错位编号，连续读/写相邻两个盘面的逻辑记录时也能减少磁头延迟时间。</p>
<p>由于传输时间由磁盘转速决定，所以无法通过其他方法减少传输时间。以上图为例，在随机扇区访问情况下，定位磁道中的一个扇区平均需要转过4个扇区，这时，延迟时间是传输时间的4倍，这是一种非常低效的存取方式。理想化的情况是不需要定位而直接连续读取扇区，没有延迟时间，这样磁盘数据存取效率可以成倍提高。但是由于读取扇区的顺序是不可预测的，所以延迟时间不可避免。上图中的编号方式是读取连续编号扇区时的一种方法。</p>
<h2 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h2><h3 id="磁盘初始化"><a href="#磁盘初始化" class="headerlink" title="磁盘初始化"></a>磁盘初始化</h3><p>一个新的磁盘只是一个含有磁性记录材料的空白盘。在磁盘能存储数据之前，它必须<strong>分成扇区</strong>以便磁盘控制器能进行<strong>读和写</strong>操作，这个过程称为<strong>低级格式化（物理分区）</strong>。低级格式化为磁盘的每个扇区釆用特别的数据结构。每个扇区的数据结构通常由头、数据区域（通常为512B大小）和尾部组成。头部和尾部包含了一些磁盘控制器所使用的信息。</p>
<p>为了使用磁盘存储文件，操作系统还需要将自己的数据结构记录在磁盘上：第一步将磁盘分为由一个或多个<strong>柱面组成的分区</strong>（即我们熟悉的C盘、D盘等形式的分区）；第二步对物理分区进行<strong>逻辑格式化（创建文件系统)</strong>，操作系统将初始的文件系统数据结构存储到磁盘上，这些数据结构包括空闲和已分配的空间以及一个初始为空的目录。</p>
<h3 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h3><p>计算机启动时需要运行一个<strong>初始化程序（自举程序）</strong>，它初始化CPU、寄存器、设备控制器和内存等，接着启动操作系统。为此，该自举程序应找到磁盘上的操作系统内核，装入内存，并转到起始地址，从而开始操作系统的运行。</p>
<p>自举程序通常保存在ROM中，为了避免改变自举代码需要改变ROM硬件的问题，故只在ROM中保留很小的<strong>自举装入程序</strong>，将<strong>完整功能的自举程序保存在磁盘的启动块</strong>上，启动块位于磁盘的<strong>固定位</strong>（会给予保护）。拥有启动分区的磁盘称为启动磁盘或者系统磁盘。</p>
<h3 id="坏块"><a href="#坏块" class="headerlink" title="坏块"></a>坏块</h3><p>由于磁盘有移动部件且容错能力弱，所以容易导致一个或多个<strong>扇区损坏</strong>。部分磁盘甚至从出厂时就有坏扇区。根据所使用的磁盘和控制器，对这些块有多种处理方式。</p>
<p>对于简单磁盘，如电子集成驱动器（IDE)。坏扇区可手工处理，如MS-DOS的Format命令执行逻辑格式化时便会扫描磁盘以检查坏扇区。坏扇区在FAT表上会标明，因此程序不会使用。</p>
<p>对于复杂的磁盘，如小型计算机系统接口（SCSI)，其控制器维护一个<strong>磁盘坏块链表</strong>。该链表在出厂前进行低级格式化时就初始化了，并在磁盘的整个使用过程中不断更新。<br>低级格式化将一些块保留作为备用，对操作系统透明。控制器可以用备用块来逻辑地替代坏块，这种方案称为<strong>扇区备用</strong>。</p>
<h2 id="总结思考"><a href="#总结思考" class="headerlink" title="总结思考"></a>总结思考</h2><h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><blockquote>
<p>引导控制块(Boot Control Block)包括系统从该分区引导操作系统所需要的信息。</p>
</blockquote>
<p>如果磁盘没有操作系统，那么这块的内容为空。它通常为分区的<strong>第一块</strong>。<br>UFS称其为引导块(Boot Block)；<br>NTFS称其为分区引导扇区(Partition Boot Sector)。</p>
<p>分区控制块(Partition Control Block)包括<strong>分区详细信息</strong>，如分区的块数、块的大小、空闲块的数量和指计、空闲FCB的数量和指针等。<br>UPS称其为超级块(Superblock)；<br>NTFS称其为主控文件表(Master File Table)。</p>
<h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p><strong>内存分区表</strong>包含所有安装分区的信息。</p>
<p><strong>内存目录结构</strong>用来保存近来访问过的目录信息。对安装分区的目录，可以包括一个指向分区表的指针。</p>
<p>系统范围的<strong>打开文件表</strong>，包括每个打开文件的FCB复制和其他信息。</p>
<p>单个进程的打开文件表，包括一个指向系统范围内已打开文件表中合适条目和其他信息的指针。</p>
<h3 id="文件系统实现概述"><a href="#文件系统实现概述" class="headerlink" title="文件系统实现概述"></a>文件系统实现概述</h3><p>为了创建一个文件，应用程序调用逻辑文件系统。逻辑文件系统知道目录结构形式，它将分配一个新的FCB给文件，把相应目录读入内存，用新的文件名更新该目录和FCB，并将结果写回到磁盘。</p>
<p>典型的FCB：<br><img src="/uploads/multithreads-basic-knowledge/123.jpg" alt="image"></p>
<p>一旦文件被创建，它就能用于I/O，不过首先要打开文件。调用open将文件名传给文件系统，文件系统根据给定文件名搜索目录结构。部分目录结构通常缓存在内存中以加快目录 操作。找到文件后，其FCB复制到系统范围的打开文件表。该表不但存储FCB，也有打开该文件的进程数量的条目。</p>
<p>然后，单个进程的打开文件表中会增加一个条目，并通过指针将系统范围的打开文件表的条目同其他域（文件当前位置的指针和文件打开模式等）相连。调用open返回的是一个 指向单个进程的打开文件表中合适条目的指针。<strong>所有文件操作都是通过该指针进行</strong>。</p>
<p>文件名不必是打开文件表的一部分，因为一旦完成对FCB在磁盘上的定位，系统就不再使用文件名了。对于访问打开文件表的索引，UNIX称之为文件描述符(File Descriptor)；而Windows 2000称之为文件句柄(File Handle)。因此，<strong>只要文件没有被关闭，所有文件操作通过打开文件表查表来进行</strong>。</p>
<p>当一个进程关闭文件，就删除一个相应的单个进程打开文件表的条目即目录项，系统范围内打开文件表的打开数也会递减。<br>当打开文件的所有用户都关闭了一个文件时，更新的文件信息会复制到磁盘的目录结构中，系统范围的打开文件表的条目也将删除。</p>
<p>在实际中，系统调用open会首先搜索系统范围的打开文件表以确定某文件是否已被其他进程所使用。<br>如果是，就在单个进程的打开文件表中创建一项，并指向现有系统范围的打开文件表的相应条目。<br>该算法在文件已打开时，能节省大量开销。</p>
<h3 id="混合索引分配的实现"><a href="#混合索引分配的实现" class="headerlink" title="混合索引分配的实现"></a>混合索引分配的实现</h3><p>混合索引分配已在UNIX系统中釆用。</p>
<p>在UNK SystemV的索引结点中，共设置了13个地址项，即iaddr(O)~iaddr(12)，如下图所示。<br>在BSD UNIX的索引结点中，共设置了13个地址项，它们都把所有的地址项分成两类，即<strong>直接地址和间接地址</strong>。</p>
<p>UNIX系统的inode结构示意图：<br><img src="/uploads/multithreads-basic-knowledge/124.jpg" alt="image"></p>
<p>1) 直接地址</p>
<p>为了提高对文件的检索速度，在索引结点中可设置10个直接地址项，即用iaddr(O)~iaddr(9)来存放直接地址。<br>换言之，在这里的每项中所存放的是该文件数据所在盘块的盘块号。<br>假如每个盘块的大小为4KB，当文件不大于40KB时，便可直接从索引结点中读出该文件的全部盘块号。</p>
<p>2) 一次间接地址</p>
<p>对于大、中型文件，只釆用直接地址并不现实。可再利用索引结点中的地址项iaddr(lO) 来提供一次间接地址。这种方式的实质就是一级索引分配方式。图中的一次间址块也就是索引块，系统将分配给文件的多个盘块号记入其中。在一次间址块中可存放1024个盘块号， 因而允许文件长达4MB。</p>
<p>3) 多次间接地址</p>
<p>当文件长度大于4MB+40KB（—次间址与10个直接地址项）时，系统还须釆用二次间址分配方式。这时，用地址项iaddr(11)提供二次间接地址。该方式的实质是两级索引分配方 式。系统此时是在二次间址块中记入所有一次间址块的盘号。在釆用二次间址方式时，文件最大长度可达4GB。同理，地址项iaddr(12)作为三次间接地址，其所允许的文件最大长度可达4TB。</p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Chain Qian
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://www.leechain.top/2017/07/21-operation-system-file/" title="操作系统原理之文件管理">https://www.leechain.top/2017/07/21-operation-system-file/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/转载/" rel="tag"># 转载</a>
          
            <a href="/tags/学习/" rel="tag"># 学习</a>
          
            <a href="/tags/操作系统/" rel="tag"># 操作系统</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/07/15-operation-system-basic-knowledge/" rel="next" title="操作系统原理之基础知识">
                <i class="fa fa-chevron-left"></i> 操作系统原理之基础知识
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/07/25-operation-system-memory/" rel="prev" title="操作系统原理之内存管理">
                操作系统原理之内存管理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="SOHUCS"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Chain Qian">
            
              <p class="site-author-name" itemprop="name">Chain Qian</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">75</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/ChainGit" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:chainz@foxmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#操作系统原理之文件管理"><span class="nav-number">1.</span> <span class="nav-text">操作系统原理之文件管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#文件的概念和定义"><span class="nav-number">1.1.</span> <span class="nav-text">文件的概念和定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据项"><span class="nav-number">1.1.1.</span> <span class="nav-text">数据项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#记录"><span class="nav-number">1.1.2.</span> <span class="nav-text">记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件"><span class="nav-number">1.1.3.</span> <span class="nav-text">文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件的属性"><span class="nav-number">1.2.</span> <span class="nav-text">文件的属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件的基本橾作"><span class="nav-number">1.3.</span> <span class="nav-text">文件的基本橾作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件的打开与关闭"><span class="nav-number">1.4.</span> <span class="nav-text">文件的打开与关闭</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件的逻辑结构"><span class="nav-number">1.5.</span> <span class="nav-text">文件的逻辑结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#无结构文件（流式文件）"><span class="nav-number">1.5.1.</span> <span class="nav-text">无结构文件（流式文件）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有结构文件（记录式文件）"><span class="nav-number">1.5.2.</span> <span class="nav-text">有结构文件（记录式文件）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#顺序文件"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">顺序文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引文件。"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">索引文件。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引顺序文件。"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">索引顺序文件。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#直接文件或散列文件-Hash-File"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">直接文件或散列文件(Hash File)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件的目录结构"><span class="nav-number">1.6.</span> <span class="nav-text">文件的目录结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件控制块和索引结点"><span class="nav-number">1.6.1.</span> <span class="nav-text">文件控制块和索引结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目录结构"><span class="nav-number">1.6.2.</span> <span class="nav-text">目录结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单级目录结构"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">单级目录结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#两级目录结构"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">两级目录结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多级目录结构（树形目录结构-。"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">多级目录结构（树形目录结构)。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#无环图目录结构。"><span class="nav-number">1.6.2.4.</span> <span class="nav-text">无环图目录结构。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#共享文件"><span class="nav-number">1.7.</span> <span class="nav-text">共享文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基于索引结点的共享方式（硬链接）"><span class="nav-number">1.7.1.</span> <span class="nav-text">基于索引结点的共享方式（硬链接）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用符号链实现文件共享（软链接）"><span class="nav-number">1.7.2.</span> <span class="nav-text">利用符号链实现文件共享（软链接）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件保护"><span class="nav-number">1.8.</span> <span class="nav-text">文件保护</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#访问类型"><span class="nav-number">1.8.1.</span> <span class="nav-text">访问类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问控制"><span class="nav-number">1.8.2.</span> <span class="nav-text">访问控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件系统层次结构"><span class="nav-number">1.9.</span> <span class="nav-text">文件系统层次结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件系统的实现"><span class="nav-number">1.10.</span> <span class="nav-text">文件系统的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目录实现"><span class="nav-number">1.10.1.</span> <span class="nav-text">目录实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线性列表"><span class="nav-number">1.10.1.1.</span> <span class="nav-text">线性列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#哈希表"><span class="nav-number">1.10.1.2.</span> <span class="nav-text">哈希表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件实现"><span class="nav-number">1.10.2.</span> <span class="nav-text">文件实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件分配方式"><span class="nav-number">1.10.2.1.</span> <span class="nav-text">文件分配方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件存储空间管理"><span class="nav-number">1.10.2.2.</span> <span class="nav-text">文件存储空间管理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#磁盘的结构"><span class="nav-number">1.11.</span> <span class="nav-text">磁盘的结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#磁盘调度算法"><span class="nav-number">1.12.</span> <span class="nav-text">磁盘调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#先来先服务-First-Come-First-Served-FCFS-算法"><span class="nav-number">1.12.1.</span> <span class="nav-text">先来先服务(First Come First Served, FCFS)算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最短寻找时间优先-Shortest-Seek-Time-First-SSTF-算法"><span class="nav-number">1.12.2.</span> <span class="nav-text">最短寻找时间优先(Shortest  Seek  Time  First, SSTF)算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扫描-SCAN-算法（又称电梯算法）"><span class="nav-number">1.12.3.</span> <span class="nav-text">扫描(SCAN)算法（又称电梯算法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环扫描-Circulair-SCAN-C-SCAN-算法"><span class="nav-number">1.12.4.</span> <span class="nav-text">循环扫描(Circulair SCAN, C-SCAN)算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#磁盘的管理"><span class="nav-number">1.13.</span> <span class="nav-text">磁盘的管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#磁盘初始化"><span class="nav-number">1.13.1.</span> <span class="nav-text">磁盘初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引导块"><span class="nav-number">1.13.2.</span> <span class="nav-text">引导块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#坏块"><span class="nav-number">1.13.3.</span> <span class="nav-text">坏块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结思考"><span class="nav-number">1.14.</span> <span class="nav-text">总结思考</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#磁盘结构"><span class="nav-number">1.14.1.</span> <span class="nav-text">磁盘结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存结构"><span class="nav-number">1.14.2.</span> <span class="nav-text">内存结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件系统实现概述"><span class="nav-number">1.14.3.</span> <span class="nav-text">文件系统实现概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#混合索引分配的实现"><span class="nav-number">1.14.4.</span> <span class="nav-text">混合索引分配的实现</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chain Qian</span>

  
</div>








  <div class="footer-custom">苏ICP备16052713号-1</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  




  
    <script type="text/javascript">
    (function(){
      var appid = 'cyt7Bknuv';
      var conf = 'prod_ef64fab63ed9004614a7a77b40203358';
      var width = window.innerWidth || document.documentElement.clientWidth;
      if (width < 960) {
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){
        window.changyan.api.config({appid:appid,conf:conf})});
      }
    })();
    </script>
    <script type="text/javascript" src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script>
  









  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script>


  

</body>
</html>
